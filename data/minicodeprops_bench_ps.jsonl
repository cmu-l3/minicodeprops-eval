{"full_name": "prop_01", "prop_defn": "theorem prop_01 (n: Nat) (xs: List \u03b1) :\n List.take n xs ++ List.drop n xs = xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:19", "score": 5, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\nn : \u2115\nxs : List \u03b1\n\u22a2 List.take n xs ++ List.drop n xs = xs", "file_locs": "LeanSrc/LeanSrc/Properties.lean:20"}
{"full_name": "prop_02", "prop_defn": "theorem prop_02 (n: Nat) (xs: List Nat) (ys: List Nat) :\n List.count n xs + List.count n ys = List.count n (xs ++ ys):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:23", "score": 5, "deps": "import Mathlib", "proof_state": "n : \u2115\nxs ys : List \u2115\n\u22a2 List.count n xs + List.count n ys = List.count n (xs ++ ys)", "file_locs": "LeanSrc/LeanSrc/Properties.lean:24"}
{"full_name": "prop_03", "prop_defn": "theorem prop_03 (n: Nat) (xs: List Nat) (ys: List Nat) :\n List.count n xs <= List.count n (xs ++ ys):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:27", "score": 4, "deps": "import Mathlib", "proof_state": "n : \u2115\nxs ys : List \u2115\n\u22a2 List.count n xs \u2264 List.count n (xs ++ ys)", "file_locs": "LeanSrc/LeanSrc/Properties.lean:28"}
{"full_name": "prop_04", "prop_defn": "theorem prop_04 (n: Nat) (xs: List Nat) :\n  (List.count n xs).succ = List.count n (n :: xs):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:31", "score": 3, "deps": "import Mathlib", "proof_state": "n : \u2115\nxs : List \u2115\n\u22a2 (List.count n xs).succ = List.count n (n :: xs)", "file_locs": "LeanSrc/LeanSrc/Properties.lean:32"}
{"full_name": "prop_05", "prop_defn": "theorem prop_05 (n: Nat) (x: Nat) (xs: List Nat) :\n (n = x) \u2192  (List.count n xs).succ = List.count n (x :: xs):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:35", "score": 4, "deps": "import Mathlib", "proof_state": "n x : \u2115\nxs : List \u2115\n\u22a2 n = x \u2192 (List.count n xs).succ = List.count n (x :: xs)", "file_locs": "LeanSrc/LeanSrc/Properties.lean:36"}
{"full_name": "prop_06", "prop_defn": "theorem prop_06 (n: Nat) (m: Nat) :\n (n - (n + m) = 0):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:39", "score": 2, "deps": "import Mathlib", "proof_state": "n m : \u2115\n\u22a2 n - (n + m) = 0", "file_locs": "LeanSrc/LeanSrc/Properties.lean:40"}
{"full_name": "prop_07", "prop_defn": "theorem prop_07 (n: Nat) (m: Nat) :\n ((n + m) - n = m):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:43", "score": 1, "deps": "import Mathlib", "proof_state": "n m : \u2115\n\u22a2 n + m - n = m", "file_locs": "LeanSrc/LeanSrc/Properties.lean:44"}
{"full_name": "prop_08", "prop_defn": "theorem prop_08 (k:Nat) (m: Nat) (n: Nat) :\n  ((k + m) - (k + n) = m - n):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:47", "score": 3, "deps": "import Mathlib", "proof_state": "k m n : \u2115\n\u22a2 k + m - (k + n) = m - n", "file_locs": "LeanSrc/LeanSrc/Properties.lean:48"}
{"full_name": "prop_09", "prop_defn": "theorem prop_09 (i: Nat) (j: Nat) (k: Nat) :\n  ((i - j) - k = i - (j + k)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:51", "score": 2, "deps": "import Mathlib", "proof_state": "i j k : \u2115\n\u22a2 i - j - k = i - (j + k)", "file_locs": "LeanSrc/LeanSrc/Properties.lean:52"}
{"full_name": "prop_10", "prop_defn": "theorem prop_10 (m: Nat) :\n (m - m = 0):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:55", "score": 1, "deps": "import Mathlib", "proof_state": "m : \u2115\n\u22a2 m - m = 0", "file_locs": "LeanSrc/LeanSrc/Properties.lean:56"}
{"full_name": "prop_11", "prop_defn": "theorem prop_11 (xs: List \u03b1) :\n   (List.drop 0 xs = xs):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:59", "score": 3, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\nxs : List \u03b1\n\u22a2 List.drop 0 xs = xs", "file_locs": "LeanSrc/LeanSrc/Properties.lean:60"}
{"full_name": "prop_12", "prop_defn": "theorem prop_12 (n: Nat) (f: \u03b1 \u2192 \u03b1) (xs: List \u03b1) :\n   (List.drop n (List.map f xs) = List.map f (List.drop n xs)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:63", "score": 5, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\nn : \u2115\nf : \u03b1 \u2192 \u03b1\nxs : List \u03b1\n\u22a2 List.drop n (List.map f xs) = List.map f (List.drop n xs)", "file_locs": "LeanSrc/LeanSrc/Properties.lean:64"}
{"full_name": "prop_13", "prop_defn": "theorem prop_13 (n: Nat) (x: \u03b1) (xs: List \u03b1) :\n (List.drop n.succ (x :: xs) = List.drop n xs):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:67", "score": 5, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\nn : \u2115\nx : \u03b1\nxs : List \u03b1\n\u22a2 List.drop n.succ (x :: xs) = List.drop n xs", "file_locs": "LeanSrc/LeanSrc/Properties.lean:68"}
{"full_name": "prop_14", "prop_defn": "theorem prop_14 (p: \u03b1 \u2192 Bool) (xs: List \u03b1) (ys: List \u03b1) :\n  (List.filter p (xs ++ ys) = (List.filter p xs) ++ (List.filter p ys)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:71", "score": 5, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nxs ys : List \u03b1\n\u22a2 List.filter p (xs ++ ys) = List.filter p xs ++ List.filter p ys", "file_locs": "LeanSrc/LeanSrc/Properties.lean:72"}
{"full_name": "prop_15", "prop_defn": "theorem prop_15 (x: Nat) (xs: List Nat) :\n  (List.length (ins x xs)) = (List.length xs).succ:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:75", "score": 5, "deps": "import Mathlib\n\ndef ins: Nat \u2192 List Nat \u2192 List Nat\n  | n, []  =>  [n]\n  | n, x::xs => if (n < x) then n :: x :: xs else x :: (ins n xs)\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (ins x xs).length = xs.length.succ", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:202&&LeanSrc/LeanSrc/Properties.lean:76"}
{"full_name": "prop_16", "prop_defn": "theorem prop_16 (x: Nat) (xs: List Nat) :\n xs = [] \u2192  last (x::xs) = x:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:79", "score": 5, "deps": "import Mathlib\n\ndef last: List Nat \u2192 Nat\n  | [] => 0\n  | [x] => x\n  | _x::xs => (last xs)\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 xs = [] \u2192 last (x :: xs) = x", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:207&&LeanSrc/LeanSrc/Properties.lean:80"}
{"full_name": "prop_17", "prop_defn": "theorem prop_17 (n: Nat) :\n  n <= 0 \u2194 n = 0:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:83", "score": 1, "deps": "import Mathlib", "proof_state": "n : \u2115\n\u22a2 n \u2264 0 \u2194 n = 0", "file_locs": "LeanSrc/LeanSrc/Properties.lean:84"}
{"full_name": "prop_18", "prop_defn": "theorem prop_18 i (m: Nat) :\n   i < (i + m).succ:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:87", "score": 2, "deps": "import Mathlib", "proof_state": "i m : \u2115\n\u22a2 i < (i + m).succ", "file_locs": "LeanSrc/LeanSrc/Properties.lean:88"}
{"full_name": "prop_19", "prop_defn": "theorem prop_19 (n: Nat) (xs: List Nat) :\n (List.length (List.drop n xs) = List.length xs - n):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:91", "score": 5, "deps": "import Mathlib", "proof_state": "n : \u2115\nxs : List \u2115\n\u22a2 (List.drop n xs).length = xs.length - n", "file_locs": "LeanSrc/LeanSrc/Properties.lean:92"}
{"full_name": "prop_20", "prop_defn": "theorem prop_20 (xs: List Nat) :\n  (List.length (sort xs) = List.length xs):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:96", "score": 5, "deps": "import Mathlib\n\ndef insort : Nat \u2192 List Nat \u2192 List Nat\n  | n, [] => [n]\n  | n, x::xs => if n <= x then n::x::xs else x::(insort n xs)\n\n\ndef sort : List Nat \u2192 List Nat\n  | [] => []\n  | x::xs => insort x (sort xs)\n", "proof_state": "xs : List \u2115\n\u22a2 (sort xs).length = xs.length", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:215&&LeanSrc/LeanSrc/Properties.lean:97"}
{"full_name": "prop_21", "prop_defn": "theorem prop_21 (n: Nat) (m: Nat) :\n  n <= (n + m):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:100", "score": 1, "deps": "import Mathlib", "proof_state": "n m : \u2115\n\u22a2 n \u2264 n + m", "file_locs": "LeanSrc/LeanSrc/Properties.lean:101"}
{"full_name": "prop_22", "prop_defn": "theorem prop_22 (a: Nat) (b: Nat) (c: Nat) :\n  (max (max a b) c = max a (max b c)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:104", "score": 2, "deps": "import Mathlib", "proof_state": "a b c : \u2115\n\u22a2 max (max a b) c = max a (max b c)", "file_locs": "LeanSrc/LeanSrc/Properties.lean:105"}
{"full_name": "prop_23", "prop_defn": "theorem prop_23 (a: Nat) (b: Nat) :\n  (max a b = max b a):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:108", "score": 1, "deps": "import Mathlib", "proof_state": "a b : \u2115\n\u22a2 max a b = max b a", "file_locs": "LeanSrc/LeanSrc/Properties.lean:109"}
{"full_name": "prop_24", "prop_defn": "theorem prop_24 (a: Nat) (b: Nat) :\n (((max a b) = a) \u2194 b <= a):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:112", "score": 2, "deps": "import Mathlib", "proof_state": "a b : \u2115\n\u22a2 max a b = a \u2194 b \u2264 a", "file_locs": "LeanSrc/LeanSrc/Properties.lean:113"}
{"full_name": "prop_25", "prop_defn": "theorem prop_25 (a: Nat) (b: Nat) :\n  (((max a b) = b) \u2194 a <= b):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:116", "score": 2, "deps": "import Mathlib", "proof_state": "a b : \u2115\n\u22a2 max a b = b \u2194 a \u2264 b", "file_locs": "LeanSrc/LeanSrc/Properties.lean:117"}
{"full_name": "prop_26", "prop_defn": "theorem prop_26 (x: \u03b1) (xs: List \u03b1) (ys: List \u03b1) :\n  x \u2208 xs \u2192  x \u2208 (xs ++ ys):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:120", "score": 4, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\nx : \u03b1\nxs ys : List \u03b1\n\u22a2 x \u2208 xs \u2192 x \u2208 xs ++ ys", "file_locs": "LeanSrc/LeanSrc/Properties.lean:121"}
{"full_name": "prop_27", "prop_defn": "theorem prop_27 (x: \u03b1) (xs: List \u03b1) (ys: List \u03b1) :\n x \u2208 ys \u2192 x \u2208 (xs ++ ys):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:124", "score": 4, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\nx : \u03b1\nxs ys : List \u03b1\n\u22a2 x \u2208 ys \u2192 x \u2208 xs ++ ys", "file_locs": "LeanSrc/LeanSrc/Properties.lean:125"}
{"full_name": "prop_28", "prop_defn": "theorem prop_28 (x: \u03b1) (xs: List \u03b1) :\n  x \u2208 (xs ++ [x]):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:128", "score": 4, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\nx : \u03b1\nxs : List \u03b1\n\u22a2 x \u2208 xs ++ [x]", "file_locs": "LeanSrc/LeanSrc/Properties.lean:129"}
{"full_name": "prop_29", "prop_defn": "theorem prop_29 (x: Nat) (xs: List Nat) :\n  x \u2208 ins1 x xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:132", "score": 5, "deps": "import Mathlib\n\ndef ins1 : Nat \u2192 List Nat \u2192 List Nat\n  | n, [] => [n]\n  | n, x::xs => if n == x then x::xs else x::(ins1 n xs)\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 x \u2208 ins1 x xs", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:224&&LeanSrc/LeanSrc/Properties.lean:133"}
{"full_name": "prop_30", "prop_defn": "theorem prop_30 (x: Nat) (xs: List Nat) :\n  x \u2208 ins x xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:136", "score": 5, "deps": "import Mathlib\n\ndef ins: Nat \u2192 List Nat \u2192 List Nat\n  | n, []  =>  [n]\n  | n, x::xs => if (n < x) then n :: x :: xs else x :: (ins n xs)\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 x \u2208 ins x xs", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:202&&LeanSrc/LeanSrc/Properties.lean:137"}
{"full_name": "prop_31", "prop_defn": "theorem prop_31 (a: Nat) (b: Nat) (c: Nat) :\n  min (min a b) c = min a (min b c):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:140", "score": 2, "deps": "import Mathlib", "proof_state": "a b c : \u2115\n\u22a2 min (min a b) c = min a (min b c)", "file_locs": "LeanSrc/LeanSrc/Properties.lean:141"}
{"full_name": "prop_32", "prop_defn": "theorem prop_32 (a: Nat) (b: Nat) :\n  min a b = min b a:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:144", "score": 1, "deps": "import Mathlib", "proof_state": "a b : \u2115\n\u22a2 min a b = min b a", "file_locs": "LeanSrc/LeanSrc/Properties.lean:145"}
{"full_name": "prop_33", "prop_defn": "theorem prop_33 (a: Nat) (b: Nat) :\n  min a b = a \u2194 a <= b:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:148", "score": 2, "deps": "import Mathlib", "proof_state": "a b : \u2115\n\u22a2 min a b = a \u2194 a \u2264 b", "file_locs": "LeanSrc/LeanSrc/Properties.lean:149"}
{"full_name": "prop_34", "prop_defn": "theorem prop_34 (a: Nat) (b: Nat) :\n  min a b = b \u2194 b <= a:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:152", "score": 2, "deps": "import Mathlib", "proof_state": "a b : \u2115\n\u22a2 min a b = b \u2194 b \u2264 a", "file_locs": "LeanSrc/LeanSrc/Properties.lean:153"}
{"full_name": "prop_35", "prop_defn": "theorem prop_35 (xs: List \u03b1) :\n  dropWhile (fun _ => False) xs = xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:156", "score": 5, "deps": "import Mathlib\n\ndef dropWhile : (\u03b1 \u2192 Bool) \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | p, x::xs => if p x then dropWhile p xs else x::xs\n", "proof_state": "\u03b1 : Type u_1\nxs : List \u03b1\n\u22a2 dropWhile (fun x => decide False) xs = xs", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:228&&LeanSrc/LeanSrc/Properties.lean:157"}
{"full_name": "prop_36", "prop_defn": "theorem prop_36 (xs: List \u03b1) :\n  takeWhile (fun _ => True) xs = xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:160", "score": 5, "deps": "import Mathlib\n\ndef takeWhile : (\u03b1 \u2192 Bool) \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | p, x::xs => if p x then x ::(takeWhile p xs) else []\n", "proof_state": "\u03b1 : Type u_1\nxs : List \u03b1\n\u22a2 takeWhile (fun x => decide True) xs = xs", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:232&&LeanSrc/LeanSrc/Properties.lean:161"}
{"full_name": "prop_37", "prop_defn": "theorem prop_37 (x: Nat) (xs: List Nat) :\n  not (x \u2208 delete x xs):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:164", "score": 5, "deps": "import Mathlib\n\ndef delete : Nat \u2192 List Nat \u2192 List Nat\n  | _, [] => []\n  | n, x::xs => if n == x then (delete n xs) else x::(delete n xs)\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (!decide (x \u2208 delete x xs)) = true", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:236&&LeanSrc/LeanSrc/Properties.lean:165"}
{"full_name": "prop_38", "prop_defn": "theorem prop_38 (n: Nat) (xs: List Nat) :\n  List.count n (xs ++ [n]) = (List.count n xs).succ:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:168", "score": 4, "deps": "import Mathlib", "proof_state": "n : \u2115\nxs : List \u2115\n\u22a2 List.count n (xs ++ [n]) = (List.count n xs).succ", "file_locs": "LeanSrc/LeanSrc/Properties.lean:169"}
{"full_name": "prop_39", "prop_defn": "theorem prop_39 (n: Nat) (x: Nat) (xs: List Nat) :\n  List.count n [x] + List.count n xs = List.count n (x::xs):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:172", "score": 4, "deps": "import Mathlib", "proof_state": "n x : \u2115\nxs : List \u2115\n\u22a2 List.count n [x] + List.count n xs = List.count n (x :: xs)", "file_locs": "LeanSrc/LeanSrc/Properties.lean:173"}
{"full_name": "prop_40", "prop_defn": "theorem prop_40 (xs: List \u03b1) :\n (List.take 0 xs = []):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:176", "score": 3, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\nxs : List \u03b1\n\u22a2 List.take 0 xs = []", "file_locs": "LeanSrc/LeanSrc/Properties.lean:177"}
{"full_name": "prop_41", "prop_defn": "theorem prop_41 (n: Nat) (f: \u03b1 \u2192 \u03b1) (xs: List \u03b1) :\n  (List.take n (List.map f xs) = List.map f (List.take n xs)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:180", "score": 5, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\nn : \u2115\nf : \u03b1 \u2192 \u03b1\nxs : List \u03b1\n\u22a2 List.take n (List.map f xs) = List.map f (List.take n xs)", "file_locs": "LeanSrc/LeanSrc/Properties.lean:181"}
{"full_name": "prop_42", "prop_defn": "theorem prop_42 (n: Nat) (x: \u03b1) (xs: List \u03b1) :\n  (List.take n.succ (x::xs) = x :: (List.take n xs)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:184", "score": 4, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\nn : \u2115\nx : \u03b1\nxs : List \u03b1\n\u22a2 List.take n.succ (x :: xs) = x :: List.take n xs", "file_locs": "LeanSrc/LeanSrc/Properties.lean:185"}
{"full_name": "prop_43", "prop_defn": "theorem prop_43 (p: Nat \u2192 Bool) (xs: List Nat) :\n  (takeWhile p xs ++ dropWhile p xs = xs):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:188", "score": 5, "deps": "import Mathlib\n\ndef dropWhile : (\u03b1 \u2192 Bool) \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | p, x::xs => if p x then dropWhile p xs else x::xs\n\n\ndef takeWhile : (\u03b1 \u2192 Bool) \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | p, x::xs => if p x then x ::(takeWhile p xs) else []\n", "proof_state": "p : \u2115 \u2192 Bool\nxs : List \u2115\n\u22a2 takeWhile p xs ++ dropWhile p xs = xs", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:232&&LeanSrc/LeanSrc/Properties.lean:189"}
{"full_name": "prop_44", "prop_defn": "theorem prop_44 (x: \u03b1) (xs: List \u03b1) (ys: List \u03b2) :\n  zip' (x::xs) ys = zipConcat x xs ys:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:192", "score": 5, "deps": "import Mathlib\n\ndef zip' : List \u03b1 \u2192 List \u03b2 \u2192 List (\u03b1 \u00d7 \u03b2)\n  | [], _ => []\n  | _, [] => []\n  | x::xs, y::ys => \u27e8x, y\u27e9 :: zip' xs ys\n\n\ndef zipConcat : \u03b1 \u2192 List \u03b1 \u2192 List \u03b2 \u2192 List (\u03b1 \u00d7 \u03b2)\n  | _, _, [] => []\n  | x, xs, y::ys => \u27e8x, y\u27e9 :: zip' xs ys\n", "proof_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : \u03b1\nxs : List \u03b1\nys : List \u03b2\n\u22a2 zip' (x :: xs) ys = zipConcat x xs ys", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:245&&LeanSrc/LeanSrc/Properties.lean:193"}
{"full_name": "prop_45", "prop_defn": "theorem prop_45 (x: \u03b1) (y: \u03b2) (xs: List \u03b1) (ys: List \u03b2) :\n  zip' (x::xs) (y::ys) = (x, y) :: zip' xs ys:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:196", "score": 4, "deps": "import Mathlib\n\ndef zip' : List \u03b1 \u2192 List \u03b2 \u2192 List (\u03b1 \u00d7 \u03b2)\n  | [], _ => []\n  | _, [] => []\n  | x::xs, y::ys => \u27e8x, y\u27e9 :: zip' xs ys\n", "proof_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : \u03b1\ny : \u03b2\nxs : List \u03b1\nys : List \u03b2\n\u22a2 zip' (x :: xs) (y :: ys) = (x, y) :: zip' xs ys", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:241&&LeanSrc/LeanSrc/Properties.lean:197"}
{"full_name": "prop_46", "prop_defn": "theorem prop_46 {\u03b1 \u03b2: Type} (xs: List \u03b2) :\n  zip' ([]: List \u03b1) xs = []:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:200", "score": 5, "deps": "import Mathlib\n\ndef zip' : List \u03b1 \u2192 List \u03b2 \u2192 List (\u03b1 \u00d7 \u03b2)\n  | [], _ => []\n  | _, [] => []\n  | x::xs, y::ys => \u27e8x, y\u27e9 :: zip' xs ys\n", "proof_state": "\u03b1 \u03b2 : Type\nxs : List \u03b2\n\u22a2 zip' [] xs = []", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:241&&LeanSrc/LeanSrc/Properties.lean:201"}
{"full_name": "prop_47", "prop_defn": "theorem prop_47 (a: MyTree \u03b1) :\n  (height' (mirror a) = height' a):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:204", "score": 5, "deps": "import Mathlib\n\ninductive MyTree (\u03b1: Type) where\n| leaf : MyTree \u03b1\n| node : MyTree \u03b1 \u2192 \u03b1 \u2192 MyTree \u03b1  \u2192  MyTree \u03b1\n\n\ndef height' : MyTree \u03b1 \u2192 \u2115\n  | .leaf => 0\n  | .node l _x r => (max (height' l) (height' r)).succ\n\n\ndef mirror : MyTree \u03b1 \u2192 MyTree \u03b1\n  | MyTree.leaf => MyTree.leaf\n  | MyTree.node l x r => MyTree.node r x l\n", "proof_state": "\u03b1 : Type\na : MyTree \u03b1\n\u22a2 height' (mirror a) = height' a", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:270&&LeanSrc/LeanSrc/Properties.lean:205"}
{"full_name": "prop_48", "prop_defn": "theorem prop_48 (xs: List Nat) :\n  not (null xs) \u2192 butlast xs ++ [last xs] = xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:208", "score": 5, "deps": "import Mathlib\n\ndef last: List Nat \u2192 Nat\n  | [] => 0\n  | [x] => x\n  | _x::xs => (last xs)\n\n\ndef null : List \u03b1 \u2192 Bool\n  | [] => True\n  | _ => False\n\n\ndef butlast : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | [_x] => []\n  | x::xs => x::(butlast xs)\n", "proof_state": "xs : List \u2115\n\u22a2 (!null xs) = true \u2192 butlast xs ++ [last xs] = xs", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:254&&LeanSrc/LeanSrc/Properties.lean:209"}
{"full_name": "prop_49", "prop_defn": "theorem prop_49 (xs: List Nat) (ys: List Nat) :\n  (butlast (xs ++ ys) = butlastConcat xs ys):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:212", "score": 4, "deps": "import Mathlib\n\ndef butlast : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | [_x] => []\n  | x::xs => x::(butlast xs)\n\n\ndef butlastConcat : List \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | xs, [] => butlast xs\n  | xs, ys => xs ++ butlast ys\n", "proof_state": "xs ys : List \u2115\n\u22a2 butlast (xs ++ ys) = butlastConcat xs ys", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:258&&LeanSrc/LeanSrc/Properties.lean:213"}
{"full_name": "prop_50", "prop_defn": "theorem prop_50 (xs: List \u03b1) :\n  (butlast xs = List.take (List.length xs - 1) xs):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:216", "score": 5, "deps": "import Mathlib\n\ndef butlast : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | [_x] => []\n  | x::xs => x::(butlast xs)\n", "proof_state": "\u03b1 : Type u_1\nxs : List \u03b1\n\u22a2 butlast xs = List.take (xs.length - 1) xs", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:254&&LeanSrc/LeanSrc/Properties.lean:217"}
{"full_name": "prop_51", "prop_defn": "theorem prop_51 (xs: List \u03b1) (x: \u03b1) :\n  (butlast (xs ++ [x]) = xs):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:220", "score": 5, "deps": "import Mathlib\n\ndef butlast : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | [_x] => []\n  | x::xs => x::(butlast xs)\n", "proof_state": "\u03b1 : Type u_1\nxs : List \u03b1\nx : \u03b1\n\u22a2 butlast (xs ++ [x]) = xs", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:254&&LeanSrc/LeanSrc/Properties.lean:221"}
{"full_name": "prop_52", "prop_defn": "theorem prop_52 (n: Nat) xs :\n  (List.count n xs = List.count n (List.reverse xs)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:224", "score": 5, "deps": "import Mathlib", "proof_state": "n : \u2115\nxs : List \u2115\n\u22a2 List.count n xs = List.count n xs.reverse", "file_locs": "LeanSrc/LeanSrc/Properties.lean:225"}
{"full_name": "prop_53", "prop_defn": "theorem prop_53 (n: Nat) xs :\n  (List.count n xs = List.count n (sort xs)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:229", "score": 5, "deps": "import Mathlib\n\ndef insort : Nat \u2192 List Nat \u2192 List Nat\n  | n, [] => [n]\n  | n, x::xs => if n <= x then n::x::xs else x::(insort n xs)\n\n\ndef sort : List Nat \u2192 List Nat\n  | [] => []\n  | x::xs => insort x (sort xs)\n", "proof_state": "n : \u2115\nxs : List \u2115\n\u22a2 List.count n xs = List.count n (sort xs)", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:215&&LeanSrc/LeanSrc/Properties.lean:230"}
{"full_name": "prop_54", "prop_defn": "theorem prop_54 (n: Nat) (m: Nat) :\n  ((m + n) - n = m):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:233", "score": 2, "deps": "import Mathlib", "proof_state": "n m : \u2115\n\u22a2 m + n - n = m", "file_locs": "LeanSrc/LeanSrc/Properties.lean:234"}
{"full_name": "prop_55", "prop_defn": "theorem prop_55 (n: Nat) (xs: List \u03b1) (ys: List \u03b1) :\n  (List.drop n (xs ++ ys) = List.drop n xs ++ List.drop (n - List.length xs) ys):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:237", "score": 5, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\nn : \u2115\nxs ys : List \u03b1\n\u22a2 List.drop n (xs ++ ys) = List.drop n xs ++ List.drop (n - xs.length) ys", "file_locs": "LeanSrc/LeanSrc/Properties.lean:238"}
{"full_name": "prop_56", "prop_defn": "theorem prop_56 (n: Nat) (m: Nat) (xs: List \u03b1) :\n  (List.drop n (List.drop m xs) = List.drop (n + m) xs):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:241", "score": 5, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\nn m : \u2115\nxs : List \u03b1\n\u22a2 List.drop n (List.drop m xs) = List.drop (n + m) xs", "file_locs": "LeanSrc/LeanSrc/Properties.lean:242"}
{"full_name": "prop_57", "prop_defn": "theorem prop_57 (n: Nat) (m: Nat) (xs: List \u03b1) :\n  (List.drop n (List.take m xs) = List.take (m - n) (List.drop n xs)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:245", "score": 5, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\nn m : \u2115\nxs : List \u03b1\n\u22a2 List.drop n (List.take m xs) = List.take (m - n) (List.drop n xs)", "file_locs": "LeanSrc/LeanSrc/Properties.lean:246"}
{"full_name": "prop_58", "prop_defn": "theorem prop_58 (n: Nat) (xs: List \u03b1) (ys: List \u03b2) :\n  (List.drop n (zip' xs ys) =  zip' (List.drop n xs) (List.drop n ys)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:249", "score": 5, "deps": "import Mathlib\n\ndef zip' : List \u03b1 \u2192 List \u03b2 \u2192 List (\u03b1 \u00d7 \u03b2)\n  | [], _ => []\n  | _, [] => []\n  | x::xs, y::ys => \u27e8x, y\u27e9 :: zip' xs ys\n", "proof_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\nxs : List \u03b1\nys : List \u03b2\n\u22a2 List.drop n (zip' xs ys) = zip' (List.drop n xs) (List.drop n ys)", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:241&&LeanSrc/LeanSrc/Properties.lean:250"}
{"full_name": "prop_59", "prop_defn": "theorem prop_59 (xs: List Nat) (ys: List Nat) :\n  ys = [] \u2192  last (xs ++ ys) = last xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:253", "score": 5, "deps": "import Mathlib\n\ndef last: List Nat \u2192 Nat\n  | [] => 0\n  | [x] => x\n  | _x::xs => (last xs)\n", "proof_state": "xs ys : List \u2115\n\u22a2 ys = [] \u2192 last (xs ++ ys) = last xs", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:207&&LeanSrc/LeanSrc/Properties.lean:254"}
{"full_name": "prop_60", "prop_defn": "theorem prop_60 (xs: List Nat) (ys: List Nat) :\n  not (null ys) \u2192 last (xs ++ ys) = last ys:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:257", "score": 5, "deps": "import Mathlib\n\ndef last: List Nat \u2192 Nat\n  | [] => 0\n  | [x] => x\n  | _x::xs => (last xs)\n\n\ndef null : List \u03b1 \u2192 Bool\n  | [] => True\n  | _ => False\n", "proof_state": "xs ys : List \u2115\n\u22a2 (!null ys) = true \u2192 last (xs ++ ys) = last ys", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:249&&LeanSrc/LeanSrc/Properties.lean:258"}
{"full_name": "prop_61", "prop_defn": "theorem prop_61 (xs: List Nat) (ys: List Nat) :\n  (last (xs ++ ys) = lastOfTwo xs ys):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:261", "score": 5, "deps": "import Mathlib\n\ndef last: List Nat \u2192 Nat\n  | [] => 0\n  | [x] => x\n  | _x::xs => (last xs)\n\n\ndef lastOfTwo : List \u2115 \u2192 List \u2115 \u2192 \u2115\n  | xs, [] => last xs\n  | _, ys => last ys\n", "proof_state": "xs ys : List \u2115\n\u22a2 last (xs ++ ys) = lastOfTwo xs ys", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:262&&LeanSrc/LeanSrc/Properties.lean:262"}
{"full_name": "prop_62", "prop_defn": "theorem prop_62 (xs: List Nat) (x: Nat) :\n  not (null xs) \u2192 last (x::xs) = last xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:265", "score": 5, "deps": "import Mathlib\n\ndef last: List Nat \u2192 Nat\n  | [] => 0\n  | [x] => x\n  | _x::xs => (last xs)\n\n\ndef null : List \u03b1 \u2192 Bool\n  | [] => True\n  | _ => False\n", "proof_state": "xs : List \u2115\nx : \u2115\n\u22a2 (!null xs) = true \u2192 last (x :: xs) = last xs", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:249&&LeanSrc/LeanSrc/Properties.lean:266"}
{"full_name": "prop_63", "prop_defn": "theorem prop_63 (n: Nat) (xs: List Nat) :\n  n < List.length xs \u2192 last (List.drop n xs) = last xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:269", "score": 5, "deps": "import Mathlib\n\ndef last: List Nat \u2192 Nat\n  | [] => 0\n  | [x] => x\n  | _x::xs => (last xs)\n", "proof_state": "n : \u2115\nxs : List \u2115\n\u22a2 n < xs.length \u2192 last (List.drop n xs) = last xs", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:207&&LeanSrc/LeanSrc/Properties.lean:270"}
{"full_name": "prop_64", "prop_defn": "theorem prop_64 x xs :\n  (last (xs ++ [x]) = x):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:273", "score": 5, "deps": "import Mathlib\n\ndef last: List Nat \u2192 Nat\n  | [] => 0\n  | [x] => x\n  | _x::xs => (last xs)\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 last (xs ++ [x]) = x", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:207&&LeanSrc/LeanSrc/Properties.lean:274"}
{"full_name": "prop_65", "prop_defn": "theorem prop_65 (i: Nat) (m: Nat) :\n  i < (m + i).succ:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:277", "score": 2, "deps": "import Mathlib", "proof_state": "i m : \u2115\n\u22a2 i < (m + i).succ", "file_locs": "LeanSrc/LeanSrc/Properties.lean:278"}
{"full_name": "prop_66", "prop_defn": "theorem prop_66 (p: \u03b1 \u2192 Bool) (xs: List \u03b1) :\n  List.length (List.filter p xs) <= List.length xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:281", "score": 4, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nxs : List \u03b1\n\u22a2 (List.filter p xs).length \u2264 xs.length", "file_locs": "LeanSrc/LeanSrc/Properties.lean:282"}
{"full_name": "prop_67", "prop_defn": "theorem prop_67 (xs: List Nat) :\n  List.length (butlast xs) = List.length xs - 1:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:285", "score": 5, "deps": "import Mathlib\n\ndef butlast : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | [_x] => []\n  | x::xs => x::(butlast xs)\n", "proof_state": "xs : List \u2115\n\u22a2 (butlast xs).length = xs.length - 1", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:254&&LeanSrc/LeanSrc/Properties.lean:286"}
{"full_name": "prop_68", "prop_defn": "theorem prop_68 (n: Nat) (xs: List Nat) :\n  List.length (delete n xs) <= List.length xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:289", "score": 5, "deps": "import Mathlib\n\ndef delete : Nat \u2192 List Nat \u2192 List Nat\n  | _, [] => []\n  | n, x::xs => if n == x then (delete n xs) else x::(delete n xs)\n", "proof_state": "n : \u2115\nxs : List \u2115\n\u22a2 (delete n xs).length \u2264 xs.length", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:236&&LeanSrc/LeanSrc/Properties.lean:290"}
{"full_name": "prop_69", "prop_defn": "theorem prop_69 (n: Nat) (m: Nat) :\n  n <= (m + n):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:293", "score": 1, "deps": "import Mathlib", "proof_state": "n m : \u2115\n\u22a2 n \u2264 m + n", "file_locs": "LeanSrc/LeanSrc/Properties.lean:294"}
{"full_name": "prop_70", "prop_defn": "theorem prop_70 m (n: Nat) :\n  m <= n \u2192 m <= n.succ:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:297", "score": 1, "deps": "import Mathlib", "proof_state": "m n : \u2115\n\u22a2 m \u2264 n \u2192 m \u2264 n.succ", "file_locs": "LeanSrc/LeanSrc/Properties.lean:298"}
{"full_name": "prop_71", "prop_defn": "theorem prop_71 (x:Nat) (y :Nat) (xs: List Nat) :\n  (x == y) = False \u2192 ((x \u2208 (ins y xs)) == (x \u2208 xs)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:301", "score": 5, "deps": "import Mathlib\n\ndef ins: Nat \u2192 List Nat \u2192 List Nat\n  | n, []  =>  [n]\n  | n, x::xs => if (n < x) then n :: x :: xs else x :: (ins n xs)\n", "proof_state": "x y : \u2115\nxs : List \u2115\n\u22a2 ((x == y) = true) = False \u2192 (decide (x \u2208 ins y xs) == decide (x \u2208 xs)) = true", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:202&&LeanSrc/LeanSrc/Properties.lean:302"}
{"full_name": "prop_72", "prop_defn": "theorem prop_72 (i: Nat) (xs: List \u03b1) :\n  (List.reverse (List.drop i xs) = List.take (List.length xs - i) (List.reverse xs)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:305", "score": 5, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\ni : \u2115\nxs : List \u03b1\n\u22a2 (List.drop i xs).reverse = List.take (xs.length - i) xs.reverse", "file_locs": "LeanSrc/LeanSrc/Properties.lean:306"}
{"full_name": "prop_73", "prop_defn": "theorem prop_73 (p: \u03b1 \u2192 Bool) (xs: List \u03b1) :\n  (List.reverse (List.filter p xs) = List.filter p (List.reverse xs)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:309", "score": 5, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nxs : List \u03b1\n\u22a2 (List.filter p xs).reverse = List.filter p xs.reverse", "file_locs": "LeanSrc/LeanSrc/Properties.lean:310"}
{"full_name": "prop_74", "prop_defn": "theorem prop_74 (i: Nat) (xs: List \u03b1) :\n  (List.reverse (List.take i xs) = List.drop (List.length xs - i) (List.reverse xs)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:313", "score": 5, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\ni : \u2115\nxs : List \u03b1\n\u22a2 (List.take i xs).reverse = List.drop (xs.length - i) xs.reverse", "file_locs": "LeanSrc/LeanSrc/Properties.lean:314"}
{"full_name": "prop_75", "prop_defn": "theorem prop_75 (n: Nat) (m: Nat ) (xs: List Nat) :\n  (List.count n xs + List.count n [m] = List.count n (m :: xs)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:317", "score": 5, "deps": "import Mathlib", "proof_state": "n m : \u2115\nxs : List \u2115\n\u22a2 List.count n xs + List.count n [m] = List.count n (m :: xs)", "file_locs": "LeanSrc/LeanSrc/Properties.lean:318"}
{"full_name": "prop_76", "prop_defn": "theorem prop_76 (n: Nat) (m: Nat) (xs: List Nat) :\n  (n == m) = False \u2192 List.count n (xs ++ [m]) = List.count n xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:321", "score": 5, "deps": "import Mathlib", "proof_state": "n m : \u2115\nxs : List \u2115\n\u22a2 ((n == m) = true) = False \u2192 List.count n (xs ++ [m]) = List.count n xs", "file_locs": "LeanSrc/LeanSrc/Properties.lean:322"}
{"full_name": "prop_77", "prop_defn": "theorem prop_77 (x: Nat) (xs: List Nat) :\n  sorted xs \u2192 sorted (insort x xs):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:325", "score": 5, "deps": "import Mathlib\n\ndef insort : Nat \u2192 List Nat \u2192 List Nat\n  | n, [] => [n]\n  | n, x::xs => if n <= x then n::x::xs else x::(insort n xs)\n\n\ndef sorted : List Nat \u2192 Bool\n  | [] => True\n  | [_x] => True\n  | x::y::xs => and (x <= y) (sorted (y::xs))\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 sorted xs = true \u2192 sorted (insort x xs) = true", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:220&&LeanSrc/LeanSrc/Properties.lean:326"}
{"full_name": "prop_78", "prop_defn": "theorem prop_78 (xs: List Nat) :\n  sorted (sort xs):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:330", "score": 5, "deps": "import Mathlib\n\ndef insort : Nat \u2192 List Nat \u2192 List Nat\n  | n, [] => [n]\n  | n, x::xs => if n <= x then n::x::xs else x::(insort n xs)\n\n\ndef sort : List Nat \u2192 List Nat\n  | [] => []\n  | x::xs => insort x (sort xs)\n\n\ndef sorted : List Nat \u2192 Bool\n  | [] => True\n  | [_x] => True\n  | x::y::xs => and (x <= y) (sorted (y::xs))\n", "proof_state": "xs : List \u2115\n\u22a2 sorted (sort xs) = true", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:220&&LeanSrc/LeanSrc/Properties.lean:331"}
{"full_name": "prop_79", "prop_defn": "theorem prop_79 (m: Nat) (n: Nat) (k: Nat) :\n  ((m.succ - n) - k.succ = (m - n) - k):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:334", "score": 2, "deps": "import Mathlib", "proof_state": "m n k : \u2115\n\u22a2 m.succ - n - k.succ = m - n - k", "file_locs": "LeanSrc/LeanSrc/Properties.lean:335"}
{"full_name": "prop_80", "prop_defn": "theorem prop_80 (n: Nat) (xs: List \u03b1) (ys: List \u03b1) :\n  (List.take n (xs ++ ys) = List.take n xs ++ List.take (n - List.length xs) ys):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:338", "score": 5, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\nn : \u2115\nxs ys : List \u03b1\n\u22a2 List.take n (xs ++ ys) = List.take n xs ++ List.take (n - xs.length) ys", "file_locs": "LeanSrc/LeanSrc/Properties.lean:339"}
{"full_name": "prop_81", "prop_defn": "theorem prop_81 (n: Nat) (m: Nat) (xs: List \u03b1)  :\n  (List.take n (List.drop m xs) = List.drop m (List.take (n + m) xs)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:343", "score": 5, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\nn m : \u2115\nxs : List \u03b1\n\u22a2 List.take n (List.drop m xs) = List.drop m (List.take (n + m) xs)", "file_locs": "LeanSrc/LeanSrc/Properties.lean:344"}
{"full_name": "prop_82", "prop_defn": "theorem prop_82 (n: Nat) (xs: List \u03b1) (ys: List \u03b2) :\n  (List.take n (zip' xs ys) = zip' (List.take n xs) (List.take n ys)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:347", "score": 5, "deps": "import Mathlib\n\ndef zip' : List \u03b1 \u2192 List \u03b2 \u2192 List (\u03b1 \u00d7 \u03b2)\n  | [], _ => []\n  | _, [] => []\n  | x::xs, y::ys => \u27e8x, y\u27e9 :: zip' xs ys\n", "proof_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\nxs : List \u03b1\nys : List \u03b2\n\u22a2 List.take n (zip' xs ys) = zip' (List.take n xs) (List.take n ys)", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:241&&LeanSrc/LeanSrc/Properties.lean:348"}
{"full_name": "prop_83", "prop_defn": "theorem prop_83 (xs: List \u03b1) (ys: List \u03b1) (zs: List \u03b2) :\n  (zip' (xs ++ ys) zs =\n           zip' xs (List.take (List.length xs) zs) ++ zip' ys (List.drop (List.length xs) zs)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:351", "score": 5, "deps": "import Mathlib\n\ndef zip' : List \u03b1 \u2192 List \u03b2 \u2192 List (\u03b1 \u00d7 \u03b2)\n  | [], _ => []\n  | _, [] => []\n  | x::xs, y::ys => \u27e8x, y\u27e9 :: zip' xs ys\n", "proof_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nxs ys : List \u03b1\nzs : List \u03b2\n\u22a2 zip' (xs ++ ys) zs = zip' xs (List.take xs.length zs) ++ zip' ys (List.drop xs.length zs)", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:241&&LeanSrc/LeanSrc/Properties.lean:353"}
{"full_name": "prop_84", "prop_defn": "theorem prop_84 (xs: List \u03b1) (ys: List \u03b2) (zs: List \u03b2) :\n  (zip' xs (ys ++ zs) =\n           zip' (List.take (List.length ys) xs) ys ++ zip' (List.drop (List.length ys) xs) zs):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:356", "score": 5, "deps": "import Mathlib\n\ndef zip' : List \u03b1 \u2192 List \u03b2 \u2192 List (\u03b1 \u00d7 \u03b2)\n  | [], _ => []\n  | _, [] => []\n  | x::xs, y::ys => \u27e8x, y\u27e9 :: zip' xs ys\n", "proof_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nxs : List \u03b1\nys zs : List \u03b2\n\u22a2 zip' xs (ys ++ zs) = zip' (List.take ys.length xs) ys ++ zip' (List.drop ys.length xs) zs", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:241&&LeanSrc/LeanSrc/Properties.lean:358"}
{"full_name": "prop_85", "prop_defn": "theorem prop_85 (xs: List \u03b1) (ys: List \u03b2) :\n  (List.length xs = List.length ys) \u2192\n    (zip' (List.reverse xs) (List.reverse ys) = List.reverse (zip' xs ys)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:363", "score": 5, "deps": "import Mathlib\n\ndef zip' : List \u03b1 \u2192 List \u03b2 \u2192 List (\u03b1 \u00d7 \u03b2)\n  | [], _ => []\n  | _, [] => []\n  | x::xs, y::ys => \u27e8x, y\u27e9 :: zip' xs ys\n", "proof_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nxs : List \u03b1\nys : List \u03b2\n\u22a2 xs.length = ys.length \u2192 zip' xs.reverse ys.reverse = (zip' xs ys).reverse", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:241&&LeanSrc/LeanSrc/Properties.lean:365"}
{"full_name": "prop_86", "prop_defn": "theorem prop_86 (x: Nat) (y: Nat) (xs: List Nat) :\n  x < y \u2192 ((x \u2208 (ins y xs)) == (x \u2208 xs)):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:368", "score": 5, "deps": "import Mathlib\n\ndef ins: Nat \u2192 List Nat \u2192 List Nat\n  | n, []  =>  [n]\n  | n, x::xs => if (n < x) then n :: x :: xs else x :: (ins n xs)\n", "proof_state": "x y : \u2115\nxs : List \u2115\n\u22a2 x < y \u2192 (decide (x \u2208 ins y xs) == decide (x \u2208 xs)) = true", "file_locs": "LeanSrc/LeanSrc/Definitions.lean:202&&LeanSrc/LeanSrc/Properties.lean:369"}
{"full_name": "prop_ISortSorts", "prop_defn": "theorem prop_ISortSorts (xs: List Nat) : ordered (isort xs) == True:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:54", "score": 5, "deps": "import Mathlib\n\ndef ordered : List Nat -> Bool\n| []       => True\n| [_x]     => True\n| x::y::xs => x <= y && ordered (y::xs)\n\n\ndef insert' : Nat \u2192 List Nat \u2192 List Nat\n| x, [] => [x]\n| x, y::xs => if x <= y then x::y::xs else y::(insert x xs)\n\n\ndef isort: List Nat \u2192 List Nat\n| [] => []\n| x::xs => insert' x (isort xs)\n", "proof_state": "xs : List \u2115\n\u22a2 (ordered (isort xs) == decide True) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:54"}
{"full_name": "prop_ISortCount", "prop_defn": "theorem prop_ISortCount (x: Nat) (xs: List Nat) : count x (isort xs) == count x xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:55", "score": 5, "deps": "import Mathlib\n\ndef count [DecidableEq \u03b1] : \u03b1 \u2192 List \u03b1 \u2192 Nat\n| _x, [] => 0\n| x, y::ys => if x == y then 1 + (count x ys) else count x ys\n\n\ndef insert' : Nat \u2192 List Nat \u2192 List Nat\n| x, [] => [x]\n| x, y::xs => if x <= y then x::y::xs else y::(insert x xs)\n\n\ndef isort: List Nat \u2192 List Nat\n| [] => []\n| x::xs => insert' x (isort xs)\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (count x (isort xs) == count x xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:55"}
{"full_name": "prop_ISortPermutes", "prop_defn": "theorem prop_ISortPermutes (xs: List Nat) : isPermutation (isort xs) xs == True:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:56", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n\n\ndef insert' : Nat \u2192 List Nat \u2192 List Nat\n| x, [] => [x]\n| x, y::xs => if x <= y then x::y::xs else y::(insert x xs)\n\n\ndef isort: List Nat \u2192 List Nat\n| [] => []\n| x::xs => insert' x (isort xs)\n", "proof_state": "xs : List \u2115\n\u22a2 (isPermutation (isort xs) xs == decide True) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:56"}
{"full_name": "prop_BubSortSorts", "prop_defn": "theorem prop_BubSortSorts (xs: List Nat) : ordered (bubsort xs) == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:89", "score": 5, "deps": "import Mathlib\n\ndef ordered : List Nat -> Bool\n| []       => True\n| [_x]     => True\n| x::y::xs => x <= y && ordered (y::xs)\n\n\ndef bubsort (xs : List Nat) : {l' : List Nat // xs.length = l'.length} :=\n  match xs with\n  | [] => \u27e8[], rfl\u27e9\n  | x :: xs =>\n    match bubsort xs with\n    | \u27e8[], h\u27e9 => \u27e8[x], by simp[h]\u27e9\n    | \u27e8y :: ys, h\u27e9 =>\n      if y < x then\n        have : Nat.succ (List.length ys) < Nat.succ (List.length xs) := by rw [h, List.length_cons]; apply Nat.lt_succ_self\n        let \u27e8zs, he\u27e9 := bubsort (x :: ys)\n        \u27e8y :: zs, by simp[h, \u2190 he]\u27e9\n      else\n        \u27e8x :: y :: ys, by simp[h]\u27e9\ntermination_by xs.length\n", "proof_state": "xs : List \u2115\n\u22a2 (ordered \u2191(bubsort xs) == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:89"}
{"full_name": "prop_BubSortCount", "prop_defn": "theorem prop_BubSortCount (x: Nat) (xs: List Nat) : count x (bubsort xs) == count x xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:90", "score": 5, "deps": "import Mathlib\n\ndef count [DecidableEq \u03b1] : \u03b1 \u2192 List \u03b1 \u2192 Nat\n| _x, [] => 0\n| x, y::ys => if x == y then 1 + (count x ys) else count x ys\n\n\ndef bubsort (xs : List Nat) : {l' : List Nat // xs.length = l'.length} :=\n  match xs with\n  | [] => \u27e8[], rfl\u27e9\n  | x :: xs =>\n    match bubsort xs with\n    | \u27e8[], h\u27e9 => \u27e8[x], by simp[h]\u27e9\n    | \u27e8y :: ys, h\u27e9 =>\n      if y < x then\n        have : Nat.succ (List.length ys) < Nat.succ (List.length xs) := by rw [h, List.length_cons]; apply Nat.lt_succ_self\n        let \u27e8zs, he\u27e9 := bubsort (x :: ys)\n        \u27e8y :: zs, by simp[h, \u2190 he]\u27e9\n      else\n        \u27e8x :: y :: ys, by simp[h]\u27e9\ntermination_by xs.length\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (count x \u2191(bubsort xs) == count x xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:90"}
{"full_name": "prop_BubSortPermutes", "prop_defn": "theorem prop_BubSortPermutes (xs: List Nat) : isPermutation (bubsort xs) xs == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:91", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n\n\ndef bubsort (xs : List Nat) : {l' : List Nat // xs.length = l'.length} :=\n  match xs with\n  | [] => \u27e8[], rfl\u27e9\n  | x :: xs =>\n    match bubsort xs with\n    | \u27e8[], h\u27e9 => \u27e8[x], by simp[h]\u27e9\n    | \u27e8y :: ys, h\u27e9 =>\n      if y < x then\n        have : Nat.succ (List.length ys) < Nat.succ (List.length xs) := by rw [h, List.length_cons]; apply Nat.lt_succ_self\n        let \u27e8zs, he\u27e9 := bubsort (x :: ys)\n        \u27e8y :: zs, by simp[h, \u2190 he]\u27e9\n      else\n        \u27e8x :: y :: ys, by simp[h]\u27e9\ntermination_by xs.length\n", "proof_state": "xs : List \u2115\n\u22a2 (isPermutation (\u2191(bubsort xs)) xs == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:91"}
{"full_name": "prop_BubSortIsSort", "prop_defn": "theorem prop_BubSortIsSort (xs: List Nat) : bubblesort xs == isort xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:92", "score": 5, "deps": "import Mathlib\n\ndef insert' : Nat \u2192 List Nat \u2192 List Nat\n| x, [] => [x]\n| x, y::xs => if x <= y then x::y::xs else y::(insert x xs)\n\n\ndef isort: List Nat \u2192 List Nat\n| [] => []\n| x::xs => insert' x (isort xs)\n\n\ndef bubsort (xs : List Nat) : {l' : List Nat // xs.length = l'.length} :=\n  match xs with\n  | [] => \u27e8[], rfl\u27e9\n  | x :: xs =>\n    match bubsort xs with\n    | \u27e8[], h\u27e9 => \u27e8[x], by simp[h]\u27e9\n    | \u27e8y :: ys, h\u27e9 =>\n      if y < x then\n        have : Nat.succ (List.length ys) < Nat.succ (List.length xs) := by rw [h, List.length_cons]; apply Nat.lt_succ_self\n        let \u27e8zs, he\u27e9 := bubsort (x :: ys)\n        \u27e8y :: zs, by simp[h, \u2190 he]\u27e9\n      else\n        \u27e8x :: y :: ys, by simp[h]\u27e9\ntermination_by xs.length\n\n\ndef bubblesort (xs: List Nat) : List Nat :=\n  bubsort xs\n", "proof_state": "xs : List \u2115\n\u22a2 (bubblesort xs == isort xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:92"}
{"full_name": "prop_HSortSorts", "prop_defn": "theorem prop_HSortSorts (xs: List Nat) : ordered (hsort xs) == True:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:195", "score": 5, "deps": "import Mathlib\n\ndef ordered : List Nat -> Bool\n| []       => True\n| [_x]     => True\n| x::y::xs => x <= y && ordered (y::xs)\n\n\ninductive MyHeap where\n| nil : MyHeap\n| node : MyHeap \u2192 Nat \u2192 MyHeap  \u2192  MyHeap\n\n\ndef hmerge : MyHeap  \u2192 MyHeap  \u2192 MyHeap\n| MyHeap.nil, q => q\n| p, MyHeap.nil => p\n| MyHeap.node p x q, MyHeap.node r y s =>\n  if x <= y then MyHeap.node (hmerge q (MyHeap.node r y s)) x p\n            else MyHeap.node (hmerge (MyHeap.node p x q) s) y r\n\n\ndef hpairwise : List MyHeap \u2192 List MyHeap\n| p::q::qs => (hmerge p q)::hpairwise qs\n| ps => ps\n\n\nlemma hpairwise_desc (ps: List MyHeap): List.length (hpairwise ps) \u2264 List.length ps := by\n  generalize hl: ps.length = len\n  induction len using Nat.strong_induction_on generalizing ps with\n  | h len2 ih =>\n    match ps with\n      | [] => unfold hpairwise; simp\n      | q1::qs1 => match qs1 with\n        | [] => unfold hpairwise; rw [\u2190hl]\n        | q2::qs2 => unfold hpairwise; rw [\u2190 hl, List.length_cons, List.length_cons, List.length_cons,Nat.succ_le_succ_iff]\n                     rw [List.length_cons, List.length_cons] at hl\n                     have hl3 := Nat.lt_of_succ_lt (Nat.lt_of_succ_le (Nat.le_of_eq hl))\n                     exact Nat.le.step (ih (qs2.length) hl3 qs2 rfl)\n\n\ndef hmerging : List MyHeap \u2192 MyHeap\n| [] => MyHeap.nil\n| [p] => p\n| p::q::ps =>\n    have : List.length (hpairwise (p :: q :: ps)) < Nat.succ (Nat.succ (List.length ps)) := by\n      unfold hpairwise\n      rw [List.length_cons, Nat.succ_lt_succ_iff, Nat.lt_succ]\n      exact hpairwise_desc _\n    hmerging (hpairwise (p::q::ps))\ntermination_by ps => ps.length\n\n\ndef toHeap : List Nat \u2192 MyHeap\n| xs => hmerging (xs.map (fun x => MyHeap.node MyHeap.nil x MyHeap.nil))\n\n\ndef numElem : MyHeap \u2192 Nat\n| MyHeap.nil => 0\n| MyHeap.node p _x q => 1 + numElem p + numElem q\n\n\nlemma numElem_lt_subHeaps  (q r: MyHeap) {x: Nat}: numElem q < numElem (MyHeap.node q x r) \u2227 numElem r < numElem (MyHeap.node q x r) := by\n  have h': numElem (MyHeap.node q x r) = 1 + numElem q + numElem r; rfl\n  rw [h'];\n  exact \u27e8by linarith, by linarith\u27e9;\n\n\nlemma merge_elems (p q: MyHeap): numElem p + numElem q = numElem (hmerge p q) := by\n  generalize hsp: numElem p = sp\n  generalize hsq: numElem q = sq\n  generalize hspq: numElem (hmerge p q) = spq\n  induction sp using Nat.strong_induction_on generalizing p q sq spq with\n  | h sp2 ih =>   induction sq using Nat.strong_induction_on generalizing p q sp2 spq with\n    | h sq2 ih2 =>\n    rw [\u2190hsp, \u2190 hsq, \u2190 hspq];\n    unfold hmerge;\n    split;\n    case h_1 _ _;\n      unfold numElem; rw [Nat.add_comm, Nat.add_zero];\n    case h_2 _ _;\n      unfold numElem; rw [Nat.add_zero];\n    case h_3 _ _ pl x pr ql y qr;\n      split;\n        unfold numElem;\n        suffices h': numElem (hmerge pr (MyHeap.node ql y qr)) = numElem pr + (1 + numElem ql + numElem qr);\n          rw[h']; linarith;\n        rw [\u2190hsp] at ih;\n        exact Eq.symm (ih (numElem pr) (numElem_lt_subHeaps _ _).2 pr (MyHeap.node ql y qr) rfl\n          (numElem (MyHeap.node ql y qr)) rfl (numElem (hmerge pr (MyHeap.node ql y qr))) rfl);\n        unfold numElem;\n        suffices h': numElem (hmerge (MyHeap.node pl x pr) qr) = numElem qr + (1 + numElem pl + numElem pr);\n          rw[h']; linarith;\n        rw [\u2190hsq] at ih2;\n        have h':= ih2 (numElem qr) (numElem_lt_subHeaps _ _).2 sp2 ih (MyHeap.node pl x pr) qr hsp rfl\n          (numElem (hmerge (MyHeap.node pl x pr) qr)) rfl;\n        rw [\u2190hsp] at h';\n        suffices h'': 1 + numElem pl + numElem pr = numElem (MyHeap.node pl x pr);\n          rw [h'']; linarith;\n        rfl;\n\n\nlemma numElem_merge_branches_lt (p q: MyHeap) (x: Nat): numElem (hmerge p q) < numElem (MyHeap.node p x q) := by\n  rw [\u2190merge_elems _ _];\n  have h': numElem (MyHeap.node p x q) = 1 + numElem p + numElem q; rfl\n  rw [h']\n  linarith;\n\n\ndef toList : MyHeap \u2192 List Nat\n| MyHeap.nil => []\n| MyHeap.node p x q =>\n    have _h := numElem_merge_branches_lt p q x\n    x :: toList (hmerge p q)\ntermination_by hp => numElem hp\n\n\ndef hsort : List Nat \u2192 List Nat\n | xs => toList (toHeap xs)\n", "proof_state": "xs : List \u2115\n\u22a2 (ordered (hsort xs) == decide True) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:195"}
{"full_name": "prop_HSortCount", "prop_defn": "theorem prop_HSortCount (x: Nat) (xs: List Nat) : count x (hsort xs) == count x xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:196", "score": 5, "deps": "import Mathlib\n\ndef count [DecidableEq \u03b1] : \u03b1 \u2192 List \u03b1 \u2192 Nat\n| _x, [] => 0\n| x, y::ys => if x == y then 1 + (count x ys) else count x ys\n\n\ninductive MyHeap where\n| nil : MyHeap\n| node : MyHeap \u2192 Nat \u2192 MyHeap  \u2192  MyHeap\n\n\ndef hmerge : MyHeap  \u2192 MyHeap  \u2192 MyHeap\n| MyHeap.nil, q => q\n| p, MyHeap.nil => p\n| MyHeap.node p x q, MyHeap.node r y s =>\n  if x <= y then MyHeap.node (hmerge q (MyHeap.node r y s)) x p\n            else MyHeap.node (hmerge (MyHeap.node p x q) s) y r\n\n\ndef hpairwise : List MyHeap \u2192 List MyHeap\n| p::q::qs => (hmerge p q)::hpairwise qs\n| ps => ps\n\n\nlemma hpairwise_desc (ps: List MyHeap): List.length (hpairwise ps) \u2264 List.length ps := by\n  generalize hl: ps.length = len\n  induction len using Nat.strong_induction_on generalizing ps with\n  | h len2 ih =>\n    match ps with\n      | [] => unfold hpairwise; simp\n      | q1::qs1 => match qs1 with\n        | [] => unfold hpairwise; rw [\u2190hl]\n        | q2::qs2 => unfold hpairwise; rw [\u2190 hl, List.length_cons, List.length_cons, List.length_cons,Nat.succ_le_succ_iff]\n                     rw [List.length_cons, List.length_cons] at hl\n                     have hl3 := Nat.lt_of_succ_lt (Nat.lt_of_succ_le (Nat.le_of_eq hl))\n                     exact Nat.le.step (ih (qs2.length) hl3 qs2 rfl)\n\n\ndef hmerging : List MyHeap \u2192 MyHeap\n| [] => MyHeap.nil\n| [p] => p\n| p::q::ps =>\n    have : List.length (hpairwise (p :: q :: ps)) < Nat.succ (Nat.succ (List.length ps)) := by\n      unfold hpairwise\n      rw [List.length_cons, Nat.succ_lt_succ_iff, Nat.lt_succ]\n      exact hpairwise_desc _\n    hmerging (hpairwise (p::q::ps))\ntermination_by ps => ps.length\n\n\ndef toHeap : List Nat \u2192 MyHeap\n| xs => hmerging (xs.map (fun x => MyHeap.node MyHeap.nil x MyHeap.nil))\n\n\ndef numElem : MyHeap \u2192 Nat\n| MyHeap.nil => 0\n| MyHeap.node p _x q => 1 + numElem p + numElem q\n\n\nlemma numElem_lt_subHeaps  (q r: MyHeap) {x: Nat}: numElem q < numElem (MyHeap.node q x r) \u2227 numElem r < numElem (MyHeap.node q x r) := by\n  have h': numElem (MyHeap.node q x r) = 1 + numElem q + numElem r; rfl\n  rw [h'];\n  exact \u27e8by linarith, by linarith\u27e9;\n\n\nlemma merge_elems (p q: MyHeap): numElem p + numElem q = numElem (hmerge p q) := by\n  generalize hsp: numElem p = sp\n  generalize hsq: numElem q = sq\n  generalize hspq: numElem (hmerge p q) = spq\n  induction sp using Nat.strong_induction_on generalizing p q sq spq with\n  | h sp2 ih =>   induction sq using Nat.strong_induction_on generalizing p q sp2 spq with\n    | h sq2 ih2 =>\n    rw [\u2190hsp, \u2190 hsq, \u2190 hspq];\n    unfold hmerge;\n    split;\n    case h_1 _ _;\n      unfold numElem; rw [Nat.add_comm, Nat.add_zero];\n    case h_2 _ _;\n      unfold numElem; rw [Nat.add_zero];\n    case h_3 _ _ pl x pr ql y qr;\n      split;\n        unfold numElem;\n        suffices h': numElem (hmerge pr (MyHeap.node ql y qr)) = numElem pr + (1 + numElem ql + numElem qr);\n          rw[h']; linarith;\n        rw [\u2190hsp] at ih;\n        exact Eq.symm (ih (numElem pr) (numElem_lt_subHeaps _ _).2 pr (MyHeap.node ql y qr) rfl\n          (numElem (MyHeap.node ql y qr)) rfl (numElem (hmerge pr (MyHeap.node ql y qr))) rfl);\n        unfold numElem;\n        suffices h': numElem (hmerge (MyHeap.node pl x pr) qr) = numElem qr + (1 + numElem pl + numElem pr);\n          rw[h']; linarith;\n        rw [\u2190hsq] at ih2;\n        have h':= ih2 (numElem qr) (numElem_lt_subHeaps _ _).2 sp2 ih (MyHeap.node pl x pr) qr hsp rfl\n          (numElem (hmerge (MyHeap.node pl x pr) qr)) rfl;\n        rw [\u2190hsp] at h';\n        suffices h'': 1 + numElem pl + numElem pr = numElem (MyHeap.node pl x pr);\n          rw [h'']; linarith;\n        rfl;\n\n\nlemma numElem_merge_branches_lt (p q: MyHeap) (x: Nat): numElem (hmerge p q) < numElem (MyHeap.node p x q) := by\n  rw [\u2190merge_elems _ _];\n  have h': numElem (MyHeap.node p x q) = 1 + numElem p + numElem q; rfl\n  rw [h']\n  linarith;\n\n\ndef toList : MyHeap \u2192 List Nat\n| MyHeap.nil => []\n| MyHeap.node p x q =>\n    have _h := numElem_merge_branches_lt p q x\n    x :: toList (hmerge p q)\ntermination_by hp => numElem hp\n\n\ndef hsort : List Nat \u2192 List Nat\n | xs => toList (toHeap xs)\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (count x (hsort xs) == count x xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:196"}
{"full_name": "prop_HSortPermutes", "prop_defn": "theorem prop_HSortPermutes (xs: List Nat) : isPermutation (hsort xs) xs == True:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:197", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n\n\ninductive MyHeap where\n| nil : MyHeap\n| node : MyHeap \u2192 Nat \u2192 MyHeap  \u2192  MyHeap\n\n\ndef hmerge : MyHeap  \u2192 MyHeap  \u2192 MyHeap\n| MyHeap.nil, q => q\n| p, MyHeap.nil => p\n| MyHeap.node p x q, MyHeap.node r y s =>\n  if x <= y then MyHeap.node (hmerge q (MyHeap.node r y s)) x p\n            else MyHeap.node (hmerge (MyHeap.node p x q) s) y r\n\n\ndef hpairwise : List MyHeap \u2192 List MyHeap\n| p::q::qs => (hmerge p q)::hpairwise qs\n| ps => ps\n\n\nlemma hpairwise_desc (ps: List MyHeap): List.length (hpairwise ps) \u2264 List.length ps := by\n  generalize hl: ps.length = len\n  induction len using Nat.strong_induction_on generalizing ps with\n  | h len2 ih =>\n    match ps with\n      | [] => unfold hpairwise; simp\n      | q1::qs1 => match qs1 with\n        | [] => unfold hpairwise; rw [\u2190hl]\n        | q2::qs2 => unfold hpairwise; rw [\u2190 hl, List.length_cons, List.length_cons, List.length_cons,Nat.succ_le_succ_iff]\n                     rw [List.length_cons, List.length_cons] at hl\n                     have hl3 := Nat.lt_of_succ_lt (Nat.lt_of_succ_le (Nat.le_of_eq hl))\n                     exact Nat.le.step (ih (qs2.length) hl3 qs2 rfl)\n\n\ndef hmerging : List MyHeap \u2192 MyHeap\n| [] => MyHeap.nil\n| [p] => p\n| p::q::ps =>\n    have : List.length (hpairwise (p :: q :: ps)) < Nat.succ (Nat.succ (List.length ps)) := by\n      unfold hpairwise\n      rw [List.length_cons, Nat.succ_lt_succ_iff, Nat.lt_succ]\n      exact hpairwise_desc _\n    hmerging (hpairwise (p::q::ps))\ntermination_by ps => ps.length\n\n\ndef toHeap : List Nat \u2192 MyHeap\n| xs => hmerging (xs.map (fun x => MyHeap.node MyHeap.nil x MyHeap.nil))\n\n\ndef numElem : MyHeap \u2192 Nat\n| MyHeap.nil => 0\n| MyHeap.node p _x q => 1 + numElem p + numElem q\n\n\nlemma numElem_lt_subHeaps  (q r: MyHeap) {x: Nat}: numElem q < numElem (MyHeap.node q x r) \u2227 numElem r < numElem (MyHeap.node q x r) := by\n  have h': numElem (MyHeap.node q x r) = 1 + numElem q + numElem r; rfl\n  rw [h'];\n  exact \u27e8by linarith, by linarith\u27e9;\n\n\nlemma merge_elems (p q: MyHeap): numElem p + numElem q = numElem (hmerge p q) := by\n  generalize hsp: numElem p = sp\n  generalize hsq: numElem q = sq\n  generalize hspq: numElem (hmerge p q) = spq\n  induction sp using Nat.strong_induction_on generalizing p q sq spq with\n  | h sp2 ih =>   induction sq using Nat.strong_induction_on generalizing p q sp2 spq with\n    | h sq2 ih2 =>\n    rw [\u2190hsp, \u2190 hsq, \u2190 hspq];\n    unfold hmerge;\n    split;\n    case h_1 _ _;\n      unfold numElem; rw [Nat.add_comm, Nat.add_zero];\n    case h_2 _ _;\n      unfold numElem; rw [Nat.add_zero];\n    case h_3 _ _ pl x pr ql y qr;\n      split;\n        unfold numElem;\n        suffices h': numElem (hmerge pr (MyHeap.node ql y qr)) = numElem pr + (1 + numElem ql + numElem qr);\n          rw[h']; linarith;\n        rw [\u2190hsp] at ih;\n        exact Eq.symm (ih (numElem pr) (numElem_lt_subHeaps _ _).2 pr (MyHeap.node ql y qr) rfl\n          (numElem (MyHeap.node ql y qr)) rfl (numElem (hmerge pr (MyHeap.node ql y qr))) rfl);\n        unfold numElem;\n        suffices h': numElem (hmerge (MyHeap.node pl x pr) qr) = numElem qr + (1 + numElem pl + numElem pr);\n          rw[h']; linarith;\n        rw [\u2190hsq] at ih2;\n        have h':= ih2 (numElem qr) (numElem_lt_subHeaps _ _).2 sp2 ih (MyHeap.node pl x pr) qr hsp rfl\n          (numElem (hmerge (MyHeap.node pl x pr) qr)) rfl;\n        rw [\u2190hsp] at h';\n        suffices h'': 1 + numElem pl + numElem pr = numElem (MyHeap.node pl x pr);\n          rw [h'']; linarith;\n        rfl;\n\n\nlemma numElem_merge_branches_lt (p q: MyHeap) (x: Nat): numElem (hmerge p q) < numElem (MyHeap.node p x q) := by\n  rw [\u2190merge_elems _ _];\n  have h': numElem (MyHeap.node p x q) = 1 + numElem p + numElem q; rfl\n  rw [h']\n  linarith;\n\n\ndef toList : MyHeap \u2192 List Nat\n| MyHeap.nil => []\n| MyHeap.node p x q =>\n    have _h := numElem_merge_branches_lt p q x\n    x :: toList (hmerge p q)\ntermination_by hp => numElem hp\n\n\ndef hsort : List Nat \u2192 List Nat\n | xs => toList (toHeap xs)\n", "proof_state": "xs : List \u2115\n\u22a2 (isPermutation (hsort xs) xs == decide True) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:197"}
{"full_name": "prop_HSortIsSort", "prop_defn": "theorem prop_HSortIsSort (xs: List Nat) : hsort xs == isort xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:198", "score": 5, "deps": "import Mathlib\n\ndef insert' : Nat \u2192 List Nat \u2192 List Nat\n| x, [] => [x]\n| x, y::xs => if x <= y then x::y::xs else y::(insert x xs)\n\n\ndef isort: List Nat \u2192 List Nat\n| [] => []\n| x::xs => insert' x (isort xs)\n\n\ninductive MyHeap where\n| nil : MyHeap\n| node : MyHeap \u2192 Nat \u2192 MyHeap  \u2192  MyHeap\n\n\ndef hmerge : MyHeap  \u2192 MyHeap  \u2192 MyHeap\n| MyHeap.nil, q => q\n| p, MyHeap.nil => p\n| MyHeap.node p x q, MyHeap.node r y s =>\n  if x <= y then MyHeap.node (hmerge q (MyHeap.node r y s)) x p\n            else MyHeap.node (hmerge (MyHeap.node p x q) s) y r\n\n\ndef hpairwise : List MyHeap \u2192 List MyHeap\n| p::q::qs => (hmerge p q)::hpairwise qs\n| ps => ps\n\n\nlemma hpairwise_desc (ps: List MyHeap): List.length (hpairwise ps) \u2264 List.length ps := by\n  generalize hl: ps.length = len\n  induction len using Nat.strong_induction_on generalizing ps with\n  | h len2 ih =>\n    match ps with\n      | [] => unfold hpairwise; simp\n      | q1::qs1 => match qs1 with\n        | [] => unfold hpairwise; rw [\u2190hl]\n        | q2::qs2 => unfold hpairwise; rw [\u2190 hl, List.length_cons, List.length_cons, List.length_cons,Nat.succ_le_succ_iff]\n                     rw [List.length_cons, List.length_cons] at hl\n                     have hl3 := Nat.lt_of_succ_lt (Nat.lt_of_succ_le (Nat.le_of_eq hl))\n                     exact Nat.le.step (ih (qs2.length) hl3 qs2 rfl)\n\n\ndef hmerging : List MyHeap \u2192 MyHeap\n| [] => MyHeap.nil\n| [p] => p\n| p::q::ps =>\n    have : List.length (hpairwise (p :: q :: ps)) < Nat.succ (Nat.succ (List.length ps)) := by\n      unfold hpairwise\n      rw [List.length_cons, Nat.succ_lt_succ_iff, Nat.lt_succ]\n      exact hpairwise_desc _\n    hmerging (hpairwise (p::q::ps))\ntermination_by ps => ps.length\n\n\ndef toHeap : List Nat \u2192 MyHeap\n| xs => hmerging (xs.map (fun x => MyHeap.node MyHeap.nil x MyHeap.nil))\n\n\ndef numElem : MyHeap \u2192 Nat\n| MyHeap.nil => 0\n| MyHeap.node p _x q => 1 + numElem p + numElem q\n\n\nlemma numElem_lt_subHeaps  (q r: MyHeap) {x: Nat}: numElem q < numElem (MyHeap.node q x r) \u2227 numElem r < numElem (MyHeap.node q x r) := by\n  have h': numElem (MyHeap.node q x r) = 1 + numElem q + numElem r; rfl\n  rw [h'];\n  exact \u27e8by linarith, by linarith\u27e9;\n\n\nlemma merge_elems (p q: MyHeap): numElem p + numElem q = numElem (hmerge p q) := by\n  generalize hsp: numElem p = sp\n  generalize hsq: numElem q = sq\n  generalize hspq: numElem (hmerge p q) = spq\n  induction sp using Nat.strong_induction_on generalizing p q sq spq with\n  | h sp2 ih =>   induction sq using Nat.strong_induction_on generalizing p q sp2 spq with\n    | h sq2 ih2 =>\n    rw [\u2190hsp, \u2190 hsq, \u2190 hspq];\n    unfold hmerge;\n    split;\n    case h_1 _ _;\n      unfold numElem; rw [Nat.add_comm, Nat.add_zero];\n    case h_2 _ _;\n      unfold numElem; rw [Nat.add_zero];\n    case h_3 _ _ pl x pr ql y qr;\n      split;\n        unfold numElem;\n        suffices h': numElem (hmerge pr (MyHeap.node ql y qr)) = numElem pr + (1 + numElem ql + numElem qr);\n          rw[h']; linarith;\n        rw [\u2190hsp] at ih;\n        exact Eq.symm (ih (numElem pr) (numElem_lt_subHeaps _ _).2 pr (MyHeap.node ql y qr) rfl\n          (numElem (MyHeap.node ql y qr)) rfl (numElem (hmerge pr (MyHeap.node ql y qr))) rfl);\n        unfold numElem;\n        suffices h': numElem (hmerge (MyHeap.node pl x pr) qr) = numElem qr + (1 + numElem pl + numElem pr);\n          rw[h']; linarith;\n        rw [\u2190hsq] at ih2;\n        have h':= ih2 (numElem qr) (numElem_lt_subHeaps _ _).2 sp2 ih (MyHeap.node pl x pr) qr hsp rfl\n          (numElem (hmerge (MyHeap.node pl x pr) qr)) rfl;\n        rw [\u2190hsp] at h';\n        suffices h'': 1 + numElem pl + numElem pr = numElem (MyHeap.node pl x pr);\n          rw [h'']; linarith;\n        rfl;\n\n\nlemma numElem_merge_branches_lt (p q: MyHeap) (x: Nat): numElem (hmerge p q) < numElem (MyHeap.node p x q) := by\n  rw [\u2190merge_elems _ _];\n  have h': numElem (MyHeap.node p x q) = 1 + numElem p + numElem q; rfl\n  rw [h']\n  linarith;\n\n\ndef toList : MyHeap \u2192 List Nat\n| MyHeap.nil => []\n| MyHeap.node p x q =>\n    have _h := numElem_merge_branches_lt p q x\n    x :: toList (hmerge p q)\ntermination_by hp => numElem hp\n\n\ndef hsort : List Nat \u2192 List Nat\n | xs => toList (toHeap xs)\n", "proof_state": "xs : List \u2115\n\u22a2 (hsort xs == isort xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:198"}
{"full_name": "prop_HSort2Sorts", "prop_defn": "theorem prop_HSort2Sorts (xs: List Nat) : ordered (hsort2 xs) == True:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:211", "score": 5, "deps": "import Mathlib\n\ndef ordered : List Nat -> Bool\n| []       => True\n| [_x]     => True\n| x::y::xs => x <= y && ordered (y::xs)\n\n\ninductive MyHeap where\n| nil : MyHeap\n| node : MyHeap \u2192 Nat \u2192 MyHeap  \u2192  MyHeap\n\n\ndef hmerge : MyHeap  \u2192 MyHeap  \u2192 MyHeap\n| MyHeap.nil, q => q\n| p, MyHeap.nil => p\n| MyHeap.node p x q, MyHeap.node r y s =>\n  if x <= y then MyHeap.node (hmerge q (MyHeap.node r y s)) x p\n            else MyHeap.node (hmerge (MyHeap.node p x q) s) y r\n\n\ndef numElem : MyHeap \u2192 Nat\n| MyHeap.nil => 0\n| MyHeap.node p _x q => 1 + numElem p + numElem q\n\n\nlemma numElem_lt_subHeaps  (q r: MyHeap) {x: Nat}: numElem q < numElem (MyHeap.node q x r) \u2227 numElem r < numElem (MyHeap.node q x r) := by\n  have h': numElem (MyHeap.node q x r) = 1 + numElem q + numElem r; rfl\n  rw [h'];\n  exact \u27e8by linarith, by linarith\u27e9;\n\n\nlemma merge_elems (p q: MyHeap): numElem p + numElem q = numElem (hmerge p q) := by\n  generalize hsp: numElem p = sp\n  generalize hsq: numElem q = sq\n  generalize hspq: numElem (hmerge p q) = spq\n  induction sp using Nat.strong_induction_on generalizing p q sq spq with\n  | h sp2 ih =>   induction sq using Nat.strong_induction_on generalizing p q sp2 spq with\n    | h sq2 ih2 =>\n    rw [\u2190hsp, \u2190 hsq, \u2190 hspq];\n    unfold hmerge;\n    split;\n    case h_1 _ _;\n      unfold numElem; rw [Nat.add_comm, Nat.add_zero];\n    case h_2 _ _;\n      unfold numElem; rw [Nat.add_zero];\n    case h_3 _ _ pl x pr ql y qr;\n      split;\n        unfold numElem;\n        suffices h': numElem (hmerge pr (MyHeap.node ql y qr)) = numElem pr + (1 + numElem ql + numElem qr);\n          rw[h']; linarith;\n        rw [\u2190hsp] at ih;\n        exact Eq.symm (ih (numElem pr) (numElem_lt_subHeaps _ _).2 pr (MyHeap.node ql y qr) rfl\n          (numElem (MyHeap.node ql y qr)) rfl (numElem (hmerge pr (MyHeap.node ql y qr))) rfl);\n        unfold numElem;\n        suffices h': numElem (hmerge (MyHeap.node pl x pr) qr) = numElem qr + (1 + numElem pl + numElem pr);\n          rw[h']; linarith;\n        rw [\u2190hsq] at ih2;\n        have h':= ih2 (numElem qr) (numElem_lt_subHeaps _ _).2 sp2 ih (MyHeap.node pl x pr) qr hsp rfl\n          (numElem (hmerge (MyHeap.node pl x pr) qr)) rfl;\n        rw [\u2190hsp] at h';\n        suffices h'': 1 + numElem pl + numElem pr = numElem (MyHeap.node pl x pr);\n          rw [h'']; linarith;\n        rfl;\n\n\nlemma numElem_merge_branches_lt (p q: MyHeap) (x: Nat): numElem (hmerge p q) < numElem (MyHeap.node p x q) := by\n  rw [\u2190merge_elems _ _];\n  have h': numElem (MyHeap.node p x q) = 1 + numElem p + numElem q; rfl\n  rw [h']\n  linarith;\n\n\ndef toList : MyHeap \u2192 List Nat\n| MyHeap.nil => []\n| MyHeap.node p x q =>\n    have _h := numElem_merge_branches_lt p q x\n    x :: toList (hmerge p q)\ntermination_by hp => numElem hp\n\n\ndef hinsert : Nat \u2192 MyHeap \u2192 MyHeap\n| x, h => hmerge (MyHeap.node MyHeap.nil x MyHeap.nil) h\n\n\ndef toHeap2 : List Nat \u2192 MyHeap\n| [] => MyHeap.nil\n| x::xs => hinsert x (toHeap2 xs)\n\n\ndef hsort2 : List Nat \u2192 List Nat\n| xs => toList (toHeap2 xs)\n", "proof_state": "xs : List \u2115\n\u22a2 (ordered (hsort2 xs) == decide True) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:211"}
{"full_name": "prop_HSort2Count", "prop_defn": "theorem prop_HSort2Count (x: Nat) (xs: List Nat) : count x (hsort2 xs) == count x xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:212", "score": 5, "deps": "import Mathlib\n\ndef count [DecidableEq \u03b1] : \u03b1 \u2192 List \u03b1 \u2192 Nat\n| _x, [] => 0\n| x, y::ys => if x == y then 1 + (count x ys) else count x ys\n\n\ninductive MyHeap where\n| nil : MyHeap\n| node : MyHeap \u2192 Nat \u2192 MyHeap  \u2192  MyHeap\n\n\ndef hmerge : MyHeap  \u2192 MyHeap  \u2192 MyHeap\n| MyHeap.nil, q => q\n| p, MyHeap.nil => p\n| MyHeap.node p x q, MyHeap.node r y s =>\n  if x <= y then MyHeap.node (hmerge q (MyHeap.node r y s)) x p\n            else MyHeap.node (hmerge (MyHeap.node p x q) s) y r\n\n\ndef numElem : MyHeap \u2192 Nat\n| MyHeap.nil => 0\n| MyHeap.node p _x q => 1 + numElem p + numElem q\n\n\nlemma numElem_lt_subHeaps  (q r: MyHeap) {x: Nat}: numElem q < numElem (MyHeap.node q x r) \u2227 numElem r < numElem (MyHeap.node q x r) := by\n  have h': numElem (MyHeap.node q x r) = 1 + numElem q + numElem r; rfl\n  rw [h'];\n  exact \u27e8by linarith, by linarith\u27e9;\n\n\nlemma merge_elems (p q: MyHeap): numElem p + numElem q = numElem (hmerge p q) := by\n  generalize hsp: numElem p = sp\n  generalize hsq: numElem q = sq\n  generalize hspq: numElem (hmerge p q) = spq\n  induction sp using Nat.strong_induction_on generalizing p q sq spq with\n  | h sp2 ih =>   induction sq using Nat.strong_induction_on generalizing p q sp2 spq with\n    | h sq2 ih2 =>\n    rw [\u2190hsp, \u2190 hsq, \u2190 hspq];\n    unfold hmerge;\n    split;\n    case h_1 _ _;\n      unfold numElem; rw [Nat.add_comm, Nat.add_zero];\n    case h_2 _ _;\n      unfold numElem; rw [Nat.add_zero];\n    case h_3 _ _ pl x pr ql y qr;\n      split;\n        unfold numElem;\n        suffices h': numElem (hmerge pr (MyHeap.node ql y qr)) = numElem pr + (1 + numElem ql + numElem qr);\n          rw[h']; linarith;\n        rw [\u2190hsp] at ih;\n        exact Eq.symm (ih (numElem pr) (numElem_lt_subHeaps _ _).2 pr (MyHeap.node ql y qr) rfl\n          (numElem (MyHeap.node ql y qr)) rfl (numElem (hmerge pr (MyHeap.node ql y qr))) rfl);\n        unfold numElem;\n        suffices h': numElem (hmerge (MyHeap.node pl x pr) qr) = numElem qr + (1 + numElem pl + numElem pr);\n          rw[h']; linarith;\n        rw [\u2190hsq] at ih2;\n        have h':= ih2 (numElem qr) (numElem_lt_subHeaps _ _).2 sp2 ih (MyHeap.node pl x pr) qr hsp rfl\n          (numElem (hmerge (MyHeap.node pl x pr) qr)) rfl;\n        rw [\u2190hsp] at h';\n        suffices h'': 1 + numElem pl + numElem pr = numElem (MyHeap.node pl x pr);\n          rw [h'']; linarith;\n        rfl;\n\n\nlemma numElem_merge_branches_lt (p q: MyHeap) (x: Nat): numElem (hmerge p q) < numElem (MyHeap.node p x q) := by\n  rw [\u2190merge_elems _ _];\n  have h': numElem (MyHeap.node p x q) = 1 + numElem p + numElem q; rfl\n  rw [h']\n  linarith;\n\n\ndef toList : MyHeap \u2192 List Nat\n| MyHeap.nil => []\n| MyHeap.node p x q =>\n    have _h := numElem_merge_branches_lt p q x\n    x :: toList (hmerge p q)\ntermination_by hp => numElem hp\n\n\ndef hinsert : Nat \u2192 MyHeap \u2192 MyHeap\n| x, h => hmerge (MyHeap.node MyHeap.nil x MyHeap.nil) h\n\n\ndef toHeap2 : List Nat \u2192 MyHeap\n| [] => MyHeap.nil\n| x::xs => hinsert x (toHeap2 xs)\n\n\ndef hsort2 : List Nat \u2192 List Nat\n| xs => toList (toHeap2 xs)\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (count x (hsort2 xs) == count x xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:212"}
{"full_name": "prop_HSort2Permutes", "prop_defn": "theorem prop_HSort2Permutes (xs: List Nat) : isPermutation (hsort2 xs) xs == True:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:213", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n\n\ninductive MyHeap where\n| nil : MyHeap\n| node : MyHeap \u2192 Nat \u2192 MyHeap  \u2192  MyHeap\n\n\ndef hmerge : MyHeap  \u2192 MyHeap  \u2192 MyHeap\n| MyHeap.nil, q => q\n| p, MyHeap.nil => p\n| MyHeap.node p x q, MyHeap.node r y s =>\n  if x <= y then MyHeap.node (hmerge q (MyHeap.node r y s)) x p\n            else MyHeap.node (hmerge (MyHeap.node p x q) s) y r\n\n\ndef numElem : MyHeap \u2192 Nat\n| MyHeap.nil => 0\n| MyHeap.node p _x q => 1 + numElem p + numElem q\n\n\nlemma numElem_lt_subHeaps  (q r: MyHeap) {x: Nat}: numElem q < numElem (MyHeap.node q x r) \u2227 numElem r < numElem (MyHeap.node q x r) := by\n  have h': numElem (MyHeap.node q x r) = 1 + numElem q + numElem r; rfl\n  rw [h'];\n  exact \u27e8by linarith, by linarith\u27e9;\n\n\nlemma merge_elems (p q: MyHeap): numElem p + numElem q = numElem (hmerge p q) := by\n  generalize hsp: numElem p = sp\n  generalize hsq: numElem q = sq\n  generalize hspq: numElem (hmerge p q) = spq\n  induction sp using Nat.strong_induction_on generalizing p q sq spq with\n  | h sp2 ih =>   induction sq using Nat.strong_induction_on generalizing p q sp2 spq with\n    | h sq2 ih2 =>\n    rw [\u2190hsp, \u2190 hsq, \u2190 hspq];\n    unfold hmerge;\n    split;\n    case h_1 _ _;\n      unfold numElem; rw [Nat.add_comm, Nat.add_zero];\n    case h_2 _ _;\n      unfold numElem; rw [Nat.add_zero];\n    case h_3 _ _ pl x pr ql y qr;\n      split;\n        unfold numElem;\n        suffices h': numElem (hmerge pr (MyHeap.node ql y qr)) = numElem pr + (1 + numElem ql + numElem qr);\n          rw[h']; linarith;\n        rw [\u2190hsp] at ih;\n        exact Eq.symm (ih (numElem pr) (numElem_lt_subHeaps _ _).2 pr (MyHeap.node ql y qr) rfl\n          (numElem (MyHeap.node ql y qr)) rfl (numElem (hmerge pr (MyHeap.node ql y qr))) rfl);\n        unfold numElem;\n        suffices h': numElem (hmerge (MyHeap.node pl x pr) qr) = numElem qr + (1 + numElem pl + numElem pr);\n          rw[h']; linarith;\n        rw [\u2190hsq] at ih2;\n        have h':= ih2 (numElem qr) (numElem_lt_subHeaps _ _).2 sp2 ih (MyHeap.node pl x pr) qr hsp rfl\n          (numElem (hmerge (MyHeap.node pl x pr) qr)) rfl;\n        rw [\u2190hsp] at h';\n        suffices h'': 1 + numElem pl + numElem pr = numElem (MyHeap.node pl x pr);\n          rw [h'']; linarith;\n        rfl;\n\n\nlemma numElem_merge_branches_lt (p q: MyHeap) (x: Nat): numElem (hmerge p q) < numElem (MyHeap.node p x q) := by\n  rw [\u2190merge_elems _ _];\n  have h': numElem (MyHeap.node p x q) = 1 + numElem p + numElem q; rfl\n  rw [h']\n  linarith;\n\n\ndef toList : MyHeap \u2192 List Nat\n| MyHeap.nil => []\n| MyHeap.node p x q =>\n    have _h := numElem_merge_branches_lt p q x\n    x :: toList (hmerge p q)\ntermination_by hp => numElem hp\n\n\ndef hinsert : Nat \u2192 MyHeap \u2192 MyHeap\n| x, h => hmerge (MyHeap.node MyHeap.nil x MyHeap.nil) h\n\n\ndef toHeap2 : List Nat \u2192 MyHeap\n| [] => MyHeap.nil\n| x::xs => hinsert x (toHeap2 xs)\n\n\ndef hsort2 : List Nat \u2192 List Nat\n| xs => toList (toHeap2 xs)\n", "proof_state": "xs : List \u2115\n\u22a2 (isPermutation (hsort2 xs) xs == decide True) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:213"}
{"full_name": "prop_HSort2IsSort", "prop_defn": "theorem prop_HSort2IsSort (xs: List Nat) : hsort2 xs == isort xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:214", "score": 5, "deps": "import Mathlib\n\ndef insert' : Nat \u2192 List Nat \u2192 List Nat\n| x, [] => [x]\n| x, y::xs => if x <= y then x::y::xs else y::(insert x xs)\n\n\ndef isort: List Nat \u2192 List Nat\n| [] => []\n| x::xs => insert' x (isort xs)\n\n\ninductive MyHeap where\n| nil : MyHeap\n| node : MyHeap \u2192 Nat \u2192 MyHeap  \u2192  MyHeap\n\n\ndef hmerge : MyHeap  \u2192 MyHeap  \u2192 MyHeap\n| MyHeap.nil, q => q\n| p, MyHeap.nil => p\n| MyHeap.node p x q, MyHeap.node r y s =>\n  if x <= y then MyHeap.node (hmerge q (MyHeap.node r y s)) x p\n            else MyHeap.node (hmerge (MyHeap.node p x q) s) y r\n\n\ndef numElem : MyHeap \u2192 Nat\n| MyHeap.nil => 0\n| MyHeap.node p _x q => 1 + numElem p + numElem q\n\n\nlemma numElem_lt_subHeaps  (q r: MyHeap) {x: Nat}: numElem q < numElem (MyHeap.node q x r) \u2227 numElem r < numElem (MyHeap.node q x r) := by\n  have h': numElem (MyHeap.node q x r) = 1 + numElem q + numElem r; rfl\n  rw [h'];\n  exact \u27e8by linarith, by linarith\u27e9;\n\n\nlemma merge_elems (p q: MyHeap): numElem p + numElem q = numElem (hmerge p q) := by\n  generalize hsp: numElem p = sp\n  generalize hsq: numElem q = sq\n  generalize hspq: numElem (hmerge p q) = spq\n  induction sp using Nat.strong_induction_on generalizing p q sq spq with\n  | h sp2 ih =>   induction sq using Nat.strong_induction_on generalizing p q sp2 spq with\n    | h sq2 ih2 =>\n    rw [\u2190hsp, \u2190 hsq, \u2190 hspq];\n    unfold hmerge;\n    split;\n    case h_1 _ _;\n      unfold numElem; rw [Nat.add_comm, Nat.add_zero];\n    case h_2 _ _;\n      unfold numElem; rw [Nat.add_zero];\n    case h_3 _ _ pl x pr ql y qr;\n      split;\n        unfold numElem;\n        suffices h': numElem (hmerge pr (MyHeap.node ql y qr)) = numElem pr + (1 + numElem ql + numElem qr);\n          rw[h']; linarith;\n        rw [\u2190hsp] at ih;\n        exact Eq.symm (ih (numElem pr) (numElem_lt_subHeaps _ _).2 pr (MyHeap.node ql y qr) rfl\n          (numElem (MyHeap.node ql y qr)) rfl (numElem (hmerge pr (MyHeap.node ql y qr))) rfl);\n        unfold numElem;\n        suffices h': numElem (hmerge (MyHeap.node pl x pr) qr) = numElem qr + (1 + numElem pl + numElem pr);\n          rw[h']; linarith;\n        rw [\u2190hsq] at ih2;\n        have h':= ih2 (numElem qr) (numElem_lt_subHeaps _ _).2 sp2 ih (MyHeap.node pl x pr) qr hsp rfl\n          (numElem (hmerge (MyHeap.node pl x pr) qr)) rfl;\n        rw [\u2190hsp] at h';\n        suffices h'': 1 + numElem pl + numElem pr = numElem (MyHeap.node pl x pr);\n          rw [h'']; linarith;\n        rfl;\n\n\nlemma numElem_merge_branches_lt (p q: MyHeap) (x: Nat): numElem (hmerge p q) < numElem (MyHeap.node p x q) := by\n  rw [\u2190merge_elems _ _];\n  have h': numElem (MyHeap.node p x q) = 1 + numElem p + numElem q; rfl\n  rw [h']\n  linarith;\n\n\ndef toList : MyHeap \u2192 List Nat\n| MyHeap.nil => []\n| MyHeap.node p x q =>\n    have _h := numElem_merge_branches_lt p q x\n    x :: toList (hmerge p q)\ntermination_by hp => numElem hp\n\n\ndef hinsert : Nat \u2192 MyHeap \u2192 MyHeap\n| x, h => hmerge (MyHeap.node MyHeap.nil x MyHeap.nil) h\n\n\ndef toHeap2 : List Nat \u2192 MyHeap\n| [] => MyHeap.nil\n| x::xs => hinsert x (toHeap2 xs)\n\n\ndef hsort2 : List Nat \u2192 List Nat\n| xs => toList (toHeap2 xs)\n", "proof_state": "xs : List \u2115\n\u22a2 (hsort2 xs == isort xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:214"}
{"full_name": "prop_MSortBU2Sorts", "prop_defn": "theorem prop_MSortBU2Sorts (xs: List Nat) : ordered (msortbu2 xs) == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:324", "score": 5, "deps": "import Mathlib\n\ndef ordered : List Nat -> Bool\n| []       => True\n| [_x]     => True\n| x::y::xs => x <= y && ordered (y::xs)\n\n\ndef risers : List Nat \u2192 List (List Nat)\n| [] => []\n| [x] => [[x]]\n| x::y::xs => if x <= y then\n      match (risers (y::xs)) with\n      | ys::yss => (x::ys)::yss\n      | _ => []\n    else\n      [x]::(risers (y::xs))\n\n\ndef lmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => if  x <= y  then\n      x::(lmerge xs (y::ys))\n    else\n      y::(lmerge (x::xs) ys)\n\n\ndef pairwise : List (List Nat) \u2192 List (List Nat)\n| xs::ys::xss => lmerge xs ys :: pairwise xss\n| xss => xss\n\n\nlemma len_pairwise (xs: List (List Nat)): 2 * (pairwise xs).length = (if (Odd xs.length) then xs.length + 1 else xs.length) := by\n  generalize hxl : xs.length = xl;\n  split_ifs with h1;\n  case pos;\n    induction xl using Nat.strong_induction_on generalizing xs with\n    | h xls ih =>\n        rw [\u2190 hxl] at h1;\n        cases xs with\n        | nil => simp at h1;\n        | cons head2 tail2 =>\n          cases tail2 with\n          | nil => unfold pairwise; simp at hxl; rw [\u2190hxl]; simp;\n          | cons head3 tail3 =>\n            unfold pairwise;\n            rw [\u2190hxl, List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _]\n            ring_nf;\n            simp;\n            have hodd: Odd tail3.length := by\n              rw [List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.add_assoc, Nat.odd_add] at h1;\n              apply h1.2; simp;\n            have tmp := ih tail3.length (by rw [\u2190hxl]; simp; linarith;) tail3 rfl hodd\n            ring_nf at tmp;\n            rw [tmp];\n            ring_nf;\n  case neg;\n    induction xl using Nat.strong_induction_on generalizing xs with\n    | h xls ih =>\n        rw [\u2190 hxl] at h1;\n        cases xs with\n        | nil => unfold pairwise; simp [\u2190 hxl]\n        | cons head2 tail2 =>\n          cases tail2 with\n          | nil => simp at h1;\n          | cons head3 tail3 =>\n            unfold pairwise;\n            rw [\u2190hxl, List.length_cons, List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n            ring_nf;\n            simp;\n            simp at h1;\n            have heven: Even tail3.length := by\n              rw [Nat.add_assoc, Nat.even_add] at h1;\n              apply h1.2; simp;\n            simp at ih;\n            have tmp := ih tail3.length (by rw [\u2190hxl]; simp; linarith;) tail3 rfl heven\n            ring_nf at tmp;\n            exact tmp;\n\n\ndef mergingbu2 : List (List Nat) \u2192 List Nat\n| [] => []\n| [xs] => xs\n| xs::ys::xss =>\n  have _h: (pairwise (xs::ys::xss)).length < (xs::ys::xss).length := by\n    suffices h': 2* List.length (pairwise (xs :: ys :: xss)) < 2 * List.length (xs :: ys :: xss)\n    case h';\n      rw [ len_pairwise _];\n      split_ifs with hparity;\n      case pos;\n        simp;\n        ring_nf;\n        linarith;\n      case neg;\n        simp;\n    linarith [h'];\n  mergingbu2 (pairwise (xs::ys::xss))\ntermination_by xss => xss.length\n\n\ndef msortbu2 : List Nat \u2192 List Nat\n| xs => mergingbu2 (risers xs)\n", "proof_state": "xs : List \u2115\n\u22a2 (ordered (msortbu2 xs) == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:324"}
{"full_name": "prop_MSortBU2Count", "prop_defn": "theorem prop_MSortBU2Count (x: Nat) (xs: List Nat) : count x (msortbu2 xs) == count x xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:325", "score": 5, "deps": "import Mathlib\n\ndef count [DecidableEq \u03b1] : \u03b1 \u2192 List \u03b1 \u2192 Nat\n| _x, [] => 0\n| x, y::ys => if x == y then 1 + (count x ys) else count x ys\n\n\ndef risers : List Nat \u2192 List (List Nat)\n| [] => []\n| [x] => [[x]]\n| x::y::xs => if x <= y then\n      match (risers (y::xs)) with\n      | ys::yss => (x::ys)::yss\n      | _ => []\n    else\n      [x]::(risers (y::xs))\n\n\ndef lmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => if  x <= y  then\n      x::(lmerge xs (y::ys))\n    else\n      y::(lmerge (x::xs) ys)\n\n\ndef pairwise : List (List Nat) \u2192 List (List Nat)\n| xs::ys::xss => lmerge xs ys :: pairwise xss\n| xss => xss\n\n\nlemma len_pairwise (xs: List (List Nat)): 2 * (pairwise xs).length = (if (Odd xs.length) then xs.length + 1 else xs.length) := by\n  generalize hxl : xs.length = xl;\n  split_ifs with h1;\n  case pos;\n    induction xl using Nat.strong_induction_on generalizing xs with\n    | h xls ih =>\n        rw [\u2190 hxl] at h1;\n        cases xs with\n        | nil => simp at h1;\n        | cons head2 tail2 =>\n          cases tail2 with\n          | nil => unfold pairwise; simp at hxl; rw [\u2190hxl]; simp;\n          | cons head3 tail3 =>\n            unfold pairwise;\n            rw [\u2190hxl, List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _]\n            ring_nf;\n            simp;\n            have hodd: Odd tail3.length := by\n              rw [List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.add_assoc, Nat.odd_add] at h1;\n              apply h1.2; simp;\n            have tmp := ih tail3.length (by rw [\u2190hxl]; simp; linarith;) tail3 rfl hodd\n            ring_nf at tmp;\n            rw [tmp];\n            ring_nf;\n  case neg;\n    induction xl using Nat.strong_induction_on generalizing xs with\n    | h xls ih =>\n        rw [\u2190 hxl] at h1;\n        cases xs with\n        | nil => unfold pairwise; simp [\u2190 hxl]\n        | cons head2 tail2 =>\n          cases tail2 with\n          | nil => simp at h1;\n          | cons head3 tail3 =>\n            unfold pairwise;\n            rw [\u2190hxl, List.length_cons, List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n            ring_nf;\n            simp;\n            simp at h1;\n            have heven: Even tail3.length := by\n              rw [Nat.add_assoc, Nat.even_add] at h1;\n              apply h1.2; simp;\n            simp at ih;\n            have tmp := ih tail3.length (by rw [\u2190hxl]; simp; linarith;) tail3 rfl heven\n            ring_nf at tmp;\n            exact tmp;\n\n\ndef mergingbu2 : List (List Nat) \u2192 List Nat\n| [] => []\n| [xs] => xs\n| xs::ys::xss =>\n  have _h: (pairwise (xs::ys::xss)).length < (xs::ys::xss).length := by\n    suffices h': 2* List.length (pairwise (xs :: ys :: xss)) < 2 * List.length (xs :: ys :: xss)\n    case h';\n      rw [ len_pairwise _];\n      split_ifs with hparity;\n      case pos;\n        simp;\n        ring_nf;\n        linarith;\n      case neg;\n        simp;\n    linarith [h'];\n  mergingbu2 (pairwise (xs::ys::xss))\ntermination_by xss => xss.length\n\n\ndef msortbu2 : List Nat \u2192 List Nat\n| xs => mergingbu2 (risers xs)\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (count x (msortbu2 xs) == count x xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:325"}
{"full_name": "prop_MSortBU2Permutes", "prop_defn": "theorem prop_MSortBU2Permutes (xs: List Nat) : isPermutation (msortbu2 xs) xs == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:326", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n\n\ndef risers : List Nat \u2192 List (List Nat)\n| [] => []\n| [x] => [[x]]\n| x::y::xs => if x <= y then\n      match (risers (y::xs)) with\n      | ys::yss => (x::ys)::yss\n      | _ => []\n    else\n      [x]::(risers (y::xs))\n\n\ndef lmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => if  x <= y  then\n      x::(lmerge xs (y::ys))\n    else\n      y::(lmerge (x::xs) ys)\n\n\ndef pairwise : List (List Nat) \u2192 List (List Nat)\n| xs::ys::xss => lmerge xs ys :: pairwise xss\n| xss => xss\n\n\nlemma len_pairwise (xs: List (List Nat)): 2 * (pairwise xs).length = (if (Odd xs.length) then xs.length + 1 else xs.length) := by\n  generalize hxl : xs.length = xl;\n  split_ifs with h1;\n  case pos;\n    induction xl using Nat.strong_induction_on generalizing xs with\n    | h xls ih =>\n        rw [\u2190 hxl] at h1;\n        cases xs with\n        | nil => simp at h1;\n        | cons head2 tail2 =>\n          cases tail2 with\n          | nil => unfold pairwise; simp at hxl; rw [\u2190hxl]; simp;\n          | cons head3 tail3 =>\n            unfold pairwise;\n            rw [\u2190hxl, List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _]\n            ring_nf;\n            simp;\n            have hodd: Odd tail3.length := by\n              rw [List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.add_assoc, Nat.odd_add] at h1;\n              apply h1.2; simp;\n            have tmp := ih tail3.length (by rw [\u2190hxl]; simp; linarith;) tail3 rfl hodd\n            ring_nf at tmp;\n            rw [tmp];\n            ring_nf;\n  case neg;\n    induction xl using Nat.strong_induction_on generalizing xs with\n    | h xls ih =>\n        rw [\u2190 hxl] at h1;\n        cases xs with\n        | nil => unfold pairwise; simp [\u2190 hxl]\n        | cons head2 tail2 =>\n          cases tail2 with\n          | nil => simp at h1;\n          | cons head3 tail3 =>\n            unfold pairwise;\n            rw [\u2190hxl, List.length_cons, List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n            ring_nf;\n            simp;\n            simp at h1;\n            have heven: Even tail3.length := by\n              rw [Nat.add_assoc, Nat.even_add] at h1;\n              apply h1.2; simp;\n            simp at ih;\n            have tmp := ih tail3.length (by rw [\u2190hxl]; simp; linarith;) tail3 rfl heven\n            ring_nf at tmp;\n            exact tmp;\n\n\ndef mergingbu2 : List (List Nat) \u2192 List Nat\n| [] => []\n| [xs] => xs\n| xs::ys::xss =>\n  have _h: (pairwise (xs::ys::xss)).length < (xs::ys::xss).length := by\n    suffices h': 2* List.length (pairwise (xs :: ys :: xss)) < 2 * List.length (xs :: ys :: xss)\n    case h';\n      rw [ len_pairwise _];\n      split_ifs with hparity;\n      case pos;\n        simp;\n        ring_nf;\n        linarith;\n      case neg;\n        simp;\n    linarith [h'];\n  mergingbu2 (pairwise (xs::ys::xss))\ntermination_by xss => xss.length\n\n\ndef msortbu2 : List Nat \u2192 List Nat\n| xs => mergingbu2 (risers xs)\n", "proof_state": "xs : List \u2115\n\u22a2 (isPermutation (msortbu2 xs) xs == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:326"}
{"full_name": "prop_MSortBU2IsSort", "prop_defn": "theorem prop_MSortBU2IsSort (xs: List Nat) : msortbu2 xs == isort xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:327", "score": 5, "deps": "import Mathlib\n\ndef insert' : Nat \u2192 List Nat \u2192 List Nat\n| x, [] => [x]\n| x, y::xs => if x <= y then x::y::xs else y::(insert x xs)\n\n\ndef isort: List Nat \u2192 List Nat\n| [] => []\n| x::xs => insert' x (isort xs)\n\n\ndef risers : List Nat \u2192 List (List Nat)\n| [] => []\n| [x] => [[x]]\n| x::y::xs => if x <= y then\n      match (risers (y::xs)) with\n      | ys::yss => (x::ys)::yss\n      | _ => []\n    else\n      [x]::(risers (y::xs))\n\n\ndef lmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => if  x <= y  then\n      x::(lmerge xs (y::ys))\n    else\n      y::(lmerge (x::xs) ys)\n\n\ndef pairwise : List (List Nat) \u2192 List (List Nat)\n| xs::ys::xss => lmerge xs ys :: pairwise xss\n| xss => xss\n\n\nlemma len_pairwise (xs: List (List Nat)): 2 * (pairwise xs).length = (if (Odd xs.length) then xs.length + 1 else xs.length) := by\n  generalize hxl : xs.length = xl;\n  split_ifs with h1;\n  case pos;\n    induction xl using Nat.strong_induction_on generalizing xs with\n    | h xls ih =>\n        rw [\u2190 hxl] at h1;\n        cases xs with\n        | nil => simp at h1;\n        | cons head2 tail2 =>\n          cases tail2 with\n          | nil => unfold pairwise; simp at hxl; rw [\u2190hxl]; simp;\n          | cons head3 tail3 =>\n            unfold pairwise;\n            rw [\u2190hxl, List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _]\n            ring_nf;\n            simp;\n            have hodd: Odd tail3.length := by\n              rw [List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.add_assoc, Nat.odd_add] at h1;\n              apply h1.2; simp;\n            have tmp := ih tail3.length (by rw [\u2190hxl]; simp; linarith;) tail3 rfl hodd\n            ring_nf at tmp;\n            rw [tmp];\n            ring_nf;\n  case neg;\n    induction xl using Nat.strong_induction_on generalizing xs with\n    | h xls ih =>\n        rw [\u2190 hxl] at h1;\n        cases xs with\n        | nil => unfold pairwise; simp [\u2190 hxl]\n        | cons head2 tail2 =>\n          cases tail2 with\n          | nil => simp at h1;\n          | cons head3 tail3 =>\n            unfold pairwise;\n            rw [\u2190hxl, List.length_cons, List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n            ring_nf;\n            simp;\n            simp at h1;\n            have heven: Even tail3.length := by\n              rw [Nat.add_assoc, Nat.even_add] at h1;\n              apply h1.2; simp;\n            simp at ih;\n            have tmp := ih tail3.length (by rw [\u2190hxl]; simp; linarith;) tail3 rfl heven\n            ring_nf at tmp;\n            exact tmp;\n\n\ndef mergingbu2 : List (List Nat) \u2192 List Nat\n| [] => []\n| [xs] => xs\n| xs::ys::xss =>\n  have _h: (pairwise (xs::ys::xss)).length < (xs::ys::xss).length := by\n    suffices h': 2* List.length (pairwise (xs :: ys :: xss)) < 2 * List.length (xs :: ys :: xss)\n    case h';\n      rw [ len_pairwise _];\n      split_ifs with hparity;\n      case pos;\n        simp;\n        ring_nf;\n        linarith;\n      case neg;\n        simp;\n    linarith [h'];\n  mergingbu2 (pairwise (xs::ys::xss))\ntermination_by xss => xss.length\n\n\ndef msortbu2 : List Nat \u2192 List Nat\n| xs => mergingbu2 (risers xs)\n", "proof_state": "xs : List \u2115\n\u22a2 (msortbu2 xs == isort xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:327"}
{"full_name": "prop_MSortBUSorts", "prop_defn": "theorem prop_MSortBUSorts (xs: List Nat) : ordered (msortbu xs) == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:352", "score": 5, "deps": "import Mathlib\n\ndef ordered : List Nat -> Bool\n| []       => True\n| [_x]     => True\n| x::y::xs => x <= y && ordered (y::xs)\n\n\ndef lmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => if  x <= y  then\n      x::(lmerge xs (y::ys))\n    else\n      y::(lmerge (x::xs) ys)\n\n\ndef pairwise : List (List Nat) \u2192 List (List Nat)\n| xs::ys::xss => lmerge xs ys :: pairwise xss\n| xss => xss\n\n\nlemma len_pairwise (xs: List (List Nat)): 2 * (pairwise xs).length = (if (Odd xs.length) then xs.length + 1 else xs.length) := by\n  generalize hxl : xs.length = xl;\n  split_ifs with h1;\n  case pos;\n    induction xl using Nat.strong_induction_on generalizing xs with\n    | h xls ih =>\n        rw [\u2190 hxl] at h1;\n        cases xs with\n        | nil => simp at h1;\n        | cons head2 tail2 =>\n          cases tail2 with\n          | nil => unfold pairwise; simp at hxl; rw [\u2190hxl]; simp;\n          | cons head3 tail3 =>\n            unfold pairwise;\n            rw [\u2190hxl, List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _]\n            ring_nf;\n            simp;\n            have hodd: Odd tail3.length := by\n              rw [List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.add_assoc, Nat.odd_add] at h1;\n              apply h1.2; simp;\n            have tmp := ih tail3.length (by rw [\u2190hxl]; simp; linarith;) tail3 rfl hodd\n            ring_nf at tmp;\n            rw [tmp];\n            ring_nf;\n  case neg;\n    induction xl using Nat.strong_induction_on generalizing xs with\n    | h xls ih =>\n        rw [\u2190 hxl] at h1;\n        cases xs with\n        | nil => unfold pairwise; simp [\u2190 hxl]\n        | cons head2 tail2 =>\n          cases tail2 with\n          | nil => simp at h1;\n          | cons head3 tail3 =>\n            unfold pairwise;\n            rw [\u2190hxl, List.length_cons, List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n            ring_nf;\n            simp;\n            simp at h1;\n            have heven: Even tail3.length := by\n              rw [Nat.add_assoc, Nat.even_add] at h1;\n              apply h1.2; simp;\n            simp at ih;\n            have tmp := ih tail3.length (by rw [\u2190hxl]; simp; linarith;) tail3 rfl heven\n            ring_nf at tmp;\n            exact tmp;\n\n\ndef mergingbu : List (List Nat) \u2192 List Nat\n| [] => []\n| [xs] => xs\n| xs::ys::xss =>\n  have _h: (pairwise (xs::ys::xss)).length < (xs::ys::xss).length := by\n    suffices h': 2* List.length (pairwise (xs :: ys :: xss)) < 2 * List.length (xs :: ys :: xss)\n    case h';\n      rw [ len_pairwise _];\n      split_ifs with hparity;\n      case pos;\n        simp;\n        ring_nf;\n        linarith;\n      case neg;\n        simp;\n    linarith [h'];\n  mergingbu (pairwise (xs::ys::xss))\ntermination_by xss => xss.length\n\n\ndef msortbu : List Nat \u2192 List Nat\n| xs => mergingbu (xs.map (fun x => [x]))\n", "proof_state": "xs : List \u2115\n\u22a2 (ordered (msortbu xs) == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:352"}
{"full_name": "prop_MSortBUCount", "prop_defn": "theorem prop_MSortBUCount (x: Nat) (xs: List Nat) : count x (msortbu xs) == count x xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:353", "score": 5, "deps": "import Mathlib\n\ndef count [DecidableEq \u03b1] : \u03b1 \u2192 List \u03b1 \u2192 Nat\n| _x, [] => 0\n| x, y::ys => if x == y then 1 + (count x ys) else count x ys\n\n\ndef lmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => if  x <= y  then\n      x::(lmerge xs (y::ys))\n    else\n      y::(lmerge (x::xs) ys)\n\n\ndef pairwise : List (List Nat) \u2192 List (List Nat)\n| xs::ys::xss => lmerge xs ys :: pairwise xss\n| xss => xss\n\n\nlemma len_pairwise (xs: List (List Nat)): 2 * (pairwise xs).length = (if (Odd xs.length) then xs.length + 1 else xs.length) := by\n  generalize hxl : xs.length = xl;\n  split_ifs with h1;\n  case pos;\n    induction xl using Nat.strong_induction_on generalizing xs with\n    | h xls ih =>\n        rw [\u2190 hxl] at h1;\n        cases xs with\n        | nil => simp at h1;\n        | cons head2 tail2 =>\n          cases tail2 with\n          | nil => unfold pairwise; simp at hxl; rw [\u2190hxl]; simp;\n          | cons head3 tail3 =>\n            unfold pairwise;\n            rw [\u2190hxl, List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _]\n            ring_nf;\n            simp;\n            have hodd: Odd tail3.length := by\n              rw [List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.add_assoc, Nat.odd_add] at h1;\n              apply h1.2; simp;\n            have tmp := ih tail3.length (by rw [\u2190hxl]; simp; linarith;) tail3 rfl hodd\n            ring_nf at tmp;\n            rw [tmp];\n            ring_nf;\n  case neg;\n    induction xl using Nat.strong_induction_on generalizing xs with\n    | h xls ih =>\n        rw [\u2190 hxl] at h1;\n        cases xs with\n        | nil => unfold pairwise; simp [\u2190 hxl]\n        | cons head2 tail2 =>\n          cases tail2 with\n          | nil => simp at h1;\n          | cons head3 tail3 =>\n            unfold pairwise;\n            rw [\u2190hxl, List.length_cons, List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n            ring_nf;\n            simp;\n            simp at h1;\n            have heven: Even tail3.length := by\n              rw [Nat.add_assoc, Nat.even_add] at h1;\n              apply h1.2; simp;\n            simp at ih;\n            have tmp := ih tail3.length (by rw [\u2190hxl]; simp; linarith;) tail3 rfl heven\n            ring_nf at tmp;\n            exact tmp;\n\n\ndef mergingbu : List (List Nat) \u2192 List Nat\n| [] => []\n| [xs] => xs\n| xs::ys::xss =>\n  have _h: (pairwise (xs::ys::xss)).length < (xs::ys::xss).length := by\n    suffices h': 2* List.length (pairwise (xs :: ys :: xss)) < 2 * List.length (xs :: ys :: xss)\n    case h';\n      rw [ len_pairwise _];\n      split_ifs with hparity;\n      case pos;\n        simp;\n        ring_nf;\n        linarith;\n      case neg;\n        simp;\n    linarith [h'];\n  mergingbu (pairwise (xs::ys::xss))\ntermination_by xss => xss.length\n\n\ndef msortbu : List Nat \u2192 List Nat\n| xs => mergingbu (xs.map (fun x => [x]))\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (count x (msortbu xs) == count x xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:353"}
{"full_name": "prop_MSortBUPermutes", "prop_defn": "theorem prop_MSortBUPermutes (xs: List Nat) : isPermutation (msortbu xs) xs == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:354", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n\n\ndef lmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => if  x <= y  then\n      x::(lmerge xs (y::ys))\n    else\n      y::(lmerge (x::xs) ys)\n\n\ndef pairwise : List (List Nat) \u2192 List (List Nat)\n| xs::ys::xss => lmerge xs ys :: pairwise xss\n| xss => xss\n\n\nlemma len_pairwise (xs: List (List Nat)): 2 * (pairwise xs).length = (if (Odd xs.length) then xs.length + 1 else xs.length) := by\n  generalize hxl : xs.length = xl;\n  split_ifs with h1;\n  case pos;\n    induction xl using Nat.strong_induction_on generalizing xs with\n    | h xls ih =>\n        rw [\u2190 hxl] at h1;\n        cases xs with\n        | nil => simp at h1;\n        | cons head2 tail2 =>\n          cases tail2 with\n          | nil => unfold pairwise; simp at hxl; rw [\u2190hxl]; simp;\n          | cons head3 tail3 =>\n            unfold pairwise;\n            rw [\u2190hxl, List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _]\n            ring_nf;\n            simp;\n            have hodd: Odd tail3.length := by\n              rw [List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.add_assoc, Nat.odd_add] at h1;\n              apply h1.2; simp;\n            have tmp := ih tail3.length (by rw [\u2190hxl]; simp; linarith;) tail3 rfl hodd\n            ring_nf at tmp;\n            rw [tmp];\n            ring_nf;\n  case neg;\n    induction xl using Nat.strong_induction_on generalizing xs with\n    | h xls ih =>\n        rw [\u2190 hxl] at h1;\n        cases xs with\n        | nil => unfold pairwise; simp [\u2190 hxl]\n        | cons head2 tail2 =>\n          cases tail2 with\n          | nil => simp at h1;\n          | cons head3 tail3 =>\n            unfold pairwise;\n            rw [\u2190hxl, List.length_cons, List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n            ring_nf;\n            simp;\n            simp at h1;\n            have heven: Even tail3.length := by\n              rw [Nat.add_assoc, Nat.even_add] at h1;\n              apply h1.2; simp;\n            simp at ih;\n            have tmp := ih tail3.length (by rw [\u2190hxl]; simp; linarith;) tail3 rfl heven\n            ring_nf at tmp;\n            exact tmp;\n\n\ndef mergingbu : List (List Nat) \u2192 List Nat\n| [] => []\n| [xs] => xs\n| xs::ys::xss =>\n  have _h: (pairwise (xs::ys::xss)).length < (xs::ys::xss).length := by\n    suffices h': 2* List.length (pairwise (xs :: ys :: xss)) < 2 * List.length (xs :: ys :: xss)\n    case h';\n      rw [ len_pairwise _];\n      split_ifs with hparity;\n      case pos;\n        simp;\n        ring_nf;\n        linarith;\n      case neg;\n        simp;\n    linarith [h'];\n  mergingbu (pairwise (xs::ys::xss))\ntermination_by xss => xss.length\n\n\ndef msortbu : List Nat \u2192 List Nat\n| xs => mergingbu (xs.map (fun x => [x]))\n", "proof_state": "xs : List \u2115\n\u22a2 (isPermutation (msortbu xs) xs == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:354"}
{"full_name": "prop_MSortBUIsSort", "prop_defn": "theorem prop_MSortBUIsSort (xs: List Nat) : msortbu xs == isort xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:355", "score": 5, "deps": "import Mathlib\n\ndef insert' : Nat \u2192 List Nat \u2192 List Nat\n| x, [] => [x]\n| x, y::xs => if x <= y then x::y::xs else y::(insert x xs)\n\n\ndef isort: List Nat \u2192 List Nat\n| [] => []\n| x::xs => insert' x (isort xs)\n\n\ndef lmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => if  x <= y  then\n      x::(lmerge xs (y::ys))\n    else\n      y::(lmerge (x::xs) ys)\n\n\ndef pairwise : List (List Nat) \u2192 List (List Nat)\n| xs::ys::xss => lmerge xs ys :: pairwise xss\n| xss => xss\n\n\nlemma len_pairwise (xs: List (List Nat)): 2 * (pairwise xs).length = (if (Odd xs.length) then xs.length + 1 else xs.length) := by\n  generalize hxl : xs.length = xl;\n  split_ifs with h1;\n  case pos;\n    induction xl using Nat.strong_induction_on generalizing xs with\n    | h xls ih =>\n        rw [\u2190 hxl] at h1;\n        cases xs with\n        | nil => simp at h1;\n        | cons head2 tail2 =>\n          cases tail2 with\n          | nil => unfold pairwise; simp at hxl; rw [\u2190hxl]; simp;\n          | cons head3 tail3 =>\n            unfold pairwise;\n            rw [\u2190hxl, List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _]\n            ring_nf;\n            simp;\n            have hodd: Odd tail3.length := by\n              rw [List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.add_assoc, Nat.odd_add] at h1;\n              apply h1.2; simp;\n            have tmp := ih tail3.length (by rw [\u2190hxl]; simp; linarith;) tail3 rfl hodd\n            ring_nf at tmp;\n            rw [tmp];\n            ring_nf;\n  case neg;\n    induction xl using Nat.strong_induction_on generalizing xs with\n    | h xls ih =>\n        rw [\u2190 hxl] at h1;\n        cases xs with\n        | nil => unfold pairwise; simp [\u2190 hxl]\n        | cons head2 tail2 =>\n          cases tail2 with\n          | nil => simp at h1;\n          | cons head3 tail3 =>\n            unfold pairwise;\n            rw [\u2190hxl, List.length_cons, List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n            ring_nf;\n            simp;\n            simp at h1;\n            have heven: Even tail3.length := by\n              rw [Nat.add_assoc, Nat.even_add] at h1;\n              apply h1.2; simp;\n            simp at ih;\n            have tmp := ih tail3.length (by rw [\u2190hxl]; simp; linarith;) tail3 rfl heven\n            ring_nf at tmp;\n            exact tmp;\n\n\ndef mergingbu : List (List Nat) \u2192 List Nat\n| [] => []\n| [xs] => xs\n| xs::ys::xss =>\n  have _h: (pairwise (xs::ys::xss)).length < (xs::ys::xss).length := by\n    suffices h': 2* List.length (pairwise (xs :: ys :: xss)) < 2 * List.length (xs :: ys :: xss)\n    case h';\n      rw [ len_pairwise _];\n      split_ifs with hparity;\n      case pos;\n        simp;\n        ring_nf;\n        linarith;\n      case neg;\n        simp;\n    linarith [h'];\n  mergingbu (pairwise (xs::ys::xss))\ntermination_by xss => xss.length\n\n\ndef msortbu : List Nat \u2192 List Nat\n| xs => mergingbu (xs.map (fun x => [x]))\n", "proof_state": "xs : List \u2115\n\u22a2 (msortbu xs == isort xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:355"}
{"full_name": "prop_MSortTDSorts", "prop_defn": "theorem prop_MSortTDSorts (xs: List Nat) : ordered (msorttd xs) == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:372", "score": 5, "deps": "import Mathlib\n\ndef ordered : List Nat -> Bool\n| []       => True\n| [_x]     => True\n| x::y::xs => x <= y && ordered (y::xs)\n\n\ndef lmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => if  x <= y  then\n      x::(lmerge xs (y::ys))\n    else\n      y::(lmerge (x::xs) ys)\n\n\ndef msorttd : List Nat \u2192 List Nat\n| [] => []\n| [x] => [x]\n| x::y::xs =>\n  let k:= (x::y::xs).length/2\n  have _h: Nat.succ (Nat.succ (List.length xs)) / 2 < Nat.succ (Nat.succ (List.length xs)) := by\n    rw [Nat.succ_eq_add_one _];\n    ring_nf;\n    simp [Nat.succ_eq_add_one _];\n    ring_nf;\n    calc 1 + xs.length/2 \u2264 1 + xs.length := by simp; exact Nat.div_le_self (List.length xs) 2;\n         _               < 2 + xs.length := by simp;\n  lmerge (msorttd ((x::y::xs).take k)) (msorttd ((x::y::xs).drop k))\ntermination_by xs => xs.length\n", "proof_state": "xs : List \u2115\n\u22a2 (ordered (msorttd xs) == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:372"}
{"full_name": "prop_MSortTDCount", "prop_defn": "theorem prop_MSortTDCount (x: Nat) (xs: List Nat) : count x (msorttd xs) == count x xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:373", "score": 5, "deps": "import Mathlib\n\ndef count [DecidableEq \u03b1] : \u03b1 \u2192 List \u03b1 \u2192 Nat\n| _x, [] => 0\n| x, y::ys => if x == y then 1 + (count x ys) else count x ys\n\n\ndef lmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => if  x <= y  then\n      x::(lmerge xs (y::ys))\n    else\n      y::(lmerge (x::xs) ys)\n\n\ndef msorttd : List Nat \u2192 List Nat\n| [] => []\n| [x] => [x]\n| x::y::xs =>\n  let k:= (x::y::xs).length/2\n  have _h: Nat.succ (Nat.succ (List.length xs)) / 2 < Nat.succ (Nat.succ (List.length xs)) := by\n    rw [Nat.succ_eq_add_one _];\n    ring_nf;\n    simp [Nat.succ_eq_add_one _];\n    ring_nf;\n    calc 1 + xs.length/2 \u2264 1 + xs.length := by simp; exact Nat.div_le_self (List.length xs) 2;\n         _               < 2 + xs.length := by simp;\n  lmerge (msorttd ((x::y::xs).take k)) (msorttd ((x::y::xs).drop k))\ntermination_by xs => xs.length\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (count x (msorttd xs) == count x xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:373"}
{"full_name": "prop_MSortTDPermutes", "prop_defn": "theorem prop_MSortTDPermutes (xs: List Nat) : isPermutation (msorttd xs) xs == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:374", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n\n\ndef lmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => if  x <= y  then\n      x::(lmerge xs (y::ys))\n    else\n      y::(lmerge (x::xs) ys)\n\n\ndef msorttd : List Nat \u2192 List Nat\n| [] => []\n| [x] => [x]\n| x::y::xs =>\n  let k:= (x::y::xs).length/2\n  have _h: Nat.succ (Nat.succ (List.length xs)) / 2 < Nat.succ (Nat.succ (List.length xs)) := by\n    rw [Nat.succ_eq_add_one _];\n    ring_nf;\n    simp [Nat.succ_eq_add_one _];\n    ring_nf;\n    calc 1 + xs.length/2 \u2264 1 + xs.length := by simp; exact Nat.div_le_self (List.length xs) 2;\n         _               < 2 + xs.length := by simp;\n  lmerge (msorttd ((x::y::xs).take k)) (msorttd ((x::y::xs).drop k))\ntermination_by xs => xs.length\n", "proof_state": "xs : List \u2115\n\u22a2 (isPermutation (msorttd xs) xs == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:374"}
{"full_name": "prop_MSortTDIsSort", "prop_defn": "theorem prop_MSortTDIsSort (xs: List Nat) : msorttd xs == isort xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:375", "score": 5, "deps": "import Mathlib\n\ndef insert' : Nat \u2192 List Nat \u2192 List Nat\n| x, [] => [x]\n| x, y::xs => if x <= y then x::y::xs else y::(insert x xs)\n\n\ndef isort: List Nat \u2192 List Nat\n| [] => []\n| x::xs => insert' x (isort xs)\n\n\ndef lmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => if  x <= y  then\n      x::(lmerge xs (y::ys))\n    else\n      y::(lmerge (x::xs) ys)\n\n\ndef msorttd : List Nat \u2192 List Nat\n| [] => []\n| [x] => [x]\n| x::y::xs =>\n  let k:= (x::y::xs).length/2\n  have _h: Nat.succ (Nat.succ (List.length xs)) / 2 < Nat.succ (Nat.succ (List.length xs)) := by\n    rw [Nat.succ_eq_add_one _];\n    ring_nf;\n    simp [Nat.succ_eq_add_one _];\n    ring_nf;\n    calc 1 + xs.length/2 \u2264 1 + xs.length := by simp; exact Nat.div_le_self (List.length xs) 2;\n         _               < 2 + xs.length := by simp;\n  lmerge (msorttd ((x::y::xs).take k)) (msorttd ((x::y::xs).drop k))\ntermination_by xs => xs.length\n", "proof_state": "xs : List \u2115\n\u22a2 (msorttd xs == isort xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:375"}
{"full_name": "prop_NMSortTDSorts", "prop_defn": "theorem prop_NMSortTDSorts (xs: List Nat) : ordered (nmsorttd xs) == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:420", "score": 5, "deps": "import Mathlib\n\ndef ordered : List Nat -> Bool\n| []       => True\n| [_x]     => True\n| x::y::xs => x <= y && ordered (y::xs)\n\n\ndef lmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => if  x <= y  then\n      x::(lmerge xs (y::ys))\n    else\n      y::(lmerge (x::xs) ys)\n\n\ndef half : Nat \u2192 Nat\n| 0 => 0\n| 1 => 0\n| x + 2 => 1 + (half x)\n\n\nlemma half_lt: half x \u2264 x := by\n  induction x using Nat.strong_induction_on with\n  | h n ih =>\n    cases n with\n    | zero => unfold half; simp;\n    | succ nm1 =>\n      cases nm1 with\n      | zero => unfold half; simp;\n      | succ nm2 =>\n        unfold half;\n        have tmp := ih nm2 (by exact Nat.le.step Nat.le.refl);\n        ring_nf;\n        calc 1 + half nm2 \u2264 1 + nm2  := Nat.add_le_add (@Nat.le.refl 1) tmp\n             _           \u2264  2 + nm2  := by simp\n\n\ndef nmsorttd : List Nat \u2192 List Nat\n| [] => []\n| [x] => [x]\n| x::y::xs =>\n  let k:= half ((x::y::xs).length)\n  have _h: half (Nat.succ (Nat.succ (List.length xs))) < Nat.succ (Nat.succ (List.length xs)) := by\n    rw [Nat.succ_eq_add_one _];\n    ring_nf;\n    rw [Nat.add_comm];\n    unfold half;\n    ring_nf;\n    calc 1 + half (xs.length) \u2264 1 + xs.length := by simp; exact half_lt;\n         _               < 2 + xs.length := by simp;\n  have _h': Nat.succ (Nat.succ (List.length xs)) - half (Nat.succ (Nat.succ (List.length xs))) <\n  Nat.succ (Nat.succ (List.length xs)) := by\n    suffices h': 0 < half (Nat.succ (Nat.succ (List.length xs)))\n    case h';\n      unfold half;simp;\n    refine Nat.sub_lt ?h h'\n    simp;\n  lmerge (nmsorttd ((x::y::xs).take k)) (nmsorttd ((x::y::xs).drop k))\ntermination_by xs => xs.length\n", "proof_state": "xs : List \u2115\n\u22a2 (ordered (nmsorttd xs) == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:420"}
{"full_name": "prop_NMSortTDCount", "prop_defn": "theorem prop_NMSortTDCount (x: Nat) (xs: List Nat) : count x (nmsorttd xs) == count x xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:421", "score": 5, "deps": "import Mathlib\n\ndef count [DecidableEq \u03b1] : \u03b1 \u2192 List \u03b1 \u2192 Nat\n| _x, [] => 0\n| x, y::ys => if x == y then 1 + (count x ys) else count x ys\n\n\ndef lmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => if  x <= y  then\n      x::(lmerge xs (y::ys))\n    else\n      y::(lmerge (x::xs) ys)\n\n\ndef half : Nat \u2192 Nat\n| 0 => 0\n| 1 => 0\n| x + 2 => 1 + (half x)\n\n\nlemma half_lt: half x \u2264 x := by\n  induction x using Nat.strong_induction_on with\n  | h n ih =>\n    cases n with\n    | zero => unfold half; simp;\n    | succ nm1 =>\n      cases nm1 with\n      | zero => unfold half; simp;\n      | succ nm2 =>\n        unfold half;\n        have tmp := ih nm2 (by exact Nat.le.step Nat.le.refl);\n        ring_nf;\n        calc 1 + half nm2 \u2264 1 + nm2  := Nat.add_le_add (@Nat.le.refl 1) tmp\n             _           \u2264  2 + nm2  := by simp\n\n\ndef nmsorttd : List Nat \u2192 List Nat\n| [] => []\n| [x] => [x]\n| x::y::xs =>\n  let k:= half ((x::y::xs).length)\n  have _h: half (Nat.succ (Nat.succ (List.length xs))) < Nat.succ (Nat.succ (List.length xs)) := by\n    rw [Nat.succ_eq_add_one _];\n    ring_nf;\n    rw [Nat.add_comm];\n    unfold half;\n    ring_nf;\n    calc 1 + half (xs.length) \u2264 1 + xs.length := by simp; exact half_lt;\n         _               < 2 + xs.length := by simp;\n  have _h': Nat.succ (Nat.succ (List.length xs)) - half (Nat.succ (Nat.succ (List.length xs))) <\n  Nat.succ (Nat.succ (List.length xs)) := by\n    suffices h': 0 < half (Nat.succ (Nat.succ (List.length xs)))\n    case h';\n      unfold half;simp;\n    refine Nat.sub_lt ?h h'\n    simp;\n  lmerge (nmsorttd ((x::y::xs).take k)) (nmsorttd ((x::y::xs).drop k))\ntermination_by xs => xs.length\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (count x (nmsorttd xs) == count x xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:421"}
{"full_name": "prop_NMSortTDPermutes", "prop_defn": "theorem prop_NMSortTDPermutes (xs: List Nat) : isPermutation (nmsorttd xs) xs == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:422", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n\n\ndef lmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => if  x <= y  then\n      x::(lmerge xs (y::ys))\n    else\n      y::(lmerge (x::xs) ys)\n\n\ndef half : Nat \u2192 Nat\n| 0 => 0\n| 1 => 0\n| x + 2 => 1 + (half x)\n\n\nlemma half_lt: half x \u2264 x := by\n  induction x using Nat.strong_induction_on with\n  | h n ih =>\n    cases n with\n    | zero => unfold half; simp;\n    | succ nm1 =>\n      cases nm1 with\n      | zero => unfold half; simp;\n      | succ nm2 =>\n        unfold half;\n        have tmp := ih nm2 (by exact Nat.le.step Nat.le.refl);\n        ring_nf;\n        calc 1 + half nm2 \u2264 1 + nm2  := Nat.add_le_add (@Nat.le.refl 1) tmp\n             _           \u2264  2 + nm2  := by simp\n\n\ndef nmsorttd : List Nat \u2192 List Nat\n| [] => []\n| [x] => [x]\n| x::y::xs =>\n  let k:= half ((x::y::xs).length)\n  have _h: half (Nat.succ (Nat.succ (List.length xs))) < Nat.succ (Nat.succ (List.length xs)) := by\n    rw [Nat.succ_eq_add_one _];\n    ring_nf;\n    rw [Nat.add_comm];\n    unfold half;\n    ring_nf;\n    calc 1 + half (xs.length) \u2264 1 + xs.length := by simp; exact half_lt;\n         _               < 2 + xs.length := by simp;\n  have _h': Nat.succ (Nat.succ (List.length xs)) - half (Nat.succ (Nat.succ (List.length xs))) <\n  Nat.succ (Nat.succ (List.length xs)) := by\n    suffices h': 0 < half (Nat.succ (Nat.succ (List.length xs)))\n    case h';\n      unfold half;simp;\n    refine Nat.sub_lt ?h h'\n    simp;\n  lmerge (nmsorttd ((x::y::xs).take k)) (nmsorttd ((x::y::xs).drop k))\ntermination_by xs => xs.length\n", "proof_state": "xs : List \u2115\n\u22a2 (isPermutation (nmsorttd xs) xs == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:422"}
{"full_name": "prop_NMSortTDIsSort", "prop_defn": "theorem prop_NMSortTDIsSort (xs: List Nat) : nmsorttd xs == isort xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:423", "score": 5, "deps": "import Mathlib\n\ndef insert' : Nat \u2192 List Nat \u2192 List Nat\n| x, [] => [x]\n| x, y::xs => if x <= y then x::y::xs else y::(insert x xs)\n\n\ndef isort: List Nat \u2192 List Nat\n| [] => []\n| x::xs => insert' x (isort xs)\n\n\ndef lmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => if  x <= y  then\n      x::(lmerge xs (y::ys))\n    else\n      y::(lmerge (x::xs) ys)\n\n\ndef half : Nat \u2192 Nat\n| 0 => 0\n| 1 => 0\n| x + 2 => 1 + (half x)\n\n\nlemma half_lt: half x \u2264 x := by\n  induction x using Nat.strong_induction_on with\n  | h n ih =>\n    cases n with\n    | zero => unfold half; simp;\n    | succ nm1 =>\n      cases nm1 with\n      | zero => unfold half; simp;\n      | succ nm2 =>\n        unfold half;\n        have tmp := ih nm2 (by exact Nat.le.step Nat.le.refl);\n        ring_nf;\n        calc 1 + half nm2 \u2264 1 + nm2  := Nat.add_le_add (@Nat.le.refl 1) tmp\n             _           \u2264  2 + nm2  := by simp\n\n\ndef nmsorttd : List Nat \u2192 List Nat\n| [] => []\n| [x] => [x]\n| x::y::xs =>\n  let k:= half ((x::y::xs).length)\n  have _h: half (Nat.succ (Nat.succ (List.length xs))) < Nat.succ (Nat.succ (List.length xs)) := by\n    rw [Nat.succ_eq_add_one _];\n    ring_nf;\n    rw [Nat.add_comm];\n    unfold half;\n    ring_nf;\n    calc 1 + half (xs.length) \u2264 1 + xs.length := by simp; exact half_lt;\n         _               < 2 + xs.length := by simp;\n  have _h': Nat.succ (Nat.succ (List.length xs)) - half (Nat.succ (Nat.succ (List.length xs))) <\n  Nat.succ (Nat.succ (List.length xs)) := by\n    suffices h': 0 < half (Nat.succ (Nat.succ (List.length xs)))\n    case h';\n      unfold half;simp;\n    refine Nat.sub_lt ?h h'\n    simp;\n  lmerge (nmsorttd ((x::y::xs).take k)) (nmsorttd ((x::y::xs).drop k))\ntermination_by xs => xs.length\n", "proof_state": "xs : List \u2115\n\u22a2 (nmsorttd xs == isort xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:423"}
{"full_name": "prop_BSortSorts", "prop_defn": "theorem prop_BSortSorts (xs: List Nat) : ordered (bsort xs) == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:530", "score": 5, "deps": "import Mathlib\n\ndef ordered : List Nat -> Bool\n| []       => True\n| [_x]     => True\n| x::y::xs => x <= y && ordered (y::xs)\n\n\nmutual\n  def evens : List Nat \u2192 List Nat\n  | [] => []\n  | x::xs => x::(odds xs)\n--\n  def odds : List Nat \u2192 List Nat\n  | [] => []\n  | _x::xs => evens xs\nend\n\n\nlemma len_evens_le : (evens xs).length \u2264 xs.length := by\n  generalize hxsl: xs.length = xsl\n  induction xsl using Nat.strong_induction_on generalizing xs with\n  | h n ih =>\n    cases xs with\n    | nil => unfold evens; simp;\n    | cons head1 tail1 =>\n      unfold evens;\n      cases tail1 with\n      | nil => unfold odds; rw[\u2190 hxsl];\n      | cons head2 tail2 =>\n        unfold odds;\n        rw [List.length_cons, List.length_cons] at hxsl;\n        rw [\u2190 hxsl, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n        simp;\n        have h': List.length tail2 < n := by rw [\u2190 hxsl, Nat.succ_eq_add_one _]; linarith;\n        exact Nat.le.step (ih (List.length tail2) h' rfl);\n\n\nlemma len_odds_le : (odds xs).length \u2264 xs.length := by\n  generalize hxsl: xs.length = xsl\n  induction xsl using Nat.strong_induction_on generalizing xs with\n  | h n ih =>\n    cases xs with\n    | nil => unfold odds; simp;\n    | cons head1 tail1 =>\n      unfold odds;\n      cases tail1 with\n      | nil => unfold evens; simp;\n      | cons head2 tail2 =>\n        unfold evens;\n        rw [List.length_cons, List.length_cons] at hxsl;\n        rw [\u2190 hxsl, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n        simp;\n        have h': List.length tail2 < n := by rw [\u2190 hxsl, Nat.succ_eq_add_one _]; linarith;\n        exact Nat.le.step (ih (List.length tail2) h' rfl);\n\n\ndef sort2 (a b: Nat): List Nat := if a \u2264 b then [a,b] else [b, a]\n\n\ndef pairs : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => (sort2 x y) ++ (pairs xs ys)\n\n\ndef stitch : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| x::xs, ys => x::(pairs xs ys)\n\n\nlemma bmerge_term (a b: Nat) (as bs: List Nat) (hlen: \u00ac(List.length as == 0 && List.length bs == 0) = true): List.length (evens (a :: as)) + List.length (evens (b :: bs)) < Nat.succ (List.length as) + Nat.succ (List.length bs) := by\n    unfold evens;\n    simp at hlen;\n    rw [List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n    ring_nf;\n    cases as with\n    | nil => cases bs with\n      | nil => simp at hlen;\n      | cons bhead btail => unfold odds; simp; linarith [@len_evens_le btail];\n    | cons ahead atail =>\n      rw [add_comm, add_comm (2 + List.length (ahead :: atail)) (List.length bs)]\n      refine add_lt_add_of_le_of_lt (@len_odds_le bs) ?h; unfold odds; simp; linarith [@len_evens_le atail];\n\n\nlemma bmerge_term2 (x y: Nat) (xs ys: List Nat) : List.length (odds (x :: xs)) + List.length (odds (y :: ys)) < Nat.succ (List.length xs) + Nat.succ (List.length ys) := by\n  unfold odds;\n  exact add_lt_add_of_lt_of_lt (Nat.lt_succ_of_le (@len_evens_le xs)) (Nat.lt_succ_of_le (@len_evens_le ys))\n\n\ndef bmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], bs => bs -- I changed this from TIP. I don't believe this case is ever hit, though.\n| as, [] => as\n| x::xs, y::ys =>\n  if hlen: xs.length == 0 && ys.length == 0 then sort2 x y else\n  have _h := bmerge_term x y xs ys hlen;\n  have _h2 := bmerge_term2 x y xs ys;\n  stitch (bmerge (evens (x::xs)) (evens (y::ys))) (bmerge (odds (x::xs)) (odds (y::ys)))\ntermination_by xs ys => xs.length + ys.length\n\n\nlemma bsort_term1 (x y: Nat) (xs: List Nat): List.length (evens (x :: y :: xs)) < Nat.succ (Nat.succ (List.length xs)) := by\n  unfold evens; unfold odds;\n  rw [List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n  simp;\n  exact Nat.lt_succ_of_le (@len_evens_le xs);\n\n\nlemma bsort_term2 (x y: Nat) (xs: List Nat): List.length (odds (x :: y :: xs)) < Nat.succ (Nat.succ (List.length xs)) := by\n  unfold odds; unfold evens;\n  rw [List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n  simp;\n  exact Nat.lt_succ_of_le (@len_odds_le xs);\n\n\ndef bsort : List Nat \u2192 List Nat\n| [] => []\n| [x] => [x]\n| x::y::xs =>\n  have _h := bsort_term1 x y xs\n  have _h2 := bsort_term2 x y xs\n  bmerge (bsort (evens (x::y::xs))) (bsort (odds (x::y::xs)))\ntermination_by xs => xs.length\n", "proof_state": "xs : List \u2115\n\u22a2 (ordered (bsort xs) == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:530"}
{"full_name": "prop_BSortCount", "prop_defn": "theorem prop_BSortCount (x: Nat) (xs: List Nat) : count x (bsort xs) == count x xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:531", "score": 5, "deps": "import Mathlib\n\ndef count [DecidableEq \u03b1] : \u03b1 \u2192 List \u03b1 \u2192 Nat\n| _x, [] => 0\n| x, y::ys => if x == y then 1 + (count x ys) else count x ys\n\n\nmutual\n  def evens : List Nat \u2192 List Nat\n  | [] => []\n  | x::xs => x::(odds xs)\n--\n  def odds : List Nat \u2192 List Nat\n  | [] => []\n  | _x::xs => evens xs\nend\n\n\nlemma len_evens_le : (evens xs).length \u2264 xs.length := by\n  generalize hxsl: xs.length = xsl\n  induction xsl using Nat.strong_induction_on generalizing xs with\n  | h n ih =>\n    cases xs with\n    | nil => unfold evens; simp;\n    | cons head1 tail1 =>\n      unfold evens;\n      cases tail1 with\n      | nil => unfold odds; rw[\u2190 hxsl];\n      | cons head2 tail2 =>\n        unfold odds;\n        rw [List.length_cons, List.length_cons] at hxsl;\n        rw [\u2190 hxsl, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n        simp;\n        have h': List.length tail2 < n := by rw [\u2190 hxsl, Nat.succ_eq_add_one _]; linarith;\n        exact Nat.le.step (ih (List.length tail2) h' rfl);\n\n\nlemma len_odds_le : (odds xs).length \u2264 xs.length := by\n  generalize hxsl: xs.length = xsl\n  induction xsl using Nat.strong_induction_on generalizing xs with\n  | h n ih =>\n    cases xs with\n    | nil => unfold odds; simp;\n    | cons head1 tail1 =>\n      unfold odds;\n      cases tail1 with\n      | nil => unfold evens; simp;\n      | cons head2 tail2 =>\n        unfold evens;\n        rw [List.length_cons, List.length_cons] at hxsl;\n        rw [\u2190 hxsl, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n        simp;\n        have h': List.length tail2 < n := by rw [\u2190 hxsl, Nat.succ_eq_add_one _]; linarith;\n        exact Nat.le.step (ih (List.length tail2) h' rfl);\n\n\ndef sort2 (a b: Nat): List Nat := if a \u2264 b then [a,b] else [b, a]\n\n\ndef pairs : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => (sort2 x y) ++ (pairs xs ys)\n\n\ndef stitch : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| x::xs, ys => x::(pairs xs ys)\n\n\nlemma bmerge_term (a b: Nat) (as bs: List Nat) (hlen: \u00ac(List.length as == 0 && List.length bs == 0) = true): List.length (evens (a :: as)) + List.length (evens (b :: bs)) < Nat.succ (List.length as) + Nat.succ (List.length bs) := by\n    unfold evens;\n    simp at hlen;\n    rw [List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n    ring_nf;\n    cases as with\n    | nil => cases bs with\n      | nil => simp at hlen;\n      | cons bhead btail => unfold odds; simp; linarith [@len_evens_le btail];\n    | cons ahead atail =>\n      rw [add_comm, add_comm (2 + List.length (ahead :: atail)) (List.length bs)]\n      refine add_lt_add_of_le_of_lt (@len_odds_le bs) ?h; unfold odds; simp; linarith [@len_evens_le atail];\n\n\nlemma bmerge_term2 (x y: Nat) (xs ys: List Nat) : List.length (odds (x :: xs)) + List.length (odds (y :: ys)) < Nat.succ (List.length xs) + Nat.succ (List.length ys) := by\n  unfold odds;\n  exact add_lt_add_of_lt_of_lt (Nat.lt_succ_of_le (@len_evens_le xs)) (Nat.lt_succ_of_le (@len_evens_le ys))\n\n\ndef bmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], bs => bs -- I changed this from TIP. I don't believe this case is ever hit, though.\n| as, [] => as\n| x::xs, y::ys =>\n  if hlen: xs.length == 0 && ys.length == 0 then sort2 x y else\n  have _h := bmerge_term x y xs ys hlen;\n  have _h2 := bmerge_term2 x y xs ys;\n  stitch (bmerge (evens (x::xs)) (evens (y::ys))) (bmerge (odds (x::xs)) (odds (y::ys)))\ntermination_by xs ys => xs.length + ys.length\n\n\nlemma bsort_term1 (x y: Nat) (xs: List Nat): List.length (evens (x :: y :: xs)) < Nat.succ (Nat.succ (List.length xs)) := by\n  unfold evens; unfold odds;\n  rw [List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n  simp;\n  exact Nat.lt_succ_of_le (@len_evens_le xs);\n\n\nlemma bsort_term2 (x y: Nat) (xs: List Nat): List.length (odds (x :: y :: xs)) < Nat.succ (Nat.succ (List.length xs)) := by\n  unfold odds; unfold evens;\n  rw [List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n  simp;\n  exact Nat.lt_succ_of_le (@len_odds_le xs);\n\n\ndef bsort : List Nat \u2192 List Nat\n| [] => []\n| [x] => [x]\n| x::y::xs =>\n  have _h := bsort_term1 x y xs\n  have _h2 := bsort_term2 x y xs\n  bmerge (bsort (evens (x::y::xs))) (bsort (odds (x::y::xs)))\ntermination_by xs => xs.length\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (count x (bsort xs) == count x xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:531"}
{"full_name": "prop_BSortPermutes", "prop_defn": "theorem prop_BSortPermutes (xs: List Nat) : isPermutation (bsort xs) xs == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:532", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n\n\nmutual\n  def evens : List Nat \u2192 List Nat\n  | [] => []\n  | x::xs => x::(odds xs)\n--\n  def odds : List Nat \u2192 List Nat\n  | [] => []\n  | _x::xs => evens xs\nend\n\n\nlemma len_evens_le : (evens xs).length \u2264 xs.length := by\n  generalize hxsl: xs.length = xsl\n  induction xsl using Nat.strong_induction_on generalizing xs with\n  | h n ih =>\n    cases xs with\n    | nil => unfold evens; simp;\n    | cons head1 tail1 =>\n      unfold evens;\n      cases tail1 with\n      | nil => unfold odds; rw[\u2190 hxsl];\n      | cons head2 tail2 =>\n        unfold odds;\n        rw [List.length_cons, List.length_cons] at hxsl;\n        rw [\u2190 hxsl, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n        simp;\n        have h': List.length tail2 < n := by rw [\u2190 hxsl, Nat.succ_eq_add_one _]; linarith;\n        exact Nat.le.step (ih (List.length tail2) h' rfl);\n\n\nlemma len_odds_le : (odds xs).length \u2264 xs.length := by\n  generalize hxsl: xs.length = xsl\n  induction xsl using Nat.strong_induction_on generalizing xs with\n  | h n ih =>\n    cases xs with\n    | nil => unfold odds; simp;\n    | cons head1 tail1 =>\n      unfold odds;\n      cases tail1 with\n      | nil => unfold evens; simp;\n      | cons head2 tail2 =>\n        unfold evens;\n        rw [List.length_cons, List.length_cons] at hxsl;\n        rw [\u2190 hxsl, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n        simp;\n        have h': List.length tail2 < n := by rw [\u2190 hxsl, Nat.succ_eq_add_one _]; linarith;\n        exact Nat.le.step (ih (List.length tail2) h' rfl);\n\n\ndef sort2 (a b: Nat): List Nat := if a \u2264 b then [a,b] else [b, a]\n\n\ndef pairs : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => (sort2 x y) ++ (pairs xs ys)\n\n\ndef stitch : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| x::xs, ys => x::(pairs xs ys)\n\n\nlemma bmerge_term (a b: Nat) (as bs: List Nat) (hlen: \u00ac(List.length as == 0 && List.length bs == 0) = true): List.length (evens (a :: as)) + List.length (evens (b :: bs)) < Nat.succ (List.length as) + Nat.succ (List.length bs) := by\n    unfold evens;\n    simp at hlen;\n    rw [List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n    ring_nf;\n    cases as with\n    | nil => cases bs with\n      | nil => simp at hlen;\n      | cons bhead btail => unfold odds; simp; linarith [@len_evens_le btail];\n    | cons ahead atail =>\n      rw [add_comm, add_comm (2 + List.length (ahead :: atail)) (List.length bs)]\n      refine add_lt_add_of_le_of_lt (@len_odds_le bs) ?h; unfold odds; simp; linarith [@len_evens_le atail];\n\n\nlemma bmerge_term2 (x y: Nat) (xs ys: List Nat) : List.length (odds (x :: xs)) + List.length (odds (y :: ys)) < Nat.succ (List.length xs) + Nat.succ (List.length ys) := by\n  unfold odds;\n  exact add_lt_add_of_lt_of_lt (Nat.lt_succ_of_le (@len_evens_le xs)) (Nat.lt_succ_of_le (@len_evens_le ys))\n\n\ndef bmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], bs => bs -- I changed this from TIP. I don't believe this case is ever hit, though.\n| as, [] => as\n| x::xs, y::ys =>\n  if hlen: xs.length == 0 && ys.length == 0 then sort2 x y else\n  have _h := bmerge_term x y xs ys hlen;\n  have _h2 := bmerge_term2 x y xs ys;\n  stitch (bmerge (evens (x::xs)) (evens (y::ys))) (bmerge (odds (x::xs)) (odds (y::ys)))\ntermination_by xs ys => xs.length + ys.length\n\n\nlemma bsort_term1 (x y: Nat) (xs: List Nat): List.length (evens (x :: y :: xs)) < Nat.succ (Nat.succ (List.length xs)) := by\n  unfold evens; unfold odds;\n  rw [List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n  simp;\n  exact Nat.lt_succ_of_le (@len_evens_le xs);\n\n\nlemma bsort_term2 (x y: Nat) (xs: List Nat): List.length (odds (x :: y :: xs)) < Nat.succ (Nat.succ (List.length xs)) := by\n  unfold odds; unfold evens;\n  rw [List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n  simp;\n  exact Nat.lt_succ_of_le (@len_odds_le xs);\n\n\ndef bsort : List Nat \u2192 List Nat\n| [] => []\n| [x] => [x]\n| x::y::xs =>\n  have _h := bsort_term1 x y xs\n  have _h2 := bsort_term2 x y xs\n  bmerge (bsort (evens (x::y::xs))) (bsort (odds (x::y::xs)))\ntermination_by xs => xs.length\n", "proof_state": "xs : List \u2115\n\u22a2 (isPermutation (bsort xs) xs == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:532"}
{"full_name": "prop_BSortIsSort", "prop_defn": "theorem prop_BSortIsSort (xs: List Nat) : bsort xs == isort xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:533", "score": 5, "deps": "import Mathlib\n\ndef insert' : Nat \u2192 List Nat \u2192 List Nat\n| x, [] => [x]\n| x, y::xs => if x <= y then x::y::xs else y::(insert x xs)\n\n\ndef isort: List Nat \u2192 List Nat\n| [] => []\n| x::xs => insert' x (isort xs)\n\n\nmutual\n  def evens : List Nat \u2192 List Nat\n  | [] => []\n  | x::xs => x::(odds xs)\n--\n  def odds : List Nat \u2192 List Nat\n  | [] => []\n  | _x::xs => evens xs\nend\n\n\nlemma len_evens_le : (evens xs).length \u2264 xs.length := by\n  generalize hxsl: xs.length = xsl\n  induction xsl using Nat.strong_induction_on generalizing xs with\n  | h n ih =>\n    cases xs with\n    | nil => unfold evens; simp;\n    | cons head1 tail1 =>\n      unfold evens;\n      cases tail1 with\n      | nil => unfold odds; rw[\u2190 hxsl];\n      | cons head2 tail2 =>\n        unfold odds;\n        rw [List.length_cons, List.length_cons] at hxsl;\n        rw [\u2190 hxsl, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n        simp;\n        have h': List.length tail2 < n := by rw [\u2190 hxsl, Nat.succ_eq_add_one _]; linarith;\n        exact Nat.le.step (ih (List.length tail2) h' rfl);\n\n\nlemma len_odds_le : (odds xs).length \u2264 xs.length := by\n  generalize hxsl: xs.length = xsl\n  induction xsl using Nat.strong_induction_on generalizing xs with\n  | h n ih =>\n    cases xs with\n    | nil => unfold odds; simp;\n    | cons head1 tail1 =>\n      unfold odds;\n      cases tail1 with\n      | nil => unfold evens; simp;\n      | cons head2 tail2 =>\n        unfold evens;\n        rw [List.length_cons, List.length_cons] at hxsl;\n        rw [\u2190 hxsl, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n        simp;\n        have h': List.length tail2 < n := by rw [\u2190 hxsl, Nat.succ_eq_add_one _]; linarith;\n        exact Nat.le.step (ih (List.length tail2) h' rfl);\n\n\ndef sort2 (a b: Nat): List Nat := if a \u2264 b then [a,b] else [b, a]\n\n\ndef pairs : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => (sort2 x y) ++ (pairs xs ys)\n\n\ndef stitch : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| x::xs, ys => x::(pairs xs ys)\n\n\nlemma bmerge_term (a b: Nat) (as bs: List Nat) (hlen: \u00ac(List.length as == 0 && List.length bs == 0) = true): List.length (evens (a :: as)) + List.length (evens (b :: bs)) < Nat.succ (List.length as) + Nat.succ (List.length bs) := by\n    unfold evens;\n    simp at hlen;\n    rw [List.length_cons, List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n    ring_nf;\n    cases as with\n    | nil => cases bs with\n      | nil => simp at hlen;\n      | cons bhead btail => unfold odds; simp; linarith [@len_evens_le btail];\n    | cons ahead atail =>\n      rw [add_comm, add_comm (2 + List.length (ahead :: atail)) (List.length bs)]\n      refine add_lt_add_of_le_of_lt (@len_odds_le bs) ?h; unfold odds; simp; linarith [@len_evens_le atail];\n\n\nlemma bmerge_term2 (x y: Nat) (xs ys: List Nat) : List.length (odds (x :: xs)) + List.length (odds (y :: ys)) < Nat.succ (List.length xs) + Nat.succ (List.length ys) := by\n  unfold odds;\n  exact add_lt_add_of_lt_of_lt (Nat.lt_succ_of_le (@len_evens_le xs)) (Nat.lt_succ_of_le (@len_evens_le ys))\n\n\ndef bmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], bs => bs -- I changed this from TIP. I don't believe this case is ever hit, though.\n| as, [] => as\n| x::xs, y::ys =>\n  if hlen: xs.length == 0 && ys.length == 0 then sort2 x y else\n  have _h := bmerge_term x y xs ys hlen;\n  have _h2 := bmerge_term2 x y xs ys;\n  stitch (bmerge (evens (x::xs)) (evens (y::ys))) (bmerge (odds (x::xs)) (odds (y::ys)))\ntermination_by xs ys => xs.length + ys.length\n\n\nlemma bsort_term1 (x y: Nat) (xs: List Nat): List.length (evens (x :: y :: xs)) < Nat.succ (Nat.succ (List.length xs)) := by\n  unfold evens; unfold odds;\n  rw [List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n  simp;\n  exact Nat.lt_succ_of_le (@len_evens_le xs);\n\n\nlemma bsort_term2 (x y: Nat) (xs: List Nat): List.length (odds (x :: y :: xs)) < Nat.succ (Nat.succ (List.length xs)) := by\n  unfold odds; unfold evens;\n  rw [List.length_cons, Nat.succ_eq_add_one _, Nat.succ_eq_add_one _];\n  simp;\n  exact Nat.lt_succ_of_le (@len_odds_le xs);\n\n\ndef bsort : List Nat \u2192 List Nat\n| [] => []\n| [x] => [x]\n| x::y::xs =>\n  have _h := bsort_term1 x y xs\n  have _h2 := bsort_term2 x y xs\n  bmerge (bsort (evens (x::y::xs))) (bsort (odds (x::y::xs)))\ntermination_by xs => xs.length\n", "proof_state": "xs : List \u2115\n\u22a2 (bsort xs == isort xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:533"}
{"full_name": "prop_QSortSorts", "prop_defn": "theorem prop_QSortSorts (xs: List Nat) : ordered (qsort xs) == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:570", "score": 5, "deps": "import Mathlib\n\ndef ordered : List Nat -> Bool\n| []       => True\n| [_x]     => True\n| x::y::xs => x <= y && ordered (y::xs)\n\n\ndef filter : List Nat \u2192 (Nat \u2192 Bool) \u2192 List Nat\n| [], _f => []\n| x::xs, f => if f x then x::(filter xs f) else (filter xs f)\n\n\nlemma filter_len_le {f: Nat \u2192 Bool} {xs: List Nat}: (filter xs f).length <= xs.length := by\n  generalize hxsl: xs.length = xsl\n  induction xsl generalizing xs with\n  | zero => rw [List.length_eq_zero] at hxsl; rw [hxsl]; unfold filter; simp;\n  | succ n ih =>\n    cases xs with\n    | nil => unfold filter; simp;\n    | cons head tail =>\n      rw [List.length_cons] at hxsl; simp at hxsl;\n      unfold filter; split_ifs with h1;\n      case pos;\n        rw [List.length_cons];\n        exact Nat.pred_le_iff.mp (ih hxsl)\n      case neg;\n        exact Nat.le.step (ih hxsl)\n\n\nlemma qsort_term (x:Nat) (xs: List Nat) : List.length (filter xs fun y => decide (y \u2264 x)) < Nat.succ (List.length xs) := by\n  exact Nat.lt_succ_of_le (filter_len_le);\n\n\nlemma qsort_term2 (x:Nat) (xs: List Nat) : List.length (filter xs fun y => decide (y > x)) < Nat.succ (List.length xs) := by\n  exact Nat.lt_succ_of_le (filter_len_le);\n\n\ndef qsort : List Nat \u2192 List Nat\n| [] => []\n| x::xs =>\n  have _h:= qsort_term x xs\n  have _h2:= qsort_term2 x xs\n  (qsort (filter xs (fun y => y <= x))) ++ [x] ++ (qsort (filter xs (fun y => y > x)))\ntermination_by xs => xs.length\n", "proof_state": "xs : List \u2115\n\u22a2 (ordered (qsort xs) == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:570"}
{"full_name": "prop_QSortCount", "prop_defn": "theorem prop_QSortCount (x: Nat) (xs: List Nat) : count x (qsort xs) == count x xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:571", "score": 5, "deps": "import Mathlib\n\ndef count [DecidableEq \u03b1] : \u03b1 \u2192 List \u03b1 \u2192 Nat\n| _x, [] => 0\n| x, y::ys => if x == y then 1 + (count x ys) else count x ys\n\n\ndef filter : List Nat \u2192 (Nat \u2192 Bool) \u2192 List Nat\n| [], _f => []\n| x::xs, f => if f x then x::(filter xs f) else (filter xs f)\n\n\nlemma filter_len_le {f: Nat \u2192 Bool} {xs: List Nat}: (filter xs f).length <= xs.length := by\n  generalize hxsl: xs.length = xsl\n  induction xsl generalizing xs with\n  | zero => rw [List.length_eq_zero] at hxsl; rw [hxsl]; unfold filter; simp;\n  | succ n ih =>\n    cases xs with\n    | nil => unfold filter; simp;\n    | cons head tail =>\n      rw [List.length_cons] at hxsl; simp at hxsl;\n      unfold filter; split_ifs with h1;\n      case pos;\n        rw [List.length_cons];\n        exact Nat.pred_le_iff.mp (ih hxsl)\n      case neg;\n        exact Nat.le.step (ih hxsl)\n\n\nlemma qsort_term (x:Nat) (xs: List Nat) : List.length (filter xs fun y => decide (y \u2264 x)) < Nat.succ (List.length xs) := by\n  exact Nat.lt_succ_of_le (filter_len_le);\n\n\nlemma qsort_term2 (x:Nat) (xs: List Nat) : List.length (filter xs fun y => decide (y > x)) < Nat.succ (List.length xs) := by\n  exact Nat.lt_succ_of_le (filter_len_le);\n\n\ndef qsort : List Nat \u2192 List Nat\n| [] => []\n| x::xs =>\n  have _h:= qsort_term x xs\n  have _h2:= qsort_term2 x xs\n  (qsort (filter xs (fun y => y <= x))) ++ [x] ++ (qsort (filter xs (fun y => y > x)))\ntermination_by xs => xs.length\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (count x (qsort xs) == count x xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:571"}
{"full_name": "prop_QSortPermutes", "prop_defn": "theorem prop_QSortPermutes (xs: List Nat) : isPermutation (qsort xs) xs == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:572", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n\n\ndef filter : List Nat \u2192 (Nat \u2192 Bool) \u2192 List Nat\n| [], _f => []\n| x::xs, f => if f x then x::(filter xs f) else (filter xs f)\n\n\nlemma filter_len_le {f: Nat \u2192 Bool} {xs: List Nat}: (filter xs f).length <= xs.length := by\n  generalize hxsl: xs.length = xsl\n  induction xsl generalizing xs with\n  | zero => rw [List.length_eq_zero] at hxsl; rw [hxsl]; unfold filter; simp;\n  | succ n ih =>\n    cases xs with\n    | nil => unfold filter; simp;\n    | cons head tail =>\n      rw [List.length_cons] at hxsl; simp at hxsl;\n      unfold filter; split_ifs with h1;\n      case pos;\n        rw [List.length_cons];\n        exact Nat.pred_le_iff.mp (ih hxsl)\n      case neg;\n        exact Nat.le.step (ih hxsl)\n\n\nlemma qsort_term (x:Nat) (xs: List Nat) : List.length (filter xs fun y => decide (y \u2264 x)) < Nat.succ (List.length xs) := by\n  exact Nat.lt_succ_of_le (filter_len_le);\n\n\nlemma qsort_term2 (x:Nat) (xs: List Nat) : List.length (filter xs fun y => decide (y > x)) < Nat.succ (List.length xs) := by\n  exact Nat.lt_succ_of_le (filter_len_le);\n\n\ndef qsort : List Nat \u2192 List Nat\n| [] => []\n| x::xs =>\n  have _h:= qsort_term x xs\n  have _h2:= qsort_term2 x xs\n  (qsort (filter xs (fun y => y <= x))) ++ [x] ++ (qsort (filter xs (fun y => y > x)))\ntermination_by xs => xs.length\n", "proof_state": "xs : List \u2115\n\u22a2 (isPermutation (qsort xs) xs == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:572"}
{"full_name": "prop_QSortIsSort", "prop_defn": "theorem prop_QSortIsSort (xs: List Nat) : qsort xs == isort xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:573", "score": 5, "deps": "import Mathlib\n\ndef insert' : Nat \u2192 List Nat \u2192 List Nat\n| x, [] => [x]\n| x, y::xs => if x <= y then x::y::xs else y::(insert x xs)\n\n\ndef isort: List Nat \u2192 List Nat\n| [] => []\n| x::xs => insert' x (isort xs)\n\n\ndef filter : List Nat \u2192 (Nat \u2192 Bool) \u2192 List Nat\n| [], _f => []\n| x::xs, f => if f x then x::(filter xs f) else (filter xs f)\n\n\nlemma filter_len_le {f: Nat \u2192 Bool} {xs: List Nat}: (filter xs f).length <= xs.length := by\n  generalize hxsl: xs.length = xsl\n  induction xsl generalizing xs with\n  | zero => rw [List.length_eq_zero] at hxsl; rw [hxsl]; unfold filter; simp;\n  | succ n ih =>\n    cases xs with\n    | nil => unfold filter; simp;\n    | cons head tail =>\n      rw [List.length_cons] at hxsl; simp at hxsl;\n      unfold filter; split_ifs with h1;\n      case pos;\n        rw [List.length_cons];\n        exact Nat.pred_le_iff.mp (ih hxsl)\n      case neg;\n        exact Nat.le.step (ih hxsl)\n\n\nlemma qsort_term (x:Nat) (xs: List Nat) : List.length (filter xs fun y => decide (y \u2264 x)) < Nat.succ (List.length xs) := by\n  exact Nat.lt_succ_of_le (filter_len_le);\n\n\nlemma qsort_term2 (x:Nat) (xs: List Nat) : List.length (filter xs fun y => decide (y > x)) < Nat.succ (List.length xs) := by\n  exact Nat.lt_succ_of_le (filter_len_le);\n\n\ndef qsort : List Nat \u2192 List Nat\n| [] => []\n| x::xs =>\n  have _h:= qsort_term x xs\n  have _h2:= qsort_term2 x xs\n  (qsort (filter xs (fun y => y <= x))) ++ [x] ++ (qsort (filter xs (fun y => y > x)))\ntermination_by xs => xs.length\n", "proof_state": "xs : List \u2115\n\u22a2 (qsort xs == isort xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:573"}
{"full_name": "prop_SSortSorts", "prop_defn": "theorem prop_SSortSorts (xs: List Nat) : ordered (ssort xs) == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:624", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef ordered : List Nat -> Bool\n| []       => True\n| [_x]     => True\n| x::y::xs => x <= y && ordered (y::xs)\n\n\ndef minimum : Nat \u2192 List Nat \u2192 Nat\n| x, [] => x\n| x, y::ys => if y <= x then minimum y ys else minimum x ys\n\n\nlemma min_in_list : minimum x xs \u2208 (x::xs) := by\n  induction xs generalizing x with\n  | nil => unfold minimum; simp;\n  | cons head tail ih =>\n    unfold minimum; split_ifs with h1;\n    case pos;\n      rw [List.mem_cons]; right; exact ih;\n    case neg;\n      rw [List.mem_cons];\n      cases (List.mem_cons.1 (@ih x)) with\n      | inl h2 => left; exact h2;\n      | inr h2 => right; rw [List.mem_cons]; right; exact h2;\n\n\nlemma delete_len_eq {x: Nat} {xs: List Nat} (h: x \u2208 xs): (deleteFirst x xs).length + 1 = xs.length := by\n  generalize hxsl: xs.length = xsl\n  induction xsl generalizing xs with\n  | zero => rw [List.length_eq_zero] at hxsl; simp [hxsl] at h;\n  | succ n ih =>\n    cases xs with\n    | nil => simp at hxsl;\n    | cons head tail =>\n      unfold deleteFirst;\n      split_ifs with h1;\n      case pos;\n        simp at hxsl;\n        simp [hxsl];\n      case neg;\n        rw [List.mem_cons] at h;\n        simp at h1;\n        simp at hxsl;\n        simp;\n        exact ih ((or_iff_right h1).1 h) hxsl;\n\n\ndef ssort : List Nat \u2192 List Nat\n| [] => []\n| x::xs =>\n  let m := minimum x xs\n  have _h: List.length (deleteFirst (minimum x xs) (x :: xs)) < Nat.succ (List.length xs) := by\n    have tmp := delete_len_eq (@min_in_list x xs)\n    simp at tmp;\n    simp [tmp];\n  m :: ssort (deleteFirst m (x::xs))\ntermination_by xs => xs.length\n", "proof_state": "xs : List \u2115\n\u22a2 (ordered (ssort xs) == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:624"}
{"full_name": "prop_SSortCount", "prop_defn": "theorem prop_SSortCount (x: Nat) (xs: List Nat) : count x (ssort xs) == count x xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:625", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef count [DecidableEq \u03b1] : \u03b1 \u2192 List \u03b1 \u2192 Nat\n| _x, [] => 0\n| x, y::ys => if x == y then 1 + (count x ys) else count x ys\n\n\ndef minimum : Nat \u2192 List Nat \u2192 Nat\n| x, [] => x\n| x, y::ys => if y <= x then minimum y ys else minimum x ys\n\n\nlemma min_in_list : minimum x xs \u2208 (x::xs) := by\n  induction xs generalizing x with\n  | nil => unfold minimum; simp;\n  | cons head tail ih =>\n    unfold minimum; split_ifs with h1;\n    case pos;\n      rw [List.mem_cons]; right; exact ih;\n    case neg;\n      rw [List.mem_cons];\n      cases (List.mem_cons.1 (@ih x)) with\n      | inl h2 => left; exact h2;\n      | inr h2 => right; rw [List.mem_cons]; right; exact h2;\n\n\nlemma delete_len_eq {x: Nat} {xs: List Nat} (h: x \u2208 xs): (deleteFirst x xs).length + 1 = xs.length := by\n  generalize hxsl: xs.length = xsl\n  induction xsl generalizing xs with\n  | zero => rw [List.length_eq_zero] at hxsl; simp [hxsl] at h;\n  | succ n ih =>\n    cases xs with\n    | nil => simp at hxsl;\n    | cons head tail =>\n      unfold deleteFirst;\n      split_ifs with h1;\n      case pos;\n        simp at hxsl;\n        simp [hxsl];\n      case neg;\n        rw [List.mem_cons] at h;\n        simp at h1;\n        simp at hxsl;\n        simp;\n        exact ih ((or_iff_right h1).1 h) hxsl;\n\n\ndef ssort : List Nat \u2192 List Nat\n| [] => []\n| x::xs =>\n  let m := minimum x xs\n  have _h: List.length (deleteFirst (minimum x xs) (x :: xs)) < Nat.succ (List.length xs) := by\n    have tmp := delete_len_eq (@min_in_list x xs)\n    simp at tmp;\n    simp [tmp];\n  m :: ssort (deleteFirst m (x::xs))\ntermination_by xs => xs.length\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (count x (ssort xs) == count x xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:625"}
{"full_name": "prop_SSortPermutes", "prop_defn": "theorem prop_SSortPermutes (xs: List Nat) : isPermutation (ssort xs) xs == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:626", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n\n\ndef minimum : Nat \u2192 List Nat \u2192 Nat\n| x, [] => x\n| x, y::ys => if y <= x then minimum y ys else minimum x ys\n\n\nlemma min_in_list : minimum x xs \u2208 (x::xs) := by\n  induction xs generalizing x with\n  | nil => unfold minimum; simp;\n  | cons head tail ih =>\n    unfold minimum; split_ifs with h1;\n    case pos;\n      rw [List.mem_cons]; right; exact ih;\n    case neg;\n      rw [List.mem_cons];\n      cases (List.mem_cons.1 (@ih x)) with\n      | inl h2 => left; exact h2;\n      | inr h2 => right; rw [List.mem_cons]; right; exact h2;\n\n\nlemma delete_len_eq {x: Nat} {xs: List Nat} (h: x \u2208 xs): (deleteFirst x xs).length + 1 = xs.length := by\n  generalize hxsl: xs.length = xsl\n  induction xsl generalizing xs with\n  | zero => rw [List.length_eq_zero] at hxsl; simp [hxsl] at h;\n  | succ n ih =>\n    cases xs with\n    | nil => simp at hxsl;\n    | cons head tail =>\n      unfold deleteFirst;\n      split_ifs with h1;\n      case pos;\n        simp at hxsl;\n        simp [hxsl];\n      case neg;\n        rw [List.mem_cons] at h;\n        simp at h1;\n        simp at hxsl;\n        simp;\n        exact ih ((or_iff_right h1).1 h) hxsl;\n\n\ndef ssort : List Nat \u2192 List Nat\n| [] => []\n| x::xs =>\n  let m := minimum x xs\n  have _h: List.length (deleteFirst (minimum x xs) (x :: xs)) < Nat.succ (List.length xs) := by\n    have tmp := delete_len_eq (@min_in_list x xs)\n    simp at tmp;\n    simp [tmp];\n  m :: ssort (deleteFirst m (x::xs))\ntermination_by xs => xs.length\n", "proof_state": "xs : List \u2115\n\u22a2 (isPermutation (ssort xs) xs == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:626"}
{"full_name": "prop_SSortIsSort", "prop_defn": "theorem prop_SSortIsSort (xs: List Nat) : ssort xs == isort xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:627", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef insert' : Nat \u2192 List Nat \u2192 List Nat\n| x, [] => [x]\n| x, y::xs => if x <= y then x::y::xs else y::(insert x xs)\n\n\ndef isort: List Nat \u2192 List Nat\n| [] => []\n| x::xs => insert' x (isort xs)\n\n\ndef minimum : Nat \u2192 List Nat \u2192 Nat\n| x, [] => x\n| x, y::ys => if y <= x then minimum y ys else minimum x ys\n\n\nlemma min_in_list : minimum x xs \u2208 (x::xs) := by\n  induction xs generalizing x with\n  | nil => unfold minimum; simp;\n  | cons head tail ih =>\n    unfold minimum; split_ifs with h1;\n    case pos;\n      rw [List.mem_cons]; right; exact ih;\n    case neg;\n      rw [List.mem_cons];\n      cases (List.mem_cons.1 (@ih x)) with\n      | inl h2 => left; exact h2;\n      | inr h2 => right; rw [List.mem_cons]; right; exact h2;\n\n\nlemma delete_len_eq {x: Nat} {xs: List Nat} (h: x \u2208 xs): (deleteFirst x xs).length + 1 = xs.length := by\n  generalize hxsl: xs.length = xsl\n  induction xsl generalizing xs with\n  | zero => rw [List.length_eq_zero] at hxsl; simp [hxsl] at h;\n  | succ n ih =>\n    cases xs with\n    | nil => simp at hxsl;\n    | cons head tail =>\n      unfold deleteFirst;\n      split_ifs with h1;\n      case pos;\n        simp at hxsl;\n        simp [hxsl];\n      case neg;\n        rw [List.mem_cons] at h;\n        simp at h1;\n        simp at hxsl;\n        simp;\n        exact ih ((or_iff_right h1).1 h) hxsl;\n\n\ndef ssort : List Nat \u2192 List Nat\n| [] => []\n| x::xs =>\n  let m := minimum x xs\n  have _h: List.length (deleteFirst (minimum x xs) (x :: xs)) < Nat.succ (List.length xs) := by\n    have tmp := delete_len_eq (@min_in_list x xs)\n    simp at tmp;\n    simp [tmp];\n  m :: ssort (deleteFirst m (x::xs))\ntermination_by xs => xs.length\n", "proof_state": "xs : List \u2115\n\u22a2 (ssort xs == isort xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:627"}
{"full_name": "prop_TSortSorts", "prop_defn": "theorem prop_TSortSorts (xs: List Nat) : ordered (tsort xs) == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:649", "score": 5, "deps": "import Mathlib\n\ndef ordered : List Nat -> Bool\n| []       => True\n| [_x]     => True\n| x::y::xs => x <= y && ordered (y::xs)\n\n\ninductive MyTree where\n| nil : MyTree\n| node : MyTree \u2192 Nat \u2192 MyTree \u2192 MyTree\n\n\ndef add : Nat \u2192 MyTree \u2192 MyTree\n| x, .nil => .node .nil x .nil\n| x, .node p y q => if x <= y then .node (add x p) y q else .node p y (add x q)\n\n\ndef toTree : List Nat \u2192 MyTree\n| [] => .nil\n| x::xs => add x (toTree xs)\n\n\ndef flatten : MyTree \u2192 List Nat \u2192 List Nat\n| .nil, ys => ys\n| .node p x q, ys => flatten p (x :: flatten q ys)\n\n\ndef tsort : List Nat \u2192 List Nat\n| xs => flatten (toTree xs) []\n", "proof_state": "xs : List \u2115\n\u22a2 (ordered (tsort xs) == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:649"}
{"full_name": "prop_TSortCount", "prop_defn": "theorem prop_TSortCount (x: Nat) (xs: List Nat) : count x (tsort xs) == count x xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:650", "score": 5, "deps": "import Mathlib\n\ndef count [DecidableEq \u03b1] : \u03b1 \u2192 List \u03b1 \u2192 Nat\n| _x, [] => 0\n| x, y::ys => if x == y then 1 + (count x ys) else count x ys\n\n\ninductive MyTree where\n| nil : MyTree\n| node : MyTree \u2192 Nat \u2192 MyTree \u2192 MyTree\n\n\ndef add : Nat \u2192 MyTree \u2192 MyTree\n| x, .nil => .node .nil x .nil\n| x, .node p y q => if x <= y then .node (add x p) y q else .node p y (add x q)\n\n\ndef toTree : List Nat \u2192 MyTree\n| [] => .nil\n| x::xs => add x (toTree xs)\n\n\ndef flatten : MyTree \u2192 List Nat \u2192 List Nat\n| .nil, ys => ys\n| .node p x q, ys => flatten p (x :: flatten q ys)\n\n\ndef tsort : List Nat \u2192 List Nat\n| xs => flatten (toTree xs) []\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (count x (tsort xs) == count x xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:650"}
{"full_name": "prop_TSortPermutes", "prop_defn": "theorem prop_TSortPermutes (xs: List Nat) : isPermutation (tsort xs) xs == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:651", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n\n\ninductive MyTree where\n| nil : MyTree\n| node : MyTree \u2192 Nat \u2192 MyTree \u2192 MyTree\n\n\ndef add : Nat \u2192 MyTree \u2192 MyTree\n| x, .nil => .node .nil x .nil\n| x, .node p y q => if x <= y then .node (add x p) y q else .node p y (add x q)\n\n\ndef toTree : List Nat \u2192 MyTree\n| [] => .nil\n| x::xs => add x (toTree xs)\n\n\ndef flatten : MyTree \u2192 List Nat \u2192 List Nat\n| .nil, ys => ys\n| .node p x q, ys => flatten p (x :: flatten q ys)\n\n\ndef tsort : List Nat \u2192 List Nat\n| xs => flatten (toTree xs) []\n", "proof_state": "xs : List \u2115\n\u22a2 (isPermutation (tsort xs) xs == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:651"}
{"full_name": "prop_TSortIsSort", "prop_defn": "theorem prop_TSortIsSort (xs: List Nat) : tsort xs == isort xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:652", "score": 5, "deps": "import Mathlib\n\ndef insert' : Nat \u2192 List Nat \u2192 List Nat\n| x, [] => [x]\n| x, y::xs => if x <= y then x::y::xs else y::(insert x xs)\n\n\ndef isort: List Nat \u2192 List Nat\n| [] => []\n| x::xs => insert' x (isort xs)\n\n\ninductive MyTree where\n| nil : MyTree\n| node : MyTree \u2192 Nat \u2192 MyTree \u2192 MyTree\n\n\ndef add : Nat \u2192 MyTree \u2192 MyTree\n| x, .nil => .node .nil x .nil\n| x, .node p y q => if x <= y then .node (add x p) y q else .node p y (add x q)\n\n\ndef toTree : List Nat \u2192 MyTree\n| [] => .nil\n| x::xs => add x (toTree xs)\n\n\ndef flatten : MyTree \u2192 List Nat \u2192 List Nat\n| .nil, ys => ys\n| .node p x q, ys => flatten p (x :: flatten q ys)\n\n\ndef tsort : List Nat \u2192 List Nat\n| xs => flatten (toTree xs) []\n", "proof_state": "xs : List \u2115\n\u22a2 (tsort xs == isort xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:652"}
{"full_name": "prop_StoogeSortSorts", "prop_defn": "theorem prop_StoogeSortSorts (xs: List Nat) : ordered (stoogesort' xs) == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:766", "score": 5, "deps": "import Mathlib\n\ndef ordered : List Nat -> Bool\n| []       => True\n| [_x]     => True\n| x::y::xs => x <= y && ordered (y::xs)\n\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n\n\ndef reverse : List Nat \u2192 List Nat\n| [] => []\n| x::xs => (reverse xs) ++ [x]\n\n\nlemma len_rev_eq_len {l: List Nat} : (reverse l).length = l.length := by\n  induction l with\n  | nil => simp [reverse]\n  | cons head tail ih => unfold reverse; simp [ih];\n\n\nlemma splitAt_len_le : (splitAt n xs).2.length \u2264 xs.length := by\n  induction xs generalizing n with\n  | nil => unfold splitAt; simp;\n  | cons head tail ih =>\n    cases n with\n    | zero => unfold splitAt; simp;\n    | succ nm1 => unfold splitAt; simp; apply Nat.le.step; exact ih;\n\n\nlemma splitAt_second_len_lt (n: Nat): (splitAt n.succ (x::xs)).2.length < (x::xs).length := by\n  unfold splitAt;\n  simp;\n  calc List.length (splitAt n xs).2 \u2264 (List.length xs) := splitAt_len_le\n       _                          < Nat.succ (List.length xs) := Nat.lt_succ_self _\n\n\nlemma splitAt_second_len_lt' (n: Nat) (hlen: xs.length > 0): (splitAt n.succ xs).2.length < xs.length := by\n  cases xs with\n  | nil => simp at hlen;\n  | cons x xs => exact splitAt_second_len_lt _;\n\n\nlemma splitAt_second_len_lt'' (hn: n > 0) (hlen: xs.length > 0) (hlen': xl = xs.length): (splitAt n xs).2.length < xl := by\n  cases n with\n  | zero => simp at hn;\n  | succ nm1 => rw [hlen']; exact splitAt_second_len_lt' _ hlen;\n\n\nlemma splitAt_sum_preserves_len (n: Nat) (xs: List Nat) (hspl: spl = splitAt n xs):\n  (spl.1.length + spl.2.length = xs.length) := by\n  induction xs generalizing n spl with\n  | nil => simp [splitAt] at hspl; simp [hspl];\n  | cons head tail ih => cases n with\n    | zero => simp [splitAt] at hspl; simp [hspl];\n    | succ nm1 =>\n      simp [splitAt] at hspl;\n      simp [hspl]\n      rw [Nat.succ_add];\n      apply Order.succ_eq_succ_iff.2\n      exact ih nm1 (by rfl);\n\n\ndef stoogesort (xs : {xs : List Nat // xs.length = n}) : {ys: List Nat // ys.length = n} := match xs with\n| \u27e8[], h\u27e9 => \u27e8[], h\u27e9\n| \u27e8[x], h\u27e9 => \u27e8[x], h\u27e9\n| \u27e8[x, y], h\u27e9 => if x <= y then \u27e8[x, y], h\u27e9 else \u27e8[y, x], by simp [\u2190h]\u27e9\n| \u27e8x1::x2::x3::xs, hlen\u27e9 =>\n  let yzs1 := splitAt ((x1::x2::x3::xs).length/3) (reverse (x1::x2::x3::xs))\n  let \u27e8tmp2, hlen2\u27e9 := (@stoogesort yzs1.2.length \u27e8yzs1.2, by rfl\u27e9)\n  let s1s2a := tmp2 ++ (reverse yzs1.1)\n  let yzs2 := splitAt (s1s2a.length/3) s1s2a\n  let \u27e8tmp3, hlen3\u27e9 := (@stoogesort yzs2.2.length \u27e8yzs2.2, by rfl\u27e9)\n  let s1s1 := yzs2.1 ++ tmp3\n  let yzs3 := splitAt (s1s1.length/3) (reverse s1s1)\n  let \u27e8tmp4, hlen4\u27e9 := (@stoogesort yzs3.2.length \u27e8yzs3.2, by rfl\u27e9)\n  \u27e8tmp4 ++ (reverse yzs3.1), by\n    simp [hlen4, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs3), len_rev_eq_len];\n    unfold_let s1s1\n    simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n    unfold_let s1s2a\n    simp [hlen2, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs1), len_rev_eq_len, hlen]\n    \u27e9\ntermination_by match xs with | \u27e8lst, _h\u27e9 => lst.length\ndecreasing_by\n  simp_wf\n  apply splitAt_second_len_lt''\n    (by simp [Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, hlen])\n  simp_wf\n  suffices hyzs2 : (splitAt (List.length s1s2a / 3) s1s2a).2.length < n\n  rw [List.length_append] at hyzs2\n  exact hyzs2;\n  unfold_let s1s2a\n  suffices hyzs1 : List.length (tmp2 ++ reverse yzs1.1) = List.length xs + 3\n  exact splitAt_second_len_lt'' (by simp [hyzs1]) (by simp [hyzs1]) (by simp [hyzs1, \u2190hlen])\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n  simp_wf\n  suffices hyzs3 : (splitAt (List.length s1s1 / 3) (reverse s1s1)).2.length < n\n  unfold_let s1s1 yzs2 s1s2a yzs1 at hyzs3\n  simp [List.length_append] at hyzs3;\n  exact hyzs3;\n  suffices hs1s1: s1s1.length = xs.length + 3\n  exact splitAt_second_len_lt'' (by simp [hs1s1]) (by simp [len_rev_eq_len, hs1s1]) (by simp [len_rev_eq_len, hs1s1, \u2190hlen])\n  unfold_let s1s1\n  simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n  unfold_let s1s2a\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n\n\ndef stoogesort' (xs: List Nat) := stoogesort \u27e8xs, Eq.refl xs.length\u27e9\n", "proof_state": "xs : List \u2115\n\u22a2 (ordered \u2191(stoogesort' xs) == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:766"}
{"full_name": "prop_StoogeSortCount", "prop_defn": "theorem prop_StoogeSortCount (x: Nat) (xs: List Nat) : count x (stoogesort' xs) == count x xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:767", "score": 5, "deps": "import Mathlib\n\ndef count [DecidableEq \u03b1] : \u03b1 \u2192 List \u03b1 \u2192 Nat\n| _x, [] => 0\n| x, y::ys => if x == y then 1 + (count x ys) else count x ys\n\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n\n\ndef reverse : List Nat \u2192 List Nat\n| [] => []\n| x::xs => (reverse xs) ++ [x]\n\n\nlemma len_rev_eq_len {l: List Nat} : (reverse l).length = l.length := by\n  induction l with\n  | nil => simp [reverse]\n  | cons head tail ih => unfold reverse; simp [ih];\n\n\nlemma splitAt_len_le : (splitAt n xs).2.length \u2264 xs.length := by\n  induction xs generalizing n with\n  | nil => unfold splitAt; simp;\n  | cons head tail ih =>\n    cases n with\n    | zero => unfold splitAt; simp;\n    | succ nm1 => unfold splitAt; simp; apply Nat.le.step; exact ih;\n\n\nlemma splitAt_second_len_lt (n: Nat): (splitAt n.succ (x::xs)).2.length < (x::xs).length := by\n  unfold splitAt;\n  simp;\n  calc List.length (splitAt n xs).2 \u2264 (List.length xs) := splitAt_len_le\n       _                          < Nat.succ (List.length xs) := Nat.lt_succ_self _\n\n\nlemma splitAt_second_len_lt' (n: Nat) (hlen: xs.length > 0): (splitAt n.succ xs).2.length < xs.length := by\n  cases xs with\n  | nil => simp at hlen;\n  | cons x xs => exact splitAt_second_len_lt _;\n\n\nlemma splitAt_second_len_lt'' (hn: n > 0) (hlen: xs.length > 0) (hlen': xl = xs.length): (splitAt n xs).2.length < xl := by\n  cases n with\n  | zero => simp at hn;\n  | succ nm1 => rw [hlen']; exact splitAt_second_len_lt' _ hlen;\n\n\nlemma splitAt_sum_preserves_len (n: Nat) (xs: List Nat) (hspl: spl = splitAt n xs):\n  (spl.1.length + spl.2.length = xs.length) := by\n  induction xs generalizing n spl with\n  | nil => simp [splitAt] at hspl; simp [hspl];\n  | cons head tail ih => cases n with\n    | zero => simp [splitAt] at hspl; simp [hspl];\n    | succ nm1 =>\n      simp [splitAt] at hspl;\n      simp [hspl]\n      rw [Nat.succ_add];\n      apply Order.succ_eq_succ_iff.2\n      exact ih nm1 (by rfl);\n\n\ndef stoogesort (xs : {xs : List Nat // xs.length = n}) : {ys: List Nat // ys.length = n} := match xs with\n| \u27e8[], h\u27e9 => \u27e8[], h\u27e9\n| \u27e8[x], h\u27e9 => \u27e8[x], h\u27e9\n| \u27e8[x, y], h\u27e9 => if x <= y then \u27e8[x, y], h\u27e9 else \u27e8[y, x], by simp [\u2190h]\u27e9\n| \u27e8x1::x2::x3::xs, hlen\u27e9 =>\n  let yzs1 := splitAt ((x1::x2::x3::xs).length/3) (reverse (x1::x2::x3::xs))\n  let \u27e8tmp2, hlen2\u27e9 := (@stoogesort yzs1.2.length \u27e8yzs1.2, by rfl\u27e9)\n  let s1s2a := tmp2 ++ (reverse yzs1.1)\n  let yzs2 := splitAt (s1s2a.length/3) s1s2a\n  let \u27e8tmp3, hlen3\u27e9 := (@stoogesort yzs2.2.length \u27e8yzs2.2, by rfl\u27e9)\n  let s1s1 := yzs2.1 ++ tmp3\n  let yzs3 := splitAt (s1s1.length/3) (reverse s1s1)\n  let \u27e8tmp4, hlen4\u27e9 := (@stoogesort yzs3.2.length \u27e8yzs3.2, by rfl\u27e9)\n  \u27e8tmp4 ++ (reverse yzs3.1), by\n    simp [hlen4, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs3), len_rev_eq_len];\n    unfold_let s1s1\n    simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n    unfold_let s1s2a\n    simp [hlen2, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs1), len_rev_eq_len, hlen]\n    \u27e9\ntermination_by match xs with | \u27e8lst, _h\u27e9 => lst.length\ndecreasing_by\n  simp_wf\n  apply splitAt_second_len_lt''\n    (by simp [Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, hlen])\n  simp_wf\n  suffices hyzs2 : (splitAt (List.length s1s2a / 3) s1s2a).2.length < n\n  rw [List.length_append] at hyzs2\n  exact hyzs2;\n  unfold_let s1s2a\n  suffices hyzs1 : List.length (tmp2 ++ reverse yzs1.1) = List.length xs + 3\n  exact splitAt_second_len_lt'' (by simp [hyzs1]) (by simp [hyzs1]) (by simp [hyzs1, \u2190hlen])\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n  simp_wf\n  suffices hyzs3 : (splitAt (List.length s1s1 / 3) (reverse s1s1)).2.length < n\n  unfold_let s1s1 yzs2 s1s2a yzs1 at hyzs3\n  simp [List.length_append] at hyzs3;\n  exact hyzs3;\n  suffices hs1s1: s1s1.length = xs.length + 3\n  exact splitAt_second_len_lt'' (by simp [hs1s1]) (by simp [len_rev_eq_len, hs1s1]) (by simp [len_rev_eq_len, hs1s1, \u2190hlen])\n  unfold_let s1s1\n  simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n  unfold_let s1s2a\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n\n\ndef stoogesort' (xs: List Nat) := stoogesort \u27e8xs, Eq.refl xs.length\u27e9\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (count x \u2191(stoogesort' xs) == count x xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:767"}
{"full_name": "prop_StoogeSortPermutes", "prop_defn": "theorem prop_StoogeSortPermutes (xs: List Nat) : isPermutation (stoogesort' xs) xs == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:768", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n\n\ndef reverse : List Nat \u2192 List Nat\n| [] => []\n| x::xs => (reverse xs) ++ [x]\n\n\nlemma len_rev_eq_len {l: List Nat} : (reverse l).length = l.length := by\n  induction l with\n  | nil => simp [reverse]\n  | cons head tail ih => unfold reverse; simp [ih];\n\n\nlemma splitAt_len_le : (splitAt n xs).2.length \u2264 xs.length := by\n  induction xs generalizing n with\n  | nil => unfold splitAt; simp;\n  | cons head tail ih =>\n    cases n with\n    | zero => unfold splitAt; simp;\n    | succ nm1 => unfold splitAt; simp; apply Nat.le.step; exact ih;\n\n\nlemma splitAt_second_len_lt (n: Nat): (splitAt n.succ (x::xs)).2.length < (x::xs).length := by\n  unfold splitAt;\n  simp;\n  calc List.length (splitAt n xs).2 \u2264 (List.length xs) := splitAt_len_le\n       _                          < Nat.succ (List.length xs) := Nat.lt_succ_self _\n\n\nlemma splitAt_second_len_lt' (n: Nat) (hlen: xs.length > 0): (splitAt n.succ xs).2.length < xs.length := by\n  cases xs with\n  | nil => simp at hlen;\n  | cons x xs => exact splitAt_second_len_lt _;\n\n\nlemma splitAt_second_len_lt'' (hn: n > 0) (hlen: xs.length > 0) (hlen': xl = xs.length): (splitAt n xs).2.length < xl := by\n  cases n with\n  | zero => simp at hn;\n  | succ nm1 => rw [hlen']; exact splitAt_second_len_lt' _ hlen;\n\n\nlemma splitAt_sum_preserves_len (n: Nat) (xs: List Nat) (hspl: spl = splitAt n xs):\n  (spl.1.length + spl.2.length = xs.length) := by\n  induction xs generalizing n spl with\n  | nil => simp [splitAt] at hspl; simp [hspl];\n  | cons head tail ih => cases n with\n    | zero => simp [splitAt] at hspl; simp [hspl];\n    | succ nm1 =>\n      simp [splitAt] at hspl;\n      simp [hspl]\n      rw [Nat.succ_add];\n      apply Order.succ_eq_succ_iff.2\n      exact ih nm1 (by rfl);\n\n\ndef stoogesort (xs : {xs : List Nat // xs.length = n}) : {ys: List Nat // ys.length = n} := match xs with\n| \u27e8[], h\u27e9 => \u27e8[], h\u27e9\n| \u27e8[x], h\u27e9 => \u27e8[x], h\u27e9\n| \u27e8[x, y], h\u27e9 => if x <= y then \u27e8[x, y], h\u27e9 else \u27e8[y, x], by simp [\u2190h]\u27e9\n| \u27e8x1::x2::x3::xs, hlen\u27e9 =>\n  let yzs1 := splitAt ((x1::x2::x3::xs).length/3) (reverse (x1::x2::x3::xs))\n  let \u27e8tmp2, hlen2\u27e9 := (@stoogesort yzs1.2.length \u27e8yzs1.2, by rfl\u27e9)\n  let s1s2a := tmp2 ++ (reverse yzs1.1)\n  let yzs2 := splitAt (s1s2a.length/3) s1s2a\n  let \u27e8tmp3, hlen3\u27e9 := (@stoogesort yzs2.2.length \u27e8yzs2.2, by rfl\u27e9)\n  let s1s1 := yzs2.1 ++ tmp3\n  let yzs3 := splitAt (s1s1.length/3) (reverse s1s1)\n  let \u27e8tmp4, hlen4\u27e9 := (@stoogesort yzs3.2.length \u27e8yzs3.2, by rfl\u27e9)\n  \u27e8tmp4 ++ (reverse yzs3.1), by\n    simp [hlen4, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs3), len_rev_eq_len];\n    unfold_let s1s1\n    simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n    unfold_let s1s2a\n    simp [hlen2, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs1), len_rev_eq_len, hlen]\n    \u27e9\ntermination_by match xs with | \u27e8lst, _h\u27e9 => lst.length\ndecreasing_by\n  simp_wf\n  apply splitAt_second_len_lt''\n    (by simp [Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, hlen])\n  simp_wf\n  suffices hyzs2 : (splitAt (List.length s1s2a / 3) s1s2a).2.length < n\n  rw [List.length_append] at hyzs2\n  exact hyzs2;\n  unfold_let s1s2a\n  suffices hyzs1 : List.length (tmp2 ++ reverse yzs1.1) = List.length xs + 3\n  exact splitAt_second_len_lt'' (by simp [hyzs1]) (by simp [hyzs1]) (by simp [hyzs1, \u2190hlen])\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n  simp_wf\n  suffices hyzs3 : (splitAt (List.length s1s1 / 3) (reverse s1s1)).2.length < n\n  unfold_let s1s1 yzs2 s1s2a yzs1 at hyzs3\n  simp [List.length_append] at hyzs3;\n  exact hyzs3;\n  suffices hs1s1: s1s1.length = xs.length + 3\n  exact splitAt_second_len_lt'' (by simp [hs1s1]) (by simp [len_rev_eq_len, hs1s1]) (by simp [len_rev_eq_len, hs1s1, \u2190hlen])\n  unfold_let s1s1\n  simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n  unfold_let s1s2a\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n\n\ndef stoogesort' (xs: List Nat) := stoogesort \u27e8xs, Eq.refl xs.length\u27e9\n", "proof_state": "xs : List \u2115\n\u22a2 (isPermutation (\u2191(stoogesort' xs)) xs == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:768"}
{"full_name": "prop_StoogeSortIsSort", "prop_defn": "theorem prop_StoogeSortIsSort (xs: List Nat) : stoogesort' xs == isort xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:769", "score": 5, "deps": "import Mathlib\n\ndef insert' : Nat \u2192 List Nat \u2192 List Nat\n| x, [] => [x]\n| x, y::xs => if x <= y then x::y::xs else y::(insert x xs)\n\n\ndef isort: List Nat \u2192 List Nat\n| [] => []\n| x::xs => insert' x (isort xs)\n\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n\n\ndef reverse : List Nat \u2192 List Nat\n| [] => []\n| x::xs => (reverse xs) ++ [x]\n\n\nlemma len_rev_eq_len {l: List Nat} : (reverse l).length = l.length := by\n  induction l with\n  | nil => simp [reverse]\n  | cons head tail ih => unfold reverse; simp [ih];\n\n\nlemma splitAt_len_le : (splitAt n xs).2.length \u2264 xs.length := by\n  induction xs generalizing n with\n  | nil => unfold splitAt; simp;\n  | cons head tail ih =>\n    cases n with\n    | zero => unfold splitAt; simp;\n    | succ nm1 => unfold splitAt; simp; apply Nat.le.step; exact ih;\n\n\nlemma splitAt_second_len_lt (n: Nat): (splitAt n.succ (x::xs)).2.length < (x::xs).length := by\n  unfold splitAt;\n  simp;\n  calc List.length (splitAt n xs).2 \u2264 (List.length xs) := splitAt_len_le\n       _                          < Nat.succ (List.length xs) := Nat.lt_succ_self _\n\n\nlemma splitAt_second_len_lt' (n: Nat) (hlen: xs.length > 0): (splitAt n.succ xs).2.length < xs.length := by\n  cases xs with\n  | nil => simp at hlen;\n  | cons x xs => exact splitAt_second_len_lt _;\n\n\nlemma splitAt_second_len_lt'' (hn: n > 0) (hlen: xs.length > 0) (hlen': xl = xs.length): (splitAt n xs).2.length < xl := by\n  cases n with\n  | zero => simp at hn;\n  | succ nm1 => rw [hlen']; exact splitAt_second_len_lt' _ hlen;\n\n\nlemma splitAt_sum_preserves_len (n: Nat) (xs: List Nat) (hspl: spl = splitAt n xs):\n  (spl.1.length + spl.2.length = xs.length) := by\n  induction xs generalizing n spl with\n  | nil => simp [splitAt] at hspl; simp [hspl];\n  | cons head tail ih => cases n with\n    | zero => simp [splitAt] at hspl; simp [hspl];\n    | succ nm1 =>\n      simp [splitAt] at hspl;\n      simp [hspl]\n      rw [Nat.succ_add];\n      apply Order.succ_eq_succ_iff.2\n      exact ih nm1 (by rfl);\n\n\ndef stoogesort (xs : {xs : List Nat // xs.length = n}) : {ys: List Nat // ys.length = n} := match xs with\n| \u27e8[], h\u27e9 => \u27e8[], h\u27e9\n| \u27e8[x], h\u27e9 => \u27e8[x], h\u27e9\n| \u27e8[x, y], h\u27e9 => if x <= y then \u27e8[x, y], h\u27e9 else \u27e8[y, x], by simp [\u2190h]\u27e9\n| \u27e8x1::x2::x3::xs, hlen\u27e9 =>\n  let yzs1 := splitAt ((x1::x2::x3::xs).length/3) (reverse (x1::x2::x3::xs))\n  let \u27e8tmp2, hlen2\u27e9 := (@stoogesort yzs1.2.length \u27e8yzs1.2, by rfl\u27e9)\n  let s1s2a := tmp2 ++ (reverse yzs1.1)\n  let yzs2 := splitAt (s1s2a.length/3) s1s2a\n  let \u27e8tmp3, hlen3\u27e9 := (@stoogesort yzs2.2.length \u27e8yzs2.2, by rfl\u27e9)\n  let s1s1 := yzs2.1 ++ tmp3\n  let yzs3 := splitAt (s1s1.length/3) (reverse s1s1)\n  let \u27e8tmp4, hlen4\u27e9 := (@stoogesort yzs3.2.length \u27e8yzs3.2, by rfl\u27e9)\n  \u27e8tmp4 ++ (reverse yzs3.1), by\n    simp [hlen4, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs3), len_rev_eq_len];\n    unfold_let s1s1\n    simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n    unfold_let s1s2a\n    simp [hlen2, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs1), len_rev_eq_len, hlen]\n    \u27e9\ntermination_by match xs with | \u27e8lst, _h\u27e9 => lst.length\ndecreasing_by\n  simp_wf\n  apply splitAt_second_len_lt''\n    (by simp [Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, hlen])\n  simp_wf\n  suffices hyzs2 : (splitAt (List.length s1s2a / 3) s1s2a).2.length < n\n  rw [List.length_append] at hyzs2\n  exact hyzs2;\n  unfold_let s1s2a\n  suffices hyzs1 : List.length (tmp2 ++ reverse yzs1.1) = List.length xs + 3\n  exact splitAt_second_len_lt'' (by simp [hyzs1]) (by simp [hyzs1]) (by simp [hyzs1, \u2190hlen])\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n  simp_wf\n  suffices hyzs3 : (splitAt (List.length s1s1 / 3) (reverse s1s1)).2.length < n\n  unfold_let s1s1 yzs2 s1s2a yzs1 at hyzs3\n  simp [List.length_append] at hyzs3;\n  exact hyzs3;\n  suffices hs1s1: s1s1.length = xs.length + 3\n  exact splitAt_second_len_lt'' (by simp [hs1s1]) (by simp [len_rev_eq_len, hs1s1]) (by simp [len_rev_eq_len, hs1s1, \u2190hlen])\n  unfold_let s1s1\n  simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n  unfold_let s1s2a\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n\n\ndef stoogesort' (xs: List Nat) := stoogesort \u27e8xs, Eq.refl xs.length\u27e9\n", "proof_state": "xs : List \u2115\n\u22a2 (\u2191(stoogesort' xs) == isort xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:769"}
{"full_name": "prop_StoogeSort2Sorts", "prop_defn": "theorem prop_StoogeSort2Sorts (xs: List Nat) : ordered (stoogesort2' xs) == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:850", "score": 5, "deps": "import Mathlib\n\ndef ordered : List Nat -> Bool\n| []       => True\n| [_x]     => True\n| x::y::xs => x <= y && ordered (y::xs)\n\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n\n\ndef reverse : List Nat \u2192 List Nat\n| [] => []\n| x::xs => (reverse xs) ++ [x]\n\n\nlemma len_rev_eq_len {l: List Nat} : (reverse l).length = l.length := by\n  induction l with\n  | nil => simp [reverse]\n  | cons head tail ih => unfold reverse; simp [ih];\n\n\nlemma splitAt_len_le : (splitAt n xs).2.length \u2264 xs.length := by\n  induction xs generalizing n with\n  | nil => unfold splitAt; simp;\n  | cons head tail ih =>\n    cases n with\n    | zero => unfold splitAt; simp;\n    | succ nm1 => unfold splitAt; simp; apply Nat.le.step; exact ih;\n\n\nlemma splitAt_second_len_lt (n: Nat): (splitAt n.succ (x::xs)).2.length < (x::xs).length := by\n  unfold splitAt;\n  simp;\n  calc List.length (splitAt n xs).2 \u2264 (List.length xs) := splitAt_len_le\n       _                          < Nat.succ (List.length xs) := Nat.lt_succ_self _\n\n\nlemma splitAt_second_len_lt' (n: Nat) (hlen: xs.length > 0): (splitAt n.succ xs).2.length < xs.length := by\n  cases xs with\n  | nil => simp at hlen;\n  | cons x xs => exact splitAt_second_len_lt _;\n\n\nlemma splitAt_second_len_lt'' (hn: n > 0) (hlen: xs.length > 0) (hlen': xl = xs.length): (splitAt n xs).2.length < xl := by\n  cases n with\n  | zero => simp at hn;\n  | succ nm1 => rw [hlen']; exact splitAt_second_len_lt' _ hlen;\n\n\nlemma splitAt_sum_preserves_len (n: Nat) (xs: List Nat) (hspl: spl = splitAt n xs):\n  (spl.1.length + spl.2.length = xs.length) := by\n  induction xs generalizing n spl with\n  | nil => simp [splitAt] at hspl; simp [hspl];\n  | cons head tail ih => cases n with\n    | zero => simp [splitAt] at hspl; simp [hspl];\n    | succ nm1 =>\n      simp [splitAt] at hspl;\n      simp [hspl]\n      rw [Nat.succ_add];\n      apply Order.succ_eq_succ_iff.2\n      exact ih nm1 (by rfl);\n\n\nlemma splitAt_first_len_lt (hn: n < xl) (hlen': xl = xs.length): (splitAt n xs).1.length < xl := by\n  suffices heq : (splitAt n xs).1.length = n\n  simp [heq, hn]\n  induction xs generalizing n xl with\n  | nil => simp [hlen'] at hn;\n  | cons head tail ih =>\n    cases n with\n    | zero => simp [splitAt];\n    | succ nm1 =>\n      simp [splitAt];\n      exact @ih nm1 tail.length (by simp [hlen'] at hn; exact hn) rfl\n\n\nlemma twon_lt (n: Nat): (2*n.succ.succ.succ + 1)/ 3 < n.succ.succ.succ := by\n  simp [Nat.succ_eq_add_one];\n  ring_nf;\n  rw [Nat.div_lt_iff_lt_mul (by simp)];\n  ring_nf;\n  linarith;\n\n\ndef stoogesort2 (xs : {xs : List Nat // xs.length = n}) : {ys: List Nat // ys.length = n} := match xs with\n| \u27e8[], h\u27e9 => \u27e8[], h\u27e9\n| \u27e8[x], h\u27e9 => \u27e8[x], h\u27e9\n| \u27e8[x, y], h\u27e9 => if x <= y then \u27e8[x, y], h\u27e9 else \u27e8[y, x], by simp [\u2190h]\u27e9\n| \u27e8x1::x2::x3::xs, hlen\u27e9 =>\n  let yzs1 := splitAt ((2*(x1::x2::x3::xs).length + 1) / 3) (x1::x2::x3::xs)\n  let \u27e8tmp2, hlen2\u27e9 := @stoogesort2 yzs1.1.length \u27e8yzs1.1, by rfl\u27e9\n  let s2s2a := tmp2 ++ yzs1.2\n  let yzs2 := splitAt (s2s2a.length / 3) s2s2a\n  let \u27e8tmp3, hlen3\u27e9 := @stoogesort2 yzs2.2.length \u27e8yzs2.2, by rfl\u27e9\n  let s2s1 := yzs2.1 ++ tmp3\n  let yzs3 := splitAt ((2*s2s1.length + 1) / 3) s2s1\n  let \u27e8tmp4, hlen4\u27e9 := @stoogesort2 yzs3.1.length \u27e8yzs3.1, by rfl\u27e9\n  \u27e8tmp4 ++ yzs3.2, by\n    simp [hlen4];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs3), len_rev_eq_len];\n    unfold_let s2s1\n    simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n    unfold_let s2s2a\n    simp [hlen2];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs1), hlen]\n    \u27e9\ntermination_by match xs with | \u27e8lst, _h\u27e9 => lst.length\ndecreasing_by\n  simp_wf;\n  simp at hlen;\n  rw [\u2190 hlen]\n  apply splitAt_first_len_lt (twon_lt _) (by simp)\n  simp_wf;\n  suffices hyzs2 : yzs2.2.length < n\n  unfold_let yzs2 at hyzs2\n  rw [List.length_append] at hyzs2\n  exact hyzs2;\n  unfold_let yzs2\n  suffices hs2s2a : s2s2a.length = n\n  rw [hs2s2a, \u2190 hlen]\n  apply splitAt_second_len_lt'' (by simp [Nat.succ_eq_add_one, Nat.add_assoc]) (by simp [hs2s2a, \u2190hlen]) (by simp [hs2s2a, \u2190hlen])\n  unfold_let s2s2a\n  simp [hlen2, splitAt_sum_preserves_len _ _ (Eq.refl yzs1), hlen]\n  simp_wf;\n  suffices hdone: yzs3.1.length < n\n  unfold_let yzs3 s2s1 yzs2 s2s2a yzs1 at hdone\n  simp [List.length_append] at hdone;\n  exact hdone;\n  unfold_let yzs3\n  suffices hs2s1: s2s1.length = xs.length.succ.succ.succ\n  refine splitAt_first_len_lt (by simp [hs2s1, \u2190 hlen]; exact twon_lt _) (by simp [hs2s1, \u2190 hlen])\n  unfold_let s2s1\n  simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n  unfold_let s2s2a\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n\n\ndef stoogesort2' (xs: List Nat) := stoogesort2 \u27e8xs, by rfl\u27e9\n", "proof_state": "xs : List \u2115\n\u22a2 (ordered \u2191(stoogesort2' xs) == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:850"}
{"full_name": "prop_StoogeSort2Count", "prop_defn": "theorem prop_StoogeSort2Count (x: Nat) (xs: List Nat) : count x (stoogesort2' xs) == count x xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:851", "score": 5, "deps": "import Mathlib\n\ndef count [DecidableEq \u03b1] : \u03b1 \u2192 List \u03b1 \u2192 Nat\n| _x, [] => 0\n| x, y::ys => if x == y then 1 + (count x ys) else count x ys\n\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n\n\ndef reverse : List Nat \u2192 List Nat\n| [] => []\n| x::xs => (reverse xs) ++ [x]\n\n\nlemma len_rev_eq_len {l: List Nat} : (reverse l).length = l.length := by\n  induction l with\n  | nil => simp [reverse]\n  | cons head tail ih => unfold reverse; simp [ih];\n\n\nlemma splitAt_len_le : (splitAt n xs).2.length \u2264 xs.length := by\n  induction xs generalizing n with\n  | nil => unfold splitAt; simp;\n  | cons head tail ih =>\n    cases n with\n    | zero => unfold splitAt; simp;\n    | succ nm1 => unfold splitAt; simp; apply Nat.le.step; exact ih;\n\n\nlemma splitAt_second_len_lt (n: Nat): (splitAt n.succ (x::xs)).2.length < (x::xs).length := by\n  unfold splitAt;\n  simp;\n  calc List.length (splitAt n xs).2 \u2264 (List.length xs) := splitAt_len_le\n       _                          < Nat.succ (List.length xs) := Nat.lt_succ_self _\n\n\nlemma splitAt_second_len_lt' (n: Nat) (hlen: xs.length > 0): (splitAt n.succ xs).2.length < xs.length := by\n  cases xs with\n  | nil => simp at hlen;\n  | cons x xs => exact splitAt_second_len_lt _;\n\n\nlemma splitAt_second_len_lt'' (hn: n > 0) (hlen: xs.length > 0) (hlen': xl = xs.length): (splitAt n xs).2.length < xl := by\n  cases n with\n  | zero => simp at hn;\n  | succ nm1 => rw [hlen']; exact splitAt_second_len_lt' _ hlen;\n\n\nlemma splitAt_sum_preserves_len (n: Nat) (xs: List Nat) (hspl: spl = splitAt n xs):\n  (spl.1.length + spl.2.length = xs.length) := by\n  induction xs generalizing n spl with\n  | nil => simp [splitAt] at hspl; simp [hspl];\n  | cons head tail ih => cases n with\n    | zero => simp [splitAt] at hspl; simp [hspl];\n    | succ nm1 =>\n      simp [splitAt] at hspl;\n      simp [hspl]\n      rw [Nat.succ_add];\n      apply Order.succ_eq_succ_iff.2\n      exact ih nm1 (by rfl);\n\n\nlemma splitAt_first_len_lt (hn: n < xl) (hlen': xl = xs.length): (splitAt n xs).1.length < xl := by\n  suffices heq : (splitAt n xs).1.length = n\n  simp [heq, hn]\n  induction xs generalizing n xl with\n  | nil => simp [hlen'] at hn;\n  | cons head tail ih =>\n    cases n with\n    | zero => simp [splitAt];\n    | succ nm1 =>\n      simp [splitAt];\n      exact @ih nm1 tail.length (by simp [hlen'] at hn; exact hn) rfl\n\n\nlemma twon_lt (n: Nat): (2*n.succ.succ.succ + 1)/ 3 < n.succ.succ.succ := by\n  simp [Nat.succ_eq_add_one];\n  ring_nf;\n  rw [Nat.div_lt_iff_lt_mul (by simp)];\n  ring_nf;\n  linarith;\n\n\ndef stoogesort2 (xs : {xs : List Nat // xs.length = n}) : {ys: List Nat // ys.length = n} := match xs with\n| \u27e8[], h\u27e9 => \u27e8[], h\u27e9\n| \u27e8[x], h\u27e9 => \u27e8[x], h\u27e9\n| \u27e8[x, y], h\u27e9 => if x <= y then \u27e8[x, y], h\u27e9 else \u27e8[y, x], by simp [\u2190h]\u27e9\n| \u27e8x1::x2::x3::xs, hlen\u27e9 =>\n  let yzs1 := splitAt ((2*(x1::x2::x3::xs).length + 1) / 3) (x1::x2::x3::xs)\n  let \u27e8tmp2, hlen2\u27e9 := @stoogesort2 yzs1.1.length \u27e8yzs1.1, by rfl\u27e9\n  let s2s2a := tmp2 ++ yzs1.2\n  let yzs2 := splitAt (s2s2a.length / 3) s2s2a\n  let \u27e8tmp3, hlen3\u27e9 := @stoogesort2 yzs2.2.length \u27e8yzs2.2, by rfl\u27e9\n  let s2s1 := yzs2.1 ++ tmp3\n  let yzs3 := splitAt ((2*s2s1.length + 1) / 3) s2s1\n  let \u27e8tmp4, hlen4\u27e9 := @stoogesort2 yzs3.1.length \u27e8yzs3.1, by rfl\u27e9\n  \u27e8tmp4 ++ yzs3.2, by\n    simp [hlen4];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs3), len_rev_eq_len];\n    unfold_let s2s1\n    simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n    unfold_let s2s2a\n    simp [hlen2];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs1), hlen]\n    \u27e9\ntermination_by match xs with | \u27e8lst, _h\u27e9 => lst.length\ndecreasing_by\n  simp_wf;\n  simp at hlen;\n  rw [\u2190 hlen]\n  apply splitAt_first_len_lt (twon_lt _) (by simp)\n  simp_wf;\n  suffices hyzs2 : yzs2.2.length < n\n  unfold_let yzs2 at hyzs2\n  rw [List.length_append] at hyzs2\n  exact hyzs2;\n  unfold_let yzs2\n  suffices hs2s2a : s2s2a.length = n\n  rw [hs2s2a, \u2190 hlen]\n  apply splitAt_second_len_lt'' (by simp [Nat.succ_eq_add_one, Nat.add_assoc]) (by simp [hs2s2a, \u2190hlen]) (by simp [hs2s2a, \u2190hlen])\n  unfold_let s2s2a\n  simp [hlen2, splitAt_sum_preserves_len _ _ (Eq.refl yzs1), hlen]\n  simp_wf;\n  suffices hdone: yzs3.1.length < n\n  unfold_let yzs3 s2s1 yzs2 s2s2a yzs1 at hdone\n  simp [List.length_append] at hdone;\n  exact hdone;\n  unfold_let yzs3\n  suffices hs2s1: s2s1.length = xs.length.succ.succ.succ\n  refine splitAt_first_len_lt (by simp [hs2s1, \u2190 hlen]; exact twon_lt _) (by simp [hs2s1, \u2190 hlen])\n  unfold_let s2s1\n  simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n  unfold_let s2s2a\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n\n\ndef stoogesort2' (xs: List Nat) := stoogesort2 \u27e8xs, by rfl\u27e9\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (count x \u2191(stoogesort2' xs) == count x xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:851"}
{"full_name": "prop_StoogeSort2Permutes", "prop_defn": "theorem prop_StoogeSort2Permutes (xs: List Nat) : isPermutation (stoogesort2' xs) xs == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:852", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n\n\ndef reverse : List Nat \u2192 List Nat\n| [] => []\n| x::xs => (reverse xs) ++ [x]\n\n\nlemma len_rev_eq_len {l: List Nat} : (reverse l).length = l.length := by\n  induction l with\n  | nil => simp [reverse]\n  | cons head tail ih => unfold reverse; simp [ih];\n\n\nlemma splitAt_len_le : (splitAt n xs).2.length \u2264 xs.length := by\n  induction xs generalizing n with\n  | nil => unfold splitAt; simp;\n  | cons head tail ih =>\n    cases n with\n    | zero => unfold splitAt; simp;\n    | succ nm1 => unfold splitAt; simp; apply Nat.le.step; exact ih;\n\n\nlemma splitAt_second_len_lt (n: Nat): (splitAt n.succ (x::xs)).2.length < (x::xs).length := by\n  unfold splitAt;\n  simp;\n  calc List.length (splitAt n xs).2 \u2264 (List.length xs) := splitAt_len_le\n       _                          < Nat.succ (List.length xs) := Nat.lt_succ_self _\n\n\nlemma splitAt_second_len_lt' (n: Nat) (hlen: xs.length > 0): (splitAt n.succ xs).2.length < xs.length := by\n  cases xs with\n  | nil => simp at hlen;\n  | cons x xs => exact splitAt_second_len_lt _;\n\n\nlemma splitAt_second_len_lt'' (hn: n > 0) (hlen: xs.length > 0) (hlen': xl = xs.length): (splitAt n xs).2.length < xl := by\n  cases n with\n  | zero => simp at hn;\n  | succ nm1 => rw [hlen']; exact splitAt_second_len_lt' _ hlen;\n\n\nlemma splitAt_sum_preserves_len (n: Nat) (xs: List Nat) (hspl: spl = splitAt n xs):\n  (spl.1.length + spl.2.length = xs.length) := by\n  induction xs generalizing n spl with\n  | nil => simp [splitAt] at hspl; simp [hspl];\n  | cons head tail ih => cases n with\n    | zero => simp [splitAt] at hspl; simp [hspl];\n    | succ nm1 =>\n      simp [splitAt] at hspl;\n      simp [hspl]\n      rw [Nat.succ_add];\n      apply Order.succ_eq_succ_iff.2\n      exact ih nm1 (by rfl);\n\n\nlemma splitAt_first_len_lt (hn: n < xl) (hlen': xl = xs.length): (splitAt n xs).1.length < xl := by\n  suffices heq : (splitAt n xs).1.length = n\n  simp [heq, hn]\n  induction xs generalizing n xl with\n  | nil => simp [hlen'] at hn;\n  | cons head tail ih =>\n    cases n with\n    | zero => simp [splitAt];\n    | succ nm1 =>\n      simp [splitAt];\n      exact @ih nm1 tail.length (by simp [hlen'] at hn; exact hn) rfl\n\n\nlemma twon_lt (n: Nat): (2*n.succ.succ.succ + 1)/ 3 < n.succ.succ.succ := by\n  simp [Nat.succ_eq_add_one];\n  ring_nf;\n  rw [Nat.div_lt_iff_lt_mul (by simp)];\n  ring_nf;\n  linarith;\n\n\ndef stoogesort2 (xs : {xs : List Nat // xs.length = n}) : {ys: List Nat // ys.length = n} := match xs with\n| \u27e8[], h\u27e9 => \u27e8[], h\u27e9\n| \u27e8[x], h\u27e9 => \u27e8[x], h\u27e9\n| \u27e8[x, y], h\u27e9 => if x <= y then \u27e8[x, y], h\u27e9 else \u27e8[y, x], by simp [\u2190h]\u27e9\n| \u27e8x1::x2::x3::xs, hlen\u27e9 =>\n  let yzs1 := splitAt ((2*(x1::x2::x3::xs).length + 1) / 3) (x1::x2::x3::xs)\n  let \u27e8tmp2, hlen2\u27e9 := @stoogesort2 yzs1.1.length \u27e8yzs1.1, by rfl\u27e9\n  let s2s2a := tmp2 ++ yzs1.2\n  let yzs2 := splitAt (s2s2a.length / 3) s2s2a\n  let \u27e8tmp3, hlen3\u27e9 := @stoogesort2 yzs2.2.length \u27e8yzs2.2, by rfl\u27e9\n  let s2s1 := yzs2.1 ++ tmp3\n  let yzs3 := splitAt ((2*s2s1.length + 1) / 3) s2s1\n  let \u27e8tmp4, hlen4\u27e9 := @stoogesort2 yzs3.1.length \u27e8yzs3.1, by rfl\u27e9\n  \u27e8tmp4 ++ yzs3.2, by\n    simp [hlen4];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs3), len_rev_eq_len];\n    unfold_let s2s1\n    simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n    unfold_let s2s2a\n    simp [hlen2];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs1), hlen]\n    \u27e9\ntermination_by match xs with | \u27e8lst, _h\u27e9 => lst.length\ndecreasing_by\n  simp_wf;\n  simp at hlen;\n  rw [\u2190 hlen]\n  apply splitAt_first_len_lt (twon_lt _) (by simp)\n  simp_wf;\n  suffices hyzs2 : yzs2.2.length < n\n  unfold_let yzs2 at hyzs2\n  rw [List.length_append] at hyzs2\n  exact hyzs2;\n  unfold_let yzs2\n  suffices hs2s2a : s2s2a.length = n\n  rw [hs2s2a, \u2190 hlen]\n  apply splitAt_second_len_lt'' (by simp [Nat.succ_eq_add_one, Nat.add_assoc]) (by simp [hs2s2a, \u2190hlen]) (by simp [hs2s2a, \u2190hlen])\n  unfold_let s2s2a\n  simp [hlen2, splitAt_sum_preserves_len _ _ (Eq.refl yzs1), hlen]\n  simp_wf;\n  suffices hdone: yzs3.1.length < n\n  unfold_let yzs3 s2s1 yzs2 s2s2a yzs1 at hdone\n  simp [List.length_append] at hdone;\n  exact hdone;\n  unfold_let yzs3\n  suffices hs2s1: s2s1.length = xs.length.succ.succ.succ\n  refine splitAt_first_len_lt (by simp [hs2s1, \u2190 hlen]; exact twon_lt _) (by simp [hs2s1, \u2190 hlen])\n  unfold_let s2s1\n  simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n  unfold_let s2s2a\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n\n\ndef stoogesort2' (xs: List Nat) := stoogesort2 \u27e8xs, by rfl\u27e9\n", "proof_state": "xs : List \u2115\n\u22a2 (isPermutation (\u2191(stoogesort2' xs)) xs == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:852"}
{"full_name": "prop_StoogeSort2IsSort", "prop_defn": "theorem prop_StoogeSort2IsSort (xs: List Nat) : stoogesort2' xs == isort xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:853", "score": 5, "deps": "import Mathlib\n\ndef insert' : Nat \u2192 List Nat \u2192 List Nat\n| x, [] => [x]\n| x, y::xs => if x <= y then x::y::xs else y::(insert x xs)\n\n\ndef isort: List Nat \u2192 List Nat\n| [] => []\n| x::xs => insert' x (isort xs)\n\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n\n\ndef reverse : List Nat \u2192 List Nat\n| [] => []\n| x::xs => (reverse xs) ++ [x]\n\n\nlemma len_rev_eq_len {l: List Nat} : (reverse l).length = l.length := by\n  induction l with\n  | nil => simp [reverse]\n  | cons head tail ih => unfold reverse; simp [ih];\n\n\nlemma splitAt_len_le : (splitAt n xs).2.length \u2264 xs.length := by\n  induction xs generalizing n with\n  | nil => unfold splitAt; simp;\n  | cons head tail ih =>\n    cases n with\n    | zero => unfold splitAt; simp;\n    | succ nm1 => unfold splitAt; simp; apply Nat.le.step; exact ih;\n\n\nlemma splitAt_second_len_lt (n: Nat): (splitAt n.succ (x::xs)).2.length < (x::xs).length := by\n  unfold splitAt;\n  simp;\n  calc List.length (splitAt n xs).2 \u2264 (List.length xs) := splitAt_len_le\n       _                          < Nat.succ (List.length xs) := Nat.lt_succ_self _\n\n\nlemma splitAt_second_len_lt' (n: Nat) (hlen: xs.length > 0): (splitAt n.succ xs).2.length < xs.length := by\n  cases xs with\n  | nil => simp at hlen;\n  | cons x xs => exact splitAt_second_len_lt _;\n\n\nlemma splitAt_second_len_lt'' (hn: n > 0) (hlen: xs.length > 0) (hlen': xl = xs.length): (splitAt n xs).2.length < xl := by\n  cases n with\n  | zero => simp at hn;\n  | succ nm1 => rw [hlen']; exact splitAt_second_len_lt' _ hlen;\n\n\nlemma splitAt_sum_preserves_len (n: Nat) (xs: List Nat) (hspl: spl = splitAt n xs):\n  (spl.1.length + spl.2.length = xs.length) := by\n  induction xs generalizing n spl with\n  | nil => simp [splitAt] at hspl; simp [hspl];\n  | cons head tail ih => cases n with\n    | zero => simp [splitAt] at hspl; simp [hspl];\n    | succ nm1 =>\n      simp [splitAt] at hspl;\n      simp [hspl]\n      rw [Nat.succ_add];\n      apply Order.succ_eq_succ_iff.2\n      exact ih nm1 (by rfl);\n\n\nlemma splitAt_first_len_lt (hn: n < xl) (hlen': xl = xs.length): (splitAt n xs).1.length < xl := by\n  suffices heq : (splitAt n xs).1.length = n\n  simp [heq, hn]\n  induction xs generalizing n xl with\n  | nil => simp [hlen'] at hn;\n  | cons head tail ih =>\n    cases n with\n    | zero => simp [splitAt];\n    | succ nm1 =>\n      simp [splitAt];\n      exact @ih nm1 tail.length (by simp [hlen'] at hn; exact hn) rfl\n\n\nlemma twon_lt (n: Nat): (2*n.succ.succ.succ + 1)/ 3 < n.succ.succ.succ := by\n  simp [Nat.succ_eq_add_one];\n  ring_nf;\n  rw [Nat.div_lt_iff_lt_mul (by simp)];\n  ring_nf;\n  linarith;\n\n\ndef stoogesort2 (xs : {xs : List Nat // xs.length = n}) : {ys: List Nat // ys.length = n} := match xs with\n| \u27e8[], h\u27e9 => \u27e8[], h\u27e9\n| \u27e8[x], h\u27e9 => \u27e8[x], h\u27e9\n| \u27e8[x, y], h\u27e9 => if x <= y then \u27e8[x, y], h\u27e9 else \u27e8[y, x], by simp [\u2190h]\u27e9\n| \u27e8x1::x2::x3::xs, hlen\u27e9 =>\n  let yzs1 := splitAt ((2*(x1::x2::x3::xs).length + 1) / 3) (x1::x2::x3::xs)\n  let \u27e8tmp2, hlen2\u27e9 := @stoogesort2 yzs1.1.length \u27e8yzs1.1, by rfl\u27e9\n  let s2s2a := tmp2 ++ yzs1.2\n  let yzs2 := splitAt (s2s2a.length / 3) s2s2a\n  let \u27e8tmp3, hlen3\u27e9 := @stoogesort2 yzs2.2.length \u27e8yzs2.2, by rfl\u27e9\n  let s2s1 := yzs2.1 ++ tmp3\n  let yzs3 := splitAt ((2*s2s1.length + 1) / 3) s2s1\n  let \u27e8tmp4, hlen4\u27e9 := @stoogesort2 yzs3.1.length \u27e8yzs3.1, by rfl\u27e9\n  \u27e8tmp4 ++ yzs3.2, by\n    simp [hlen4];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs3), len_rev_eq_len];\n    unfold_let s2s1\n    simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n    unfold_let s2s2a\n    simp [hlen2];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs1), hlen]\n    \u27e9\ntermination_by match xs with | \u27e8lst, _h\u27e9 => lst.length\ndecreasing_by\n  simp_wf;\n  simp at hlen;\n  rw [\u2190 hlen]\n  apply splitAt_first_len_lt (twon_lt _) (by simp)\n  simp_wf;\n  suffices hyzs2 : yzs2.2.length < n\n  unfold_let yzs2 at hyzs2\n  rw [List.length_append] at hyzs2\n  exact hyzs2;\n  unfold_let yzs2\n  suffices hs2s2a : s2s2a.length = n\n  rw [hs2s2a, \u2190 hlen]\n  apply splitAt_second_len_lt'' (by simp [Nat.succ_eq_add_one, Nat.add_assoc]) (by simp [hs2s2a, \u2190hlen]) (by simp [hs2s2a, \u2190hlen])\n  unfold_let s2s2a\n  simp [hlen2, splitAt_sum_preserves_len _ _ (Eq.refl yzs1), hlen]\n  simp_wf;\n  suffices hdone: yzs3.1.length < n\n  unfold_let yzs3 s2s1 yzs2 s2s2a yzs1 at hdone\n  simp [List.length_append] at hdone;\n  exact hdone;\n  unfold_let yzs3\n  suffices hs2s1: s2s1.length = xs.length.succ.succ.succ\n  refine splitAt_first_len_lt (by simp [hs2s1, \u2190 hlen]; exact twon_lt _) (by simp [hs2s1, \u2190 hlen])\n  unfold_let s2s1\n  simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n  unfold_let s2s2a\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n\n\ndef stoogesort2' (xs: List Nat) := stoogesort2 \u27e8xs, by rfl\u27e9\n", "proof_state": "xs : List \u2115\n\u22a2 (\u2191(stoogesort2' xs) == isort xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:853"}
{"full_name": "prop_NStoogeSortSorts", "prop_defn": "theorem prop_NStoogeSortSorts (xs: List Nat) : ordered (nstoogesort' xs) == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:923", "score": 5, "deps": "import Mathlib\n\ndef ordered : List Nat -> Bool\n| []       => True\n| [_x]     => True\n| x::y::xs => x <= y && ordered (y::xs)\n\n\ndef third : Nat \u2192 Nat\n| 0 => 0\n| 1 => 0\n| 2 => 0\n| n + 3 => 1 + (third n)\n\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n\n\ndef reverse : List Nat \u2192 List Nat\n| [] => []\n| x::xs => (reverse xs) ++ [x]\n\n\nlemma len_rev_eq_len {l: List Nat} : (reverse l).length = l.length := by\n  induction l with\n  | nil => simp [reverse]\n  | cons head tail ih => unfold reverse; simp [ih];\n\n\nlemma splitAt_len_le : (splitAt n xs).2.length \u2264 xs.length := by\n  induction xs generalizing n with\n  | nil => unfold splitAt; simp;\n  | cons head tail ih =>\n    cases n with\n    | zero => unfold splitAt; simp;\n    | succ nm1 => unfold splitAt; simp; apply Nat.le.step; exact ih;\n\n\nlemma splitAt_second_len_lt (n: Nat): (splitAt n.succ (x::xs)).2.length < (x::xs).length := by\n  unfold splitAt;\n  simp;\n  calc List.length (splitAt n xs).2 \u2264 (List.length xs) := splitAt_len_le\n       _                          < Nat.succ (List.length xs) := Nat.lt_succ_self _\n\n\nlemma splitAt_second_len_lt' (n: Nat) (hlen: xs.length > 0): (splitAt n.succ xs).2.length < xs.length := by\n  cases xs with\n  | nil => simp at hlen;\n  | cons x xs => exact splitAt_second_len_lt _;\n\n\nlemma splitAt_second_len_lt'' (hn: n > 0) (hlen: xs.length > 0) (hlen': xl = xs.length): (splitAt n xs).2.length < xl := by\n  cases n with\n  | zero => simp at hn;\n  | succ nm1 => rw [hlen']; exact splitAt_second_len_lt' _ hlen;\n\n\nlemma splitAt_sum_preserves_len (n: Nat) (xs: List Nat) (hspl: spl = splitAt n xs):\n  (spl.1.length + spl.2.length = xs.length) := by\n  induction xs generalizing n spl with\n  | nil => simp [splitAt] at hspl; simp [hspl];\n  | cons head tail ih => cases n with\n    | zero => simp [splitAt] at hspl; simp [hspl];\n    | succ nm1 =>\n      simp [splitAt] at hspl;\n      simp [hspl]\n      rw [Nat.succ_add];\n      apply Order.succ_eq_succ_iff.2\n      exact ih nm1 (by rfl);\n\n\nlemma third_eq_div_3 : (x/3) = third x := by\n  induction x using Nat.strongInductionOn with\n  | ind x ih =>\n  unfold third\n  match x with\n  | 0 => simp;\n  | 1 => simp;\n  | 2 => simp;\n  | n + 3 => simp [Nat.succ_eq_add_one]; ring_nf; linarith [ih n (by linarith)]\n\n\ndef nstoogesort (xs : {xs : List Nat // xs.length = n}) : {ys: List Nat // ys.length = n} := match xs with\n| \u27e8[], h\u27e9 => \u27e8[], h\u27e9\n| \u27e8[x], h\u27e9 => \u27e8[x], h\u27e9\n| \u27e8[x, y], h\u27e9 => if x <= y then \u27e8[x, y], h\u27e9 else \u27e8[y, x], by simp [\u2190h]\u27e9\n| \u27e8x1::x2::x3::xs, hlen\u27e9 =>\n  let yzs1 := splitAt (third (x1::x2::x3::xs).length) (reverse (x1::x2::x3::xs))\n  let \u27e8tmp2, hlen2\u27e9 := (@nstoogesort yzs1.2.length \u27e8yzs1.2, by rfl\u27e9)\n  let s1s2a := tmp2 ++ (reverse yzs1.1)\n  let yzs2 := splitAt (third s1s2a.length) s1s2a\n  let \u27e8tmp3, hlen3\u27e9 := (@nstoogesort yzs2.2.length \u27e8yzs2.2, by rfl\u27e9)\n  let s1s1 := yzs2.1 ++ tmp3\n  let yzs3 := splitAt (third s1s1.length) (reverse s1s1)\n  let \u27e8tmp4, hlen4\u27e9 := (@nstoogesort yzs3.2.length \u27e8yzs3.2, by rfl\u27e9)\n  \u27e8tmp4 ++ (reverse yzs3.1), by\n    simp [hlen4, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs3), len_rev_eq_len];\n    unfold_let s1s1\n    simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n    unfold_let s1s2a\n    simp [hlen2, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs1), len_rev_eq_len, hlen]\n    \u27e9\ntermination_by match xs with | \u27e8lst, _h\u27e9 => lst.length\ndecreasing_by\n  simp_wf\n  apply splitAt_second_len_lt''\n    (by simp [\u2190third_eq_div_3, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, hlen])\n  simp_wf\n  suffices hyzs2 : (splitAt (List.length s1s2a / 3) s1s2a).2.length < n\n  rw [List.length_append, third_eq_div_3] at hyzs2\n  exact hyzs2;\n  unfold_let s1s2a\n  suffices hyzs1 : List.length (tmp2 ++ reverse yzs1.1) = List.length xs + 3\n  exact splitAt_second_len_lt'' (by simp [hyzs1]) (by simp [hyzs1]) (by simp [hyzs1, \u2190hlen])\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n  simp_wf\n  suffices hyzs3 : (splitAt (List.length s1s1 / 3) (reverse s1s1)).2.length < n\n  unfold_let s1s1 yzs2 s1s2a yzs1 at hyzs3\n  simp [List.length_append, third_eq_div_3] at hyzs3;\n  exact hyzs3;\n  suffices hs1s1: s1s1.length = xs.length + 3\n  exact splitAt_second_len_lt'' (by simp [hs1s1]) (by simp [len_rev_eq_len, hs1s1]) (by simp [len_rev_eq_len, hs1s1, \u2190hlen])\n  unfold_let s1s1\n  simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n  unfold_let s1s2a\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n\n\ndef nstoogesort' (xs: List Nat) := nstoogesort \u27e8xs, (by rfl)\u27e9\n", "proof_state": "xs : List \u2115\n\u22a2 (ordered \u2191(nstoogesort' xs) == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:923"}
{"full_name": "prop_NStoogeSortCount", "prop_defn": "theorem prop_NStoogeSortCount (x: Nat) (xs: List Nat) : count x (nstoogesort' xs) == count x xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:924", "score": 5, "deps": "import Mathlib\n\ndef count [DecidableEq \u03b1] : \u03b1 \u2192 List \u03b1 \u2192 Nat\n| _x, [] => 0\n| x, y::ys => if x == y then 1 + (count x ys) else count x ys\n\n\ndef third : Nat \u2192 Nat\n| 0 => 0\n| 1 => 0\n| 2 => 0\n| n + 3 => 1 + (third n)\n\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n\n\ndef reverse : List Nat \u2192 List Nat\n| [] => []\n| x::xs => (reverse xs) ++ [x]\n\n\nlemma len_rev_eq_len {l: List Nat} : (reverse l).length = l.length := by\n  induction l with\n  | nil => simp [reverse]\n  | cons head tail ih => unfold reverse; simp [ih];\n\n\nlemma splitAt_len_le : (splitAt n xs).2.length \u2264 xs.length := by\n  induction xs generalizing n with\n  | nil => unfold splitAt; simp;\n  | cons head tail ih =>\n    cases n with\n    | zero => unfold splitAt; simp;\n    | succ nm1 => unfold splitAt; simp; apply Nat.le.step; exact ih;\n\n\nlemma splitAt_second_len_lt (n: Nat): (splitAt n.succ (x::xs)).2.length < (x::xs).length := by\n  unfold splitAt;\n  simp;\n  calc List.length (splitAt n xs).2 \u2264 (List.length xs) := splitAt_len_le\n       _                          < Nat.succ (List.length xs) := Nat.lt_succ_self _\n\n\nlemma splitAt_second_len_lt' (n: Nat) (hlen: xs.length > 0): (splitAt n.succ xs).2.length < xs.length := by\n  cases xs with\n  | nil => simp at hlen;\n  | cons x xs => exact splitAt_second_len_lt _;\n\n\nlemma splitAt_second_len_lt'' (hn: n > 0) (hlen: xs.length > 0) (hlen': xl = xs.length): (splitAt n xs).2.length < xl := by\n  cases n with\n  | zero => simp at hn;\n  | succ nm1 => rw [hlen']; exact splitAt_second_len_lt' _ hlen;\n\n\nlemma splitAt_sum_preserves_len (n: Nat) (xs: List Nat) (hspl: spl = splitAt n xs):\n  (spl.1.length + spl.2.length = xs.length) := by\n  induction xs generalizing n spl with\n  | nil => simp [splitAt] at hspl; simp [hspl];\n  | cons head tail ih => cases n with\n    | zero => simp [splitAt] at hspl; simp [hspl];\n    | succ nm1 =>\n      simp [splitAt] at hspl;\n      simp [hspl]\n      rw [Nat.succ_add];\n      apply Order.succ_eq_succ_iff.2\n      exact ih nm1 (by rfl);\n\n\nlemma third_eq_div_3 : (x/3) = third x := by\n  induction x using Nat.strongInductionOn with\n  | ind x ih =>\n  unfold third\n  match x with\n  | 0 => simp;\n  | 1 => simp;\n  | 2 => simp;\n  | n + 3 => simp [Nat.succ_eq_add_one]; ring_nf; linarith [ih n (by linarith)]\n\n\ndef nstoogesort (xs : {xs : List Nat // xs.length = n}) : {ys: List Nat // ys.length = n} := match xs with\n| \u27e8[], h\u27e9 => \u27e8[], h\u27e9\n| \u27e8[x], h\u27e9 => \u27e8[x], h\u27e9\n| \u27e8[x, y], h\u27e9 => if x <= y then \u27e8[x, y], h\u27e9 else \u27e8[y, x], by simp [\u2190h]\u27e9\n| \u27e8x1::x2::x3::xs, hlen\u27e9 =>\n  let yzs1 := splitAt (third (x1::x2::x3::xs).length) (reverse (x1::x2::x3::xs))\n  let \u27e8tmp2, hlen2\u27e9 := (@nstoogesort yzs1.2.length \u27e8yzs1.2, by rfl\u27e9)\n  let s1s2a := tmp2 ++ (reverse yzs1.1)\n  let yzs2 := splitAt (third s1s2a.length) s1s2a\n  let \u27e8tmp3, hlen3\u27e9 := (@nstoogesort yzs2.2.length \u27e8yzs2.2, by rfl\u27e9)\n  let s1s1 := yzs2.1 ++ tmp3\n  let yzs3 := splitAt (third s1s1.length) (reverse s1s1)\n  let \u27e8tmp4, hlen4\u27e9 := (@nstoogesort yzs3.2.length \u27e8yzs3.2, by rfl\u27e9)\n  \u27e8tmp4 ++ (reverse yzs3.1), by\n    simp [hlen4, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs3), len_rev_eq_len];\n    unfold_let s1s1\n    simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n    unfold_let s1s2a\n    simp [hlen2, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs1), len_rev_eq_len, hlen]\n    \u27e9\ntermination_by match xs with | \u27e8lst, _h\u27e9 => lst.length\ndecreasing_by\n  simp_wf\n  apply splitAt_second_len_lt''\n    (by simp [\u2190third_eq_div_3, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, hlen])\n  simp_wf\n  suffices hyzs2 : (splitAt (List.length s1s2a / 3) s1s2a).2.length < n\n  rw [List.length_append, third_eq_div_3] at hyzs2\n  exact hyzs2;\n  unfold_let s1s2a\n  suffices hyzs1 : List.length (tmp2 ++ reverse yzs1.1) = List.length xs + 3\n  exact splitAt_second_len_lt'' (by simp [hyzs1]) (by simp [hyzs1]) (by simp [hyzs1, \u2190hlen])\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n  simp_wf\n  suffices hyzs3 : (splitAt (List.length s1s1 / 3) (reverse s1s1)).2.length < n\n  unfold_let s1s1 yzs2 s1s2a yzs1 at hyzs3\n  simp [List.length_append, third_eq_div_3] at hyzs3;\n  exact hyzs3;\n  suffices hs1s1: s1s1.length = xs.length + 3\n  exact splitAt_second_len_lt'' (by simp [hs1s1]) (by simp [len_rev_eq_len, hs1s1]) (by simp [len_rev_eq_len, hs1s1, \u2190hlen])\n  unfold_let s1s1\n  simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n  unfold_let s1s2a\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n\n\ndef nstoogesort' (xs: List Nat) := nstoogesort \u27e8xs, (by rfl)\u27e9\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (count x \u2191(nstoogesort' xs) == count x xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:924"}
{"full_name": "prop_NStoogeSortPermutes", "prop_defn": "theorem prop_NStoogeSortPermutes (xs: List Nat) : isPermutation (nstoogesort' xs) xs == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:925", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n\n\ndef third : Nat \u2192 Nat\n| 0 => 0\n| 1 => 0\n| 2 => 0\n| n + 3 => 1 + (third n)\n\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n\n\ndef reverse : List Nat \u2192 List Nat\n| [] => []\n| x::xs => (reverse xs) ++ [x]\n\n\nlemma len_rev_eq_len {l: List Nat} : (reverse l).length = l.length := by\n  induction l with\n  | nil => simp [reverse]\n  | cons head tail ih => unfold reverse; simp [ih];\n\n\nlemma splitAt_len_le : (splitAt n xs).2.length \u2264 xs.length := by\n  induction xs generalizing n with\n  | nil => unfold splitAt; simp;\n  | cons head tail ih =>\n    cases n with\n    | zero => unfold splitAt; simp;\n    | succ nm1 => unfold splitAt; simp; apply Nat.le.step; exact ih;\n\n\nlemma splitAt_second_len_lt (n: Nat): (splitAt n.succ (x::xs)).2.length < (x::xs).length := by\n  unfold splitAt;\n  simp;\n  calc List.length (splitAt n xs).2 \u2264 (List.length xs) := splitAt_len_le\n       _                          < Nat.succ (List.length xs) := Nat.lt_succ_self _\n\n\nlemma splitAt_second_len_lt' (n: Nat) (hlen: xs.length > 0): (splitAt n.succ xs).2.length < xs.length := by\n  cases xs with\n  | nil => simp at hlen;\n  | cons x xs => exact splitAt_second_len_lt _;\n\n\nlemma splitAt_second_len_lt'' (hn: n > 0) (hlen: xs.length > 0) (hlen': xl = xs.length): (splitAt n xs).2.length < xl := by\n  cases n with\n  | zero => simp at hn;\n  | succ nm1 => rw [hlen']; exact splitAt_second_len_lt' _ hlen;\n\n\nlemma splitAt_sum_preserves_len (n: Nat) (xs: List Nat) (hspl: spl = splitAt n xs):\n  (spl.1.length + spl.2.length = xs.length) := by\n  induction xs generalizing n spl with\n  | nil => simp [splitAt] at hspl; simp [hspl];\n  | cons head tail ih => cases n with\n    | zero => simp [splitAt] at hspl; simp [hspl];\n    | succ nm1 =>\n      simp [splitAt] at hspl;\n      simp [hspl]\n      rw [Nat.succ_add];\n      apply Order.succ_eq_succ_iff.2\n      exact ih nm1 (by rfl);\n\n\nlemma third_eq_div_3 : (x/3) = third x := by\n  induction x using Nat.strongInductionOn with\n  | ind x ih =>\n  unfold third\n  match x with\n  | 0 => simp;\n  | 1 => simp;\n  | 2 => simp;\n  | n + 3 => simp [Nat.succ_eq_add_one]; ring_nf; linarith [ih n (by linarith)]\n\n\ndef nstoogesort (xs : {xs : List Nat // xs.length = n}) : {ys: List Nat // ys.length = n} := match xs with\n| \u27e8[], h\u27e9 => \u27e8[], h\u27e9\n| \u27e8[x], h\u27e9 => \u27e8[x], h\u27e9\n| \u27e8[x, y], h\u27e9 => if x <= y then \u27e8[x, y], h\u27e9 else \u27e8[y, x], by simp [\u2190h]\u27e9\n| \u27e8x1::x2::x3::xs, hlen\u27e9 =>\n  let yzs1 := splitAt (third (x1::x2::x3::xs).length) (reverse (x1::x2::x3::xs))\n  let \u27e8tmp2, hlen2\u27e9 := (@nstoogesort yzs1.2.length \u27e8yzs1.2, by rfl\u27e9)\n  let s1s2a := tmp2 ++ (reverse yzs1.1)\n  let yzs2 := splitAt (third s1s2a.length) s1s2a\n  let \u27e8tmp3, hlen3\u27e9 := (@nstoogesort yzs2.2.length \u27e8yzs2.2, by rfl\u27e9)\n  let s1s1 := yzs2.1 ++ tmp3\n  let yzs3 := splitAt (third s1s1.length) (reverse s1s1)\n  let \u27e8tmp4, hlen4\u27e9 := (@nstoogesort yzs3.2.length \u27e8yzs3.2, by rfl\u27e9)\n  \u27e8tmp4 ++ (reverse yzs3.1), by\n    simp [hlen4, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs3), len_rev_eq_len];\n    unfold_let s1s1\n    simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n    unfold_let s1s2a\n    simp [hlen2, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs1), len_rev_eq_len, hlen]\n    \u27e9\ntermination_by match xs with | \u27e8lst, _h\u27e9 => lst.length\ndecreasing_by\n  simp_wf\n  apply splitAt_second_len_lt''\n    (by simp [\u2190third_eq_div_3, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, hlen])\n  simp_wf\n  suffices hyzs2 : (splitAt (List.length s1s2a / 3) s1s2a).2.length < n\n  rw [List.length_append, third_eq_div_3] at hyzs2\n  exact hyzs2;\n  unfold_let s1s2a\n  suffices hyzs1 : List.length (tmp2 ++ reverse yzs1.1) = List.length xs + 3\n  exact splitAt_second_len_lt'' (by simp [hyzs1]) (by simp [hyzs1]) (by simp [hyzs1, \u2190hlen])\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n  simp_wf\n  suffices hyzs3 : (splitAt (List.length s1s1 / 3) (reverse s1s1)).2.length < n\n  unfold_let s1s1 yzs2 s1s2a yzs1 at hyzs3\n  simp [List.length_append, third_eq_div_3] at hyzs3;\n  exact hyzs3;\n  suffices hs1s1: s1s1.length = xs.length + 3\n  exact splitAt_second_len_lt'' (by simp [hs1s1]) (by simp [len_rev_eq_len, hs1s1]) (by simp [len_rev_eq_len, hs1s1, \u2190hlen])\n  unfold_let s1s1\n  simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n  unfold_let s1s2a\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n\n\ndef nstoogesort' (xs: List Nat) := nstoogesort \u27e8xs, (by rfl)\u27e9\n", "proof_state": "xs : List \u2115\n\u22a2 (isPermutation (\u2191(nstoogesort' xs)) xs == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:925"}
{"full_name": "prop_NStoogeSortIsSort", "prop_defn": "theorem prop_NStoogeSortIsSort (xs: List Nat) : nstoogesort' xs == isort xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:926", "score": 5, "deps": "import Mathlib\n\ndef third : Nat \u2192 Nat\n| 0 => 0\n| 1 => 0\n| 2 => 0\n| n + 3 => 1 + (third n)\n\n\ndef insert' : Nat \u2192 List Nat \u2192 List Nat\n| x, [] => [x]\n| x, y::xs => if x <= y then x::y::xs else y::(insert x xs)\n\n\ndef isort: List Nat \u2192 List Nat\n| [] => []\n| x::xs => insert' x (isort xs)\n\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n\n\ndef reverse : List Nat \u2192 List Nat\n| [] => []\n| x::xs => (reverse xs) ++ [x]\n\n\nlemma len_rev_eq_len {l: List Nat} : (reverse l).length = l.length := by\n  induction l with\n  | nil => simp [reverse]\n  | cons head tail ih => unfold reverse; simp [ih];\n\n\nlemma splitAt_len_le : (splitAt n xs).2.length \u2264 xs.length := by\n  induction xs generalizing n with\n  | nil => unfold splitAt; simp;\n  | cons head tail ih =>\n    cases n with\n    | zero => unfold splitAt; simp;\n    | succ nm1 => unfold splitAt; simp; apply Nat.le.step; exact ih;\n\n\nlemma splitAt_second_len_lt (n: Nat): (splitAt n.succ (x::xs)).2.length < (x::xs).length := by\n  unfold splitAt;\n  simp;\n  calc List.length (splitAt n xs).2 \u2264 (List.length xs) := splitAt_len_le\n       _                          < Nat.succ (List.length xs) := Nat.lt_succ_self _\n\n\nlemma splitAt_second_len_lt' (n: Nat) (hlen: xs.length > 0): (splitAt n.succ xs).2.length < xs.length := by\n  cases xs with\n  | nil => simp at hlen;\n  | cons x xs => exact splitAt_second_len_lt _;\n\n\nlemma splitAt_second_len_lt'' (hn: n > 0) (hlen: xs.length > 0) (hlen': xl = xs.length): (splitAt n xs).2.length < xl := by\n  cases n with\n  | zero => simp at hn;\n  | succ nm1 => rw [hlen']; exact splitAt_second_len_lt' _ hlen;\n\n\nlemma splitAt_sum_preserves_len (n: Nat) (xs: List Nat) (hspl: spl = splitAt n xs):\n  (spl.1.length + spl.2.length = xs.length) := by\n  induction xs generalizing n spl with\n  | nil => simp [splitAt] at hspl; simp [hspl];\n  | cons head tail ih => cases n with\n    | zero => simp [splitAt] at hspl; simp [hspl];\n    | succ nm1 =>\n      simp [splitAt] at hspl;\n      simp [hspl]\n      rw [Nat.succ_add];\n      apply Order.succ_eq_succ_iff.2\n      exact ih nm1 (by rfl);\n\n\nlemma third_eq_div_3 : (x/3) = third x := by\n  induction x using Nat.strongInductionOn with\n  | ind x ih =>\n  unfold third\n  match x with\n  | 0 => simp;\n  | 1 => simp;\n  | 2 => simp;\n  | n + 3 => simp [Nat.succ_eq_add_one]; ring_nf; linarith [ih n (by linarith)]\n\n\ndef nstoogesort (xs : {xs : List Nat // xs.length = n}) : {ys: List Nat // ys.length = n} := match xs with\n| \u27e8[], h\u27e9 => \u27e8[], h\u27e9\n| \u27e8[x], h\u27e9 => \u27e8[x], h\u27e9\n| \u27e8[x, y], h\u27e9 => if x <= y then \u27e8[x, y], h\u27e9 else \u27e8[y, x], by simp [\u2190h]\u27e9\n| \u27e8x1::x2::x3::xs, hlen\u27e9 =>\n  let yzs1 := splitAt (third (x1::x2::x3::xs).length) (reverse (x1::x2::x3::xs))\n  let \u27e8tmp2, hlen2\u27e9 := (@nstoogesort yzs1.2.length \u27e8yzs1.2, by rfl\u27e9)\n  let s1s2a := tmp2 ++ (reverse yzs1.1)\n  let yzs2 := splitAt (third s1s2a.length) s1s2a\n  let \u27e8tmp3, hlen3\u27e9 := (@nstoogesort yzs2.2.length \u27e8yzs2.2, by rfl\u27e9)\n  let s1s1 := yzs2.1 ++ tmp3\n  let yzs3 := splitAt (third s1s1.length) (reverse s1s1)\n  let \u27e8tmp4, hlen4\u27e9 := (@nstoogesort yzs3.2.length \u27e8yzs3.2, by rfl\u27e9)\n  \u27e8tmp4 ++ (reverse yzs3.1), by\n    simp [hlen4, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs3), len_rev_eq_len];\n    unfold_let s1s1\n    simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n    unfold_let s1s2a\n    simp [hlen2, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs1), len_rev_eq_len, hlen]\n    \u27e9\ntermination_by match xs with | \u27e8lst, _h\u27e9 => lst.length\ndecreasing_by\n  simp_wf\n  apply splitAt_second_len_lt''\n    (by simp [\u2190third_eq_div_3, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, hlen])\n  simp_wf\n  suffices hyzs2 : (splitAt (List.length s1s2a / 3) s1s2a).2.length < n\n  rw [List.length_append, third_eq_div_3] at hyzs2\n  exact hyzs2;\n  unfold_let s1s2a\n  suffices hyzs1 : List.length (tmp2 ++ reverse yzs1.1) = List.length xs + 3\n  exact splitAt_second_len_lt'' (by simp [hyzs1]) (by simp [hyzs1]) (by simp [hyzs1, \u2190hlen])\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n  simp_wf\n  suffices hyzs3 : (splitAt (List.length s1s1 / 3) (reverse s1s1)).2.length < n\n  unfold_let s1s1 yzs2 s1s2a yzs1 at hyzs3\n  simp [List.length_append, third_eq_div_3] at hyzs3;\n  exact hyzs3;\n  suffices hs1s1: s1s1.length = xs.length + 3\n  exact splitAt_second_len_lt'' (by simp [hs1s1]) (by simp [len_rev_eq_len, hs1s1]) (by simp [len_rev_eq_len, hs1s1, \u2190hlen])\n  unfold_let s1s1\n  simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n  unfold_let s1s2a\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n\n\ndef nstoogesort' (xs: List Nat) := nstoogesort \u27e8xs, (by rfl)\u27e9\n", "proof_state": "xs : List \u2115\n\u22a2 (\u2191(nstoogesort' xs) == isort xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:926"}
{"full_name": "prop_NStoogeSort2Sorts", "prop_defn": "theorem prop_NStoogeSort2Sorts (xs: List Nat) : ordered (nstoogesort2' xs) == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:996", "score": 5, "deps": "import Mathlib\n\ndef ordered : List Nat -> Bool\n| []       => True\n| [_x]     => True\n| x::y::xs => x <= y && ordered (y::xs)\n\n\ndef third : Nat \u2192 Nat\n| 0 => 0\n| 1 => 0\n| 2 => 0\n| n + 3 => 1 + (third n)\n\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n\n\ndef reverse : List Nat \u2192 List Nat\n| [] => []\n| x::xs => (reverse xs) ++ [x]\n\n\nlemma len_rev_eq_len {l: List Nat} : (reverse l).length = l.length := by\n  induction l with\n  | nil => simp [reverse]\n  | cons head tail ih => unfold reverse; simp [ih];\n\n\nlemma splitAt_len_le : (splitAt n xs).2.length \u2264 xs.length := by\n  induction xs generalizing n with\n  | nil => unfold splitAt; simp;\n  | cons head tail ih =>\n    cases n with\n    | zero => unfold splitAt; simp;\n    | succ nm1 => unfold splitAt; simp; apply Nat.le.step; exact ih;\n\n\nlemma splitAt_second_len_lt (n: Nat): (splitAt n.succ (x::xs)).2.length < (x::xs).length := by\n  unfold splitAt;\n  simp;\n  calc List.length (splitAt n xs).2 \u2264 (List.length xs) := splitAt_len_le\n       _                          < Nat.succ (List.length xs) := Nat.lt_succ_self _\n\n\nlemma splitAt_second_len_lt' (n: Nat) (hlen: xs.length > 0): (splitAt n.succ xs).2.length < xs.length := by\n  cases xs with\n  | nil => simp at hlen;\n  | cons x xs => exact splitAt_second_len_lt _;\n\n\nlemma splitAt_second_len_lt'' (hn: n > 0) (hlen: xs.length > 0) (hlen': xl = xs.length): (splitAt n xs).2.length < xl := by\n  cases n with\n  | zero => simp at hn;\n  | succ nm1 => rw [hlen']; exact splitAt_second_len_lt' _ hlen;\n\n\nlemma splitAt_sum_preserves_len (n: Nat) (xs: List Nat) (hspl: spl = splitAt n xs):\n  (spl.1.length + spl.2.length = xs.length) := by\n  induction xs generalizing n spl with\n  | nil => simp [splitAt] at hspl; simp [hspl];\n  | cons head tail ih => cases n with\n    | zero => simp [splitAt] at hspl; simp [hspl];\n    | succ nm1 =>\n      simp [splitAt] at hspl;\n      simp [hspl]\n      rw [Nat.succ_add];\n      apply Order.succ_eq_succ_iff.2\n      exact ih nm1 (by rfl);\n\n\nlemma third_eq_div_3 : (x/3) = third x := by\n  induction x using Nat.strongInductionOn with\n  | ind x ih =>\n  unfold third\n  match x with\n  | 0 => simp;\n  | 1 => simp;\n  | 2 => simp;\n  | n + 3 => simp [Nat.succ_eq_add_one]; ring_nf; linarith [ih n (by linarith)]\n\n\ndef nstoogesort (xs : {xs : List Nat // xs.length = n}) : {ys: List Nat // ys.length = n} := match xs with\n| \u27e8[], h\u27e9 => \u27e8[], h\u27e9\n| \u27e8[x], h\u27e9 => \u27e8[x], h\u27e9\n| \u27e8[x, y], h\u27e9 => if x <= y then \u27e8[x, y], h\u27e9 else \u27e8[y, x], by simp [\u2190h]\u27e9\n| \u27e8x1::x2::x3::xs, hlen\u27e9 =>\n  let yzs1 := splitAt (third (x1::x2::x3::xs).length) (reverse (x1::x2::x3::xs))\n  let \u27e8tmp2, hlen2\u27e9 := (@nstoogesort yzs1.2.length \u27e8yzs1.2, by rfl\u27e9)\n  let s1s2a := tmp2 ++ (reverse yzs1.1)\n  let yzs2 := splitAt (third s1s2a.length) s1s2a\n  let \u27e8tmp3, hlen3\u27e9 := (@nstoogesort yzs2.2.length \u27e8yzs2.2, by rfl\u27e9)\n  let s1s1 := yzs2.1 ++ tmp3\n  let yzs3 := splitAt (third s1s1.length) (reverse s1s1)\n  let \u27e8tmp4, hlen4\u27e9 := (@nstoogesort yzs3.2.length \u27e8yzs3.2, by rfl\u27e9)\n  \u27e8tmp4 ++ (reverse yzs3.1), by\n    simp [hlen4, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs3), len_rev_eq_len];\n    unfold_let s1s1\n    simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n    unfold_let s1s2a\n    simp [hlen2, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs1), len_rev_eq_len, hlen]\n    \u27e9\ntermination_by match xs with | \u27e8lst, _h\u27e9 => lst.length\ndecreasing_by\n  simp_wf\n  apply splitAt_second_len_lt''\n    (by simp [\u2190third_eq_div_3, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, hlen])\n  simp_wf\n  suffices hyzs2 : (splitAt (List.length s1s2a / 3) s1s2a).2.length < n\n  rw [List.length_append, third_eq_div_3] at hyzs2\n  exact hyzs2;\n  unfold_let s1s2a\n  suffices hyzs1 : List.length (tmp2 ++ reverse yzs1.1) = List.length xs + 3\n  exact splitAt_second_len_lt'' (by simp [hyzs1]) (by simp [hyzs1]) (by simp [hyzs1, \u2190hlen])\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n  simp_wf\n  suffices hyzs3 : (splitAt (List.length s1s1 / 3) (reverse s1s1)).2.length < n\n  unfold_let s1s1 yzs2 s1s2a yzs1 at hyzs3\n  simp [List.length_append, third_eq_div_3] at hyzs3;\n  exact hyzs3;\n  suffices hs1s1: s1s1.length = xs.length + 3\n  exact splitAt_second_len_lt'' (by simp [hs1s1]) (by simp [len_rev_eq_len, hs1s1]) (by simp [len_rev_eq_len, hs1s1, \u2190hlen])\n  unfold_let s1s1\n  simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n  unfold_let s1s2a\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n\n\ndef nstoogesort2' (xs: List Nat) := nstoogesort \u27e8xs, (by rfl)\u27e9\n", "proof_state": "xs : List \u2115\n\u22a2 (ordered \u2191(nstoogesort2' xs) == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:996"}
{"full_name": "prop_NStoogeSort2Count", "prop_defn": "theorem prop_NStoogeSort2Count (x: Nat) (xs: List Nat) : count x (nstoogesort2' xs) == count x xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:997", "score": 5, "deps": "import Mathlib\n\ndef count [DecidableEq \u03b1] : \u03b1 \u2192 List \u03b1 \u2192 Nat\n| _x, [] => 0\n| x, y::ys => if x == y then 1 + (count x ys) else count x ys\n\n\ndef third : Nat \u2192 Nat\n| 0 => 0\n| 1 => 0\n| 2 => 0\n| n + 3 => 1 + (third n)\n\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n\n\ndef reverse : List Nat \u2192 List Nat\n| [] => []\n| x::xs => (reverse xs) ++ [x]\n\n\nlemma len_rev_eq_len {l: List Nat} : (reverse l).length = l.length := by\n  induction l with\n  | nil => simp [reverse]\n  | cons head tail ih => unfold reverse; simp [ih];\n\n\nlemma splitAt_len_le : (splitAt n xs).2.length \u2264 xs.length := by\n  induction xs generalizing n with\n  | nil => unfold splitAt; simp;\n  | cons head tail ih =>\n    cases n with\n    | zero => unfold splitAt; simp;\n    | succ nm1 => unfold splitAt; simp; apply Nat.le.step; exact ih;\n\n\nlemma splitAt_second_len_lt (n: Nat): (splitAt n.succ (x::xs)).2.length < (x::xs).length := by\n  unfold splitAt;\n  simp;\n  calc List.length (splitAt n xs).2 \u2264 (List.length xs) := splitAt_len_le\n       _                          < Nat.succ (List.length xs) := Nat.lt_succ_self _\n\n\nlemma splitAt_second_len_lt' (n: Nat) (hlen: xs.length > 0): (splitAt n.succ xs).2.length < xs.length := by\n  cases xs with\n  | nil => simp at hlen;\n  | cons x xs => exact splitAt_second_len_lt _;\n\n\nlemma splitAt_second_len_lt'' (hn: n > 0) (hlen: xs.length > 0) (hlen': xl = xs.length): (splitAt n xs).2.length < xl := by\n  cases n with\n  | zero => simp at hn;\n  | succ nm1 => rw [hlen']; exact splitAt_second_len_lt' _ hlen;\n\n\nlemma splitAt_sum_preserves_len (n: Nat) (xs: List Nat) (hspl: spl = splitAt n xs):\n  (spl.1.length + spl.2.length = xs.length) := by\n  induction xs generalizing n spl with\n  | nil => simp [splitAt] at hspl; simp [hspl];\n  | cons head tail ih => cases n with\n    | zero => simp [splitAt] at hspl; simp [hspl];\n    | succ nm1 =>\n      simp [splitAt] at hspl;\n      simp [hspl]\n      rw [Nat.succ_add];\n      apply Order.succ_eq_succ_iff.2\n      exact ih nm1 (by rfl);\n\n\nlemma third_eq_div_3 : (x/3) = third x := by\n  induction x using Nat.strongInductionOn with\n  | ind x ih =>\n  unfold third\n  match x with\n  | 0 => simp;\n  | 1 => simp;\n  | 2 => simp;\n  | n + 3 => simp [Nat.succ_eq_add_one]; ring_nf; linarith [ih n (by linarith)]\n\n\ndef nstoogesort (xs : {xs : List Nat // xs.length = n}) : {ys: List Nat // ys.length = n} := match xs with\n| \u27e8[], h\u27e9 => \u27e8[], h\u27e9\n| \u27e8[x], h\u27e9 => \u27e8[x], h\u27e9\n| \u27e8[x, y], h\u27e9 => if x <= y then \u27e8[x, y], h\u27e9 else \u27e8[y, x], by simp [\u2190h]\u27e9\n| \u27e8x1::x2::x3::xs, hlen\u27e9 =>\n  let yzs1 := splitAt (third (x1::x2::x3::xs).length) (reverse (x1::x2::x3::xs))\n  let \u27e8tmp2, hlen2\u27e9 := (@nstoogesort yzs1.2.length \u27e8yzs1.2, by rfl\u27e9)\n  let s1s2a := tmp2 ++ (reverse yzs1.1)\n  let yzs2 := splitAt (third s1s2a.length) s1s2a\n  let \u27e8tmp3, hlen3\u27e9 := (@nstoogesort yzs2.2.length \u27e8yzs2.2, by rfl\u27e9)\n  let s1s1 := yzs2.1 ++ tmp3\n  let yzs3 := splitAt (third s1s1.length) (reverse s1s1)\n  let \u27e8tmp4, hlen4\u27e9 := (@nstoogesort yzs3.2.length \u27e8yzs3.2, by rfl\u27e9)\n  \u27e8tmp4 ++ (reverse yzs3.1), by\n    simp [hlen4, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs3), len_rev_eq_len];\n    unfold_let s1s1\n    simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n    unfold_let s1s2a\n    simp [hlen2, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs1), len_rev_eq_len, hlen]\n    \u27e9\ntermination_by match xs with | \u27e8lst, _h\u27e9 => lst.length\ndecreasing_by\n  simp_wf\n  apply splitAt_second_len_lt''\n    (by simp [\u2190third_eq_div_3, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, hlen])\n  simp_wf\n  suffices hyzs2 : (splitAt (List.length s1s2a / 3) s1s2a).2.length < n\n  rw [List.length_append, third_eq_div_3] at hyzs2\n  exact hyzs2;\n  unfold_let s1s2a\n  suffices hyzs1 : List.length (tmp2 ++ reverse yzs1.1) = List.length xs + 3\n  exact splitAt_second_len_lt'' (by simp [hyzs1]) (by simp [hyzs1]) (by simp [hyzs1, \u2190hlen])\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n  simp_wf\n  suffices hyzs3 : (splitAt (List.length s1s1 / 3) (reverse s1s1)).2.length < n\n  unfold_let s1s1 yzs2 s1s2a yzs1 at hyzs3\n  simp [List.length_append, third_eq_div_3] at hyzs3;\n  exact hyzs3;\n  suffices hs1s1: s1s1.length = xs.length + 3\n  exact splitAt_second_len_lt'' (by simp [hs1s1]) (by simp [len_rev_eq_len, hs1s1]) (by simp [len_rev_eq_len, hs1s1, \u2190hlen])\n  unfold_let s1s1\n  simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n  unfold_let s1s2a\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n\n\ndef nstoogesort2' (xs: List Nat) := nstoogesort \u27e8xs, (by rfl)\u27e9\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (count x \u2191(nstoogesort2' xs) == count x xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:997"}
{"full_name": "prop_NStoogeSort2Permutes", "prop_defn": "theorem prop_NStoogeSort2Permutes (xs: List Nat) : isPermutation (nstoogesort2' xs) xs == true:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:998", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n\n\ndef third : Nat \u2192 Nat\n| 0 => 0\n| 1 => 0\n| 2 => 0\n| n + 3 => 1 + (third n)\n\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n\n\ndef reverse : List Nat \u2192 List Nat\n| [] => []\n| x::xs => (reverse xs) ++ [x]\n\n\nlemma len_rev_eq_len {l: List Nat} : (reverse l).length = l.length := by\n  induction l with\n  | nil => simp [reverse]\n  | cons head tail ih => unfold reverse; simp [ih];\n\n\nlemma splitAt_len_le : (splitAt n xs).2.length \u2264 xs.length := by\n  induction xs generalizing n with\n  | nil => unfold splitAt; simp;\n  | cons head tail ih =>\n    cases n with\n    | zero => unfold splitAt; simp;\n    | succ nm1 => unfold splitAt; simp; apply Nat.le.step; exact ih;\n\n\nlemma splitAt_second_len_lt (n: Nat): (splitAt n.succ (x::xs)).2.length < (x::xs).length := by\n  unfold splitAt;\n  simp;\n  calc List.length (splitAt n xs).2 \u2264 (List.length xs) := splitAt_len_le\n       _                          < Nat.succ (List.length xs) := Nat.lt_succ_self _\n\n\nlemma splitAt_second_len_lt' (n: Nat) (hlen: xs.length > 0): (splitAt n.succ xs).2.length < xs.length := by\n  cases xs with\n  | nil => simp at hlen;\n  | cons x xs => exact splitAt_second_len_lt _;\n\n\nlemma splitAt_second_len_lt'' (hn: n > 0) (hlen: xs.length > 0) (hlen': xl = xs.length): (splitAt n xs).2.length < xl := by\n  cases n with\n  | zero => simp at hn;\n  | succ nm1 => rw [hlen']; exact splitAt_second_len_lt' _ hlen;\n\n\nlemma splitAt_sum_preserves_len (n: Nat) (xs: List Nat) (hspl: spl = splitAt n xs):\n  (spl.1.length + spl.2.length = xs.length) := by\n  induction xs generalizing n spl with\n  | nil => simp [splitAt] at hspl; simp [hspl];\n  | cons head tail ih => cases n with\n    | zero => simp [splitAt] at hspl; simp [hspl];\n    | succ nm1 =>\n      simp [splitAt] at hspl;\n      simp [hspl]\n      rw [Nat.succ_add];\n      apply Order.succ_eq_succ_iff.2\n      exact ih nm1 (by rfl);\n\n\nlemma third_eq_div_3 : (x/3) = third x := by\n  induction x using Nat.strongInductionOn with\n  | ind x ih =>\n  unfold third\n  match x with\n  | 0 => simp;\n  | 1 => simp;\n  | 2 => simp;\n  | n + 3 => simp [Nat.succ_eq_add_one]; ring_nf; linarith [ih n (by linarith)]\n\n\ndef nstoogesort (xs : {xs : List Nat // xs.length = n}) : {ys: List Nat // ys.length = n} := match xs with\n| \u27e8[], h\u27e9 => \u27e8[], h\u27e9\n| \u27e8[x], h\u27e9 => \u27e8[x], h\u27e9\n| \u27e8[x, y], h\u27e9 => if x <= y then \u27e8[x, y], h\u27e9 else \u27e8[y, x], by simp [\u2190h]\u27e9\n| \u27e8x1::x2::x3::xs, hlen\u27e9 =>\n  let yzs1 := splitAt (third (x1::x2::x3::xs).length) (reverse (x1::x2::x3::xs))\n  let \u27e8tmp2, hlen2\u27e9 := (@nstoogesort yzs1.2.length \u27e8yzs1.2, by rfl\u27e9)\n  let s1s2a := tmp2 ++ (reverse yzs1.1)\n  let yzs2 := splitAt (third s1s2a.length) s1s2a\n  let \u27e8tmp3, hlen3\u27e9 := (@nstoogesort yzs2.2.length \u27e8yzs2.2, by rfl\u27e9)\n  let s1s1 := yzs2.1 ++ tmp3\n  let yzs3 := splitAt (third s1s1.length) (reverse s1s1)\n  let \u27e8tmp4, hlen4\u27e9 := (@nstoogesort yzs3.2.length \u27e8yzs3.2, by rfl\u27e9)\n  \u27e8tmp4 ++ (reverse yzs3.1), by\n    simp [hlen4, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs3), len_rev_eq_len];\n    unfold_let s1s1\n    simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n    unfold_let s1s2a\n    simp [hlen2, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs1), len_rev_eq_len, hlen]\n    \u27e9\ntermination_by match xs with | \u27e8lst, _h\u27e9 => lst.length\ndecreasing_by\n  simp_wf\n  apply splitAt_second_len_lt''\n    (by simp [\u2190third_eq_div_3, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, hlen])\n  simp_wf\n  suffices hyzs2 : (splitAt (List.length s1s2a / 3) s1s2a).2.length < n\n  rw [List.length_append, third_eq_div_3] at hyzs2\n  exact hyzs2;\n  unfold_let s1s2a\n  suffices hyzs1 : List.length (tmp2 ++ reverse yzs1.1) = List.length xs + 3\n  exact splitAt_second_len_lt'' (by simp [hyzs1]) (by simp [hyzs1]) (by simp [hyzs1, \u2190hlen])\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n  simp_wf\n  suffices hyzs3 : (splitAt (List.length s1s1 / 3) (reverse s1s1)).2.length < n\n  unfold_let s1s1 yzs2 s1s2a yzs1 at hyzs3\n  simp [List.length_append, third_eq_div_3] at hyzs3;\n  exact hyzs3;\n  suffices hs1s1: s1s1.length = xs.length + 3\n  exact splitAt_second_len_lt'' (by simp [hs1s1]) (by simp [len_rev_eq_len, hs1s1]) (by simp [len_rev_eq_len, hs1s1, \u2190hlen])\n  unfold_let s1s1\n  simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n  unfold_let s1s2a\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n\n\ndef nstoogesort2' (xs: List Nat) := nstoogesort \u27e8xs, (by rfl)\u27e9\n", "proof_state": "xs : List \u2115\n\u22a2 (isPermutation (\u2191(nstoogesort2' xs)) xs == true) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:998"}
{"full_name": "prop_NStoogeSort2IsSort", "prop_defn": "theorem prop_NStoogeSort2IsSort (xs: List Nat) : nstoogesort2' xs == isort xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:999", "score": 5, "deps": "import Mathlib\n\ndef third : Nat \u2192 Nat\n| 0 => 0\n| 1 => 0\n| 2 => 0\n| n + 3 => 1 + (third n)\n\n\ndef insert' : Nat \u2192 List Nat \u2192 List Nat\n| x, [] => [x]\n| x, y::xs => if x <= y then x::y::xs else y::(insert x xs)\n\n\ndef isort: List Nat \u2192 List Nat\n| [] => []\n| x::xs => insert' x (isort xs)\n\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n\n\ndef reverse : List Nat \u2192 List Nat\n| [] => []\n| x::xs => (reverse xs) ++ [x]\n\n\nlemma len_rev_eq_len {l: List Nat} : (reverse l).length = l.length := by\n  induction l with\n  | nil => simp [reverse]\n  | cons head tail ih => unfold reverse; simp [ih];\n\n\nlemma splitAt_len_le : (splitAt n xs).2.length \u2264 xs.length := by\n  induction xs generalizing n with\n  | nil => unfold splitAt; simp;\n  | cons head tail ih =>\n    cases n with\n    | zero => unfold splitAt; simp;\n    | succ nm1 => unfold splitAt; simp; apply Nat.le.step; exact ih;\n\n\nlemma splitAt_second_len_lt (n: Nat): (splitAt n.succ (x::xs)).2.length < (x::xs).length := by\n  unfold splitAt;\n  simp;\n  calc List.length (splitAt n xs).2 \u2264 (List.length xs) := splitAt_len_le\n       _                          < Nat.succ (List.length xs) := Nat.lt_succ_self _\n\n\nlemma splitAt_second_len_lt' (n: Nat) (hlen: xs.length > 0): (splitAt n.succ xs).2.length < xs.length := by\n  cases xs with\n  | nil => simp at hlen;\n  | cons x xs => exact splitAt_second_len_lt _;\n\n\nlemma splitAt_second_len_lt'' (hn: n > 0) (hlen: xs.length > 0) (hlen': xl = xs.length): (splitAt n xs).2.length < xl := by\n  cases n with\n  | zero => simp at hn;\n  | succ nm1 => rw [hlen']; exact splitAt_second_len_lt' _ hlen;\n\n\nlemma splitAt_sum_preserves_len (n: Nat) (xs: List Nat) (hspl: spl = splitAt n xs):\n  (spl.1.length + spl.2.length = xs.length) := by\n  induction xs generalizing n spl with\n  | nil => simp [splitAt] at hspl; simp [hspl];\n  | cons head tail ih => cases n with\n    | zero => simp [splitAt] at hspl; simp [hspl];\n    | succ nm1 =>\n      simp [splitAt] at hspl;\n      simp [hspl]\n      rw [Nat.succ_add];\n      apply Order.succ_eq_succ_iff.2\n      exact ih nm1 (by rfl);\n\n\nlemma third_eq_div_3 : (x/3) = third x := by\n  induction x using Nat.strongInductionOn with\n  | ind x ih =>\n  unfold third\n  match x with\n  | 0 => simp;\n  | 1 => simp;\n  | 2 => simp;\n  | n + 3 => simp [Nat.succ_eq_add_one]; ring_nf; linarith [ih n (by linarith)]\n\n\ndef nstoogesort (xs : {xs : List Nat // xs.length = n}) : {ys: List Nat // ys.length = n} := match xs with\n| \u27e8[], h\u27e9 => \u27e8[], h\u27e9\n| \u27e8[x], h\u27e9 => \u27e8[x], h\u27e9\n| \u27e8[x, y], h\u27e9 => if x <= y then \u27e8[x, y], h\u27e9 else \u27e8[y, x], by simp [\u2190h]\u27e9\n| \u27e8x1::x2::x3::xs, hlen\u27e9 =>\n  let yzs1 := splitAt (third (x1::x2::x3::xs).length) (reverse (x1::x2::x3::xs))\n  let \u27e8tmp2, hlen2\u27e9 := (@nstoogesort yzs1.2.length \u27e8yzs1.2, by rfl\u27e9)\n  let s1s2a := tmp2 ++ (reverse yzs1.1)\n  let yzs2 := splitAt (third s1s2a.length) s1s2a\n  let \u27e8tmp3, hlen3\u27e9 := (@nstoogesort yzs2.2.length \u27e8yzs2.2, by rfl\u27e9)\n  let s1s1 := yzs2.1 ++ tmp3\n  let yzs3 := splitAt (third s1s1.length) (reverse s1s1)\n  let \u27e8tmp4, hlen4\u27e9 := (@nstoogesort yzs3.2.length \u27e8yzs3.2, by rfl\u27e9)\n  \u27e8tmp4 ++ (reverse yzs3.1), by\n    simp [hlen4, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs3), len_rev_eq_len];\n    unfold_let s1s1\n    simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n    unfold_let s1s2a\n    simp [hlen2, len_rev_eq_len];\n    rw [add_comm];\n    simp [splitAt_sum_preserves_len _ _ (Eq.refl yzs1), len_rev_eq_len, hlen]\n    \u27e9\ntermination_by match xs with | \u27e8lst, _h\u27e9 => lst.length\ndecreasing_by\n  simp_wf\n  apply splitAt_second_len_lt''\n    (by simp [\u2190third_eq_div_3, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, Nat.succ_eq_add_one, Nat.add_assoc])\n    (by simp [len_rev_eq_len, hlen])\n  simp_wf\n  suffices hyzs2 : (splitAt (List.length s1s2a / 3) s1s2a).2.length < n\n  rw [List.length_append, third_eq_div_3] at hyzs2\n  exact hyzs2;\n  unfold_let s1s2a\n  suffices hyzs1 : List.length (tmp2 ++ reverse yzs1.1) = List.length xs + 3\n  exact splitAt_second_len_lt'' (by simp [hyzs1]) (by simp [hyzs1]) (by simp [hyzs1, \u2190hlen])\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n  simp_wf\n  suffices hyzs3 : (splitAt (List.length s1s1 / 3) (reverse s1s1)).2.length < n\n  unfold_let s1s1 yzs2 s1s2a yzs1 at hyzs3\n  simp [List.length_append, third_eq_div_3] at hyzs3;\n  exact hyzs3;\n  suffices hs1s1: s1s1.length = xs.length + 3\n  exact splitAt_second_len_lt'' (by simp [hs1s1]) (by simp [len_rev_eq_len, hs1s1]) (by simp [len_rev_eq_len, hs1s1, \u2190hlen])\n  unfold_let s1s1\n  simp [hlen3, splitAt_sum_preserves_len _ _ (Eq.refl yzs2)]\n  unfold_let s1s2a\n  simp [hlen2, len_rev_eq_len, Nat.add_comm, splitAt_sum_preserves_len _ _ (Eq.refl yzs1)]\n  ring_nf\n\n\ndef nstoogesort2' (xs: List Nat) := nstoogesort \u27e8xs, (by rfl)\u27e9\n", "proof_state": "xs : List \u2115\n\u22a2 (\u2191(nstoogesort2' xs) == isort xs) = true", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:999"}
{"full_name": "hpairwise_desc", "prop_defn": "theorem hpairwise_desc (ps: List MyHeap): List.length (hpairwise ps) \u2264 List.length ps := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:109", "score": 5, "deps": "import Mathlib\n\ninductive MyHeap where\n| nil : MyHeap\n| node : MyHeap \u2192 Nat \u2192 MyHeap  \u2192  MyHeap\n\n\ndef hmerge : MyHeap  \u2192 MyHeap  \u2192 MyHeap\n| MyHeap.nil, q => q\n| p, MyHeap.nil => p\n| MyHeap.node p x q, MyHeap.node r y s =>\n  if x <= y then MyHeap.node (hmerge q (MyHeap.node r y s)) x p\n            else MyHeap.node (hmerge (MyHeap.node p x q) s) y r\n\n\ndef hpairwise : List MyHeap \u2192 List MyHeap\n| p::q::qs => (hmerge p q)::hpairwise qs\n| ps => ps\n", "proof_state": "ps : List MyHeap\n\u22a2 (hpairwise ps).length \u2264 ps.length", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:120"}
{"full_name": "numElem_lt_subHeaps", "prop_defn": "theorem numElem_lt_subHeaps  (q r: MyHeap) {x: Nat}: numElem q < numElem (MyHeap.node q x r) \u2227 numElem r < numElem (MyHeap.node q x r) := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:140", "score": 5, "deps": "import Mathlib\n\ninductive MyHeap where\n| nil : MyHeap\n| node : MyHeap \u2192 Nat \u2192 MyHeap  \u2192  MyHeap\n\n\ndef numElem : MyHeap \u2192 Nat\n| MyHeap.nil => 0\n| MyHeap.node p _x q => 1 + numElem p + numElem q\n", "proof_state": "q r : MyHeap\nx : \u2115\n\u22a2 numElem q < numElem (q.node x r) \u2227 numElem r < numElem (q.node x r)", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:143"}
{"full_name": "merge_elems", "prop_defn": "theorem merge_elems (p q: MyHeap): numElem p + numElem q = numElem (hmerge p q) := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:145", "score": 5, "deps": "import Mathlib\n\ninductive MyHeap where\n| nil : MyHeap\n| node : MyHeap \u2192 Nat \u2192 MyHeap  \u2192  MyHeap\n\n\ndef hmerge : MyHeap  \u2192 MyHeap  \u2192 MyHeap\n| MyHeap.nil, q => q\n| p, MyHeap.nil => p\n| MyHeap.node p x q, MyHeap.node r y s =>\n  if x <= y then MyHeap.node (hmerge q (MyHeap.node r y s)) x p\n            else MyHeap.node (hmerge (MyHeap.node p x q) s) y r\n\n\ndef numElem : MyHeap \u2192 Nat\n| MyHeap.nil => 0\n| MyHeap.node p _x q => 1 + numElem p + numElem q\n", "proof_state": "p q : MyHeap\n\u22a2 numElem p + numElem q = numElem (hmerge p q)", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:177"}
{"full_name": "numElem_merge_branches_lt", "prop_defn": "theorem numElem_merge_branches_lt (p q: MyHeap) (x: Nat): numElem (hmerge p q) < numElem (MyHeap.node p x q) := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:179", "score": 5, "deps": "import Mathlib\n\ninductive MyHeap where\n| nil : MyHeap\n| node : MyHeap \u2192 Nat \u2192 MyHeap  \u2192  MyHeap\n\n\ndef hmerge : MyHeap  \u2192 MyHeap  \u2192 MyHeap\n| MyHeap.nil, q => q\n| p, MyHeap.nil => p\n| MyHeap.node p x q, MyHeap.node r y s =>\n  if x <= y then MyHeap.node (hmerge q (MyHeap.node r y s)) x p\n            else MyHeap.node (hmerge (MyHeap.node p x q) s) y r\n\n\ndef numElem : MyHeap \u2192 Nat\n| MyHeap.nil => 0\n| MyHeap.node p _x q => 1 + numElem p + numElem q\n", "proof_state": "p q : MyHeap\nx : \u2115\n\u22a2 numElem (hmerge p q) < numElem (p.node x q)", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:183"}
{"full_name": "len_pairwise", "prop_defn": "theorem len_pairwise (xs: List (List Nat)): 2 * (pairwise xs).length = (if (Odd xs.length) then xs.length + 1 else xs.length) := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:241", "score": 5, "deps": "import Mathlib\n\ndef lmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => if  x <= y  then\n      x::(lmerge xs (y::ys))\n    else\n      y::(lmerge (x::xs) ys)\n\n\ndef pairwise : List (List Nat) \u2192 List (List Nat)\n| xs::ys::xss => lmerge xs ys :: pairwise xss\n| xss => xss\n", "proof_state": "xs : List (List \u2115)\n\u22a2 2 * (pairwise xs).length = if Odd xs.length then xs.length + 1 else xs.length", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:286"}
{"full_name": "merge_term", "prop_defn": "theorem merge_term : (pairwise (xs::ys::xss)).length < (xs::ys::xss).length := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:288", "score": 5, "deps": "import Mathlib\n\ndef lmerge : List Nat \u2192 List Nat \u2192 List Nat\n| [], ys => ys\n| xs, [] => xs\n| x::xs, y::ys => if  x <= y  then\n      x::(lmerge xs (y::ys))\n    else\n      y::(lmerge (x::xs) ys)\n\n\ndef pairwise : List (List Nat) \u2192 List (List Nat)\n| xs::ys::xss => lmerge xs ys :: pairwise xss\n| xss => xss\n", "proof_state": "xs ys : List \u2115\nxss : List (List \u2115)\n\u22a2 (pairwise (xs :: ys :: xss)).length < (xs :: ys :: xss).length", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:299"}
{"full_name": "half_lt", "prop_defn": "theorem half_lt: half x \u2264 x := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:382", "score": 5, "deps": "import Mathlib\n\ndef half : Nat \u2192 Nat\n| 0 => 0\n| 1 => 0\n| x + 2 => 1 + (half x)\n", "proof_state": "x : \u2115\n\u22a2 half x \u2264 x", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:395"}
{"full_name": "len_evens_le", "prop_defn": "theorem len_evens_le {xs: List Nat}: (evens xs).length \u2264 xs.length := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:435", "score": 5, "deps": "import Mathlib\n\nmutual\n  def evens : List Nat \u2192 List Nat\n  | [] => []\n  | x::xs => x::(odds xs)\n--\n  def odds : List Nat \u2192 List Nat\n  | [] => []\n  | _x::xs => evens xs\nend\n", "proof_state": "xs : List \u2115\n\u22a2 (evens xs).length \u2264 xs.length", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:451"}
{"full_name": "len_odds_le", "prop_defn": "theorem len_odds_le {xs: List Nat}: (odds xs).length \u2264 xs.length := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:453", "score": 5, "deps": "import Mathlib\n\nmutual\n  def evens : List Nat \u2192 List Nat\n  | [] => []\n  | x::xs => x::(odds xs)\n--\n  def odds : List Nat \u2192 List Nat\n  | [] => []\n  | _x::xs => evens xs\nend\n", "proof_state": "xs : List \u2115\n\u22a2 (odds xs).length \u2264 xs.length", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:469"}
{"full_name": "bmerge_term", "prop_defn": "theorem bmerge_term (a b: Nat) (as bs: List Nat) (hlen: \u00ac(List.length as == 0 && List.length bs == 0) = true): List.length (evens (a :: as)) + List.length (evens (b :: bs)) < Nat.succ (List.length as) + Nat.succ (List.length bs) := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:482", "score": 5, "deps": "import Mathlib\n\nmutual\n  def evens : List Nat \u2192 List Nat\n  | [] => []\n  | x::xs => x::(odds xs)\n--\n  def odds : List Nat \u2192 List Nat\n  | [] => []\n  | _x::xs => evens xs\nend\n", "proof_state": "a b : \u2115\nas bs : List \u2115\nhlen : \u00ac(as.length == 0 && bs.length == 0) = true\n\u22a2 (evens (a :: as)).length + (evens (b :: bs)).length < as.length.succ + bs.length.succ", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:493"}
{"full_name": "bmerge_term2", "prop_defn": "theorem bmerge_term2 (x y: Nat) (xs ys: List Nat) : List.length (odds (x :: xs)) + List.length (odds (y :: ys)) < Nat.succ (List.length xs) + Nat.succ (List.length ys) := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:495", "score": 5, "deps": "import Mathlib\n\nmutual\n  def evens : List Nat \u2192 List Nat\n  | [] => []\n  | x::xs => x::(odds xs)\n--\n  def odds : List Nat \u2192 List Nat\n  | [] => []\n  | _x::xs => evens xs\nend\n", "proof_state": "x y : \u2115\nxs ys : List \u2115\n\u22a2 (odds (x :: xs)).length + (odds (y :: ys)).length < xs.length.succ + ys.length.succ", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:497"}
{"full_name": "bsort_term1", "prop_defn": "theorem bsort_term1 (x y: Nat) (xs: List Nat): List.length (evens (x :: y :: xs)) < Nat.succ (Nat.succ (List.length xs)) := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:509", "score": 5, "deps": "import Mathlib\n\nmutual\n  def evens : List Nat \u2192 List Nat\n  | [] => []\n  | x::xs => x::(odds xs)\n--\n  def odds : List Nat \u2192 List Nat\n  | [] => []\n  | _x::xs => evens xs\nend\n", "proof_state": "x y : \u2115\nxs : List \u2115\n\u22a2 (evens (x :: y :: xs)).length < xs.length.succ.succ", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:513"}
{"full_name": "bsort_term2", "prop_defn": "theorem bsort_term2 (x y: Nat) (xs: List Nat): List.length (odds (x :: y :: xs)) < Nat.succ (Nat.succ (List.length xs)) := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:515", "score": 5, "deps": "import Mathlib\n\nmutual\n  def evens : List Nat \u2192 List Nat\n  | [] => []\n  | x::xs => x::(odds xs)\n--\n  def odds : List Nat \u2192 List Nat\n  | [] => []\n  | _x::xs => evens xs\nend\n", "proof_state": "x y : \u2115\nxs : List \u2115\n\u22a2 (odds (x :: y :: xs)).length < xs.length.succ.succ", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:519"}
{"full_name": "filter_len_le", "prop_defn": "theorem filter_len_le {f: Nat \u2192 Bool} {xs: List Nat}: (filter xs f).length <= xs.length := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:539", "score": 5, "deps": "import Mathlib\n\ndef filter : List Nat \u2192 (Nat \u2192 Bool) \u2192 List Nat\n| [], _f => []\n| x::xs, f => if f x then x::(filter xs f) else (filter xs f)\n", "proof_state": "f : \u2115 \u2192 Bool\nxs : List \u2115\n\u22a2 (filter xs f).length \u2264 xs.length", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:553"}
{"full_name": "qsort_term", "prop_defn": "theorem qsort_term (x:Nat) (xs: List Nat) : List.length (filter xs fun y => decide (y \u2264 x)) < Nat.succ (List.length xs) := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:556", "score": 5, "deps": "import Mathlib\n\ndef filter : List Nat \u2192 (Nat \u2192 Bool) \u2192 List Nat\n| [], _f => []\n| x::xs, f => if f x then x::(filter xs f) else (filter xs f)\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (filter xs fun y => decide (y \u2264 x)).length < xs.length.succ", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:557"}
{"full_name": "qsort_term2", "prop_defn": "theorem qsort_term2 (x:Nat) (xs: List Nat) : List.length (filter xs fun y => decide (y > x)) < Nat.succ (List.length xs) := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:559", "score": 5, "deps": "import Mathlib\n\ndef filter : List Nat \u2192 (Nat \u2192 Bool) \u2192 List Nat\n| [], _f => []\n| x::xs, f => if f x then x::(filter xs f) else (filter xs f)\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 (filter xs fun y => decide (y > x)).length < xs.length.succ", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:560"}
{"full_name": "min_in_list", "prop_defn": "theorem min_in_list : minimum x xs \u2208 (x::xs) := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:579", "score": 5, "deps": "import Mathlib\n\ndef minimum : Nat \u2192 List Nat \u2192 Nat\n| x, [] => x\n| x, y::ys => if y <= x then minimum y ys else minimum x ys\n", "proof_state": "x : \u2115\nxs : List \u2115\n\u22a2 minimum x xs \u2208 x :: xs", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:590"}
{"full_name": "delete_len_eq", "prop_defn": "theorem delete_len_eq {x: Nat} {xs: List Nat} (h: x \u2208 xs): (deleteFirst x xs).length + 1 = xs.length := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:592", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n", "proof_state": "x : \u2115\nxs : List \u2115\nh : x \u2208 xs\n\u22a2 (deleteFirst x xs).length + 1 = xs.length", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:610"}
{"full_name": "len_rev_eq_len", "prop_defn": "theorem len_rev_eq_len {l: List Nat} : (reverse l).length = l.length := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:664", "score": 5, "deps": "import Mathlib\n\ndef reverse : List Nat \u2192 List Nat\n| [] => []\n| x::xs => (reverse xs) ++ [x]\n", "proof_state": "l : List \u2115\n\u22a2 (reverse l).length = l.length", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:667"}
{"full_name": "splitAt_len_le", "prop_defn": "theorem splitAt_len_le {xs: List Nat}: (splitAt n xs).2.length \u2264 xs.length := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:669", "score": 5, "deps": "import Mathlib\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n", "proof_state": "n : \u2115\nxs : List \u2115\n\u22a2 (splitAt n xs).2.length \u2264 xs.length", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:675"}
{"full_name": "splitAt_second_len_lt", "prop_defn": "theorem splitAt_second_len_lt (n: Nat): (splitAt n.succ (x::xs)).2.length < (x::xs).length := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:677", "score": 5, "deps": "import Mathlib\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n", "proof_state": "x : \u2115\nxs : List \u2115\nn : \u2115\n\u22a2 (splitAt n.succ (x :: xs)).2.length < (x :: xs).length", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:681"}
{"full_name": "splitAt_second_len_lt'", "prop_defn": "theorem splitAt_second_len_lt' {xs: List Nat} (n: Nat) (hlen: xs.length > 0): (splitAt n.succ xs).2.length < xs.length := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:683", "score": 5, "deps": "import Mathlib\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n", "proof_state": "xs : List \u2115\nn : \u2115\nhlen : xs.length > 0\n\u22a2 (splitAt n.succ xs).2.length < xs.length", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:686"}
{"full_name": "splitAt_second_len_lt''", "prop_defn": "theorem splitAt_second_len_lt'' {xs: List Nat} (hn: n > 0) (hlen: xs.length > 0) (hlen': xl = xs.length): (splitAt n xs).2.length < xl := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:688", "score": 5, "deps": "import Mathlib\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n", "proof_state": "n xl : \u2115\nxs : List \u2115\nhn : n > 0\nhlen : xs.length > 0\nhlen' : xl = xs.length\n\u22a2 (splitAt n xs).2.length < xl", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:691"}
{"full_name": "splitAt_sum_preserves_len", "prop_defn": "theorem splitAt_sum_preserves_len (n: Nat) (xs: List Nat) (hspl: spl = splitAt n xs): (spl.1.length + spl.2.length = xs.length) := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:693", "score": 5, "deps": "import Mathlib\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n", "proof_state": "spl : List \u2115 \u00d7 List \u2115\nn : \u2115\nxs : List \u2115\nhspl : spl = splitAt n xs\n\u22a2 spl.1.length + spl.2.length = xs.length", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:703"}
{"full_name": "splitAt_first_len_lt", "prop_defn": "theorem splitAt_first_len_lt {xs: List Nat} (hn: n < xl) (hlen': xl = xs.length): (splitAt n xs).1.length < xl := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:771", "score": 5, "deps": "import Mathlib\n\ndef splitAt : Nat \u2192 List Nat \u2192 (List Nat \u00d7 List Nat)\n| _n, [] => ([], [])\n| 0, xs => ([], xs)\n| n + 1, x::xs => match splitAt n xs with\n  | (l1, l2) => (x::l1, l2)\n", "proof_state": "n xl : \u2115\nxs : List \u2115\nhn : n < xl\nhlen' : xl = xs.length\n\u22a2 (splitAt n xs).1.length < xl", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:781"}
{"full_name": "twon_lt", "prop_defn": "theorem twon_lt (n: Nat): (2*n.succ.succ.succ + 1)/ 3 < n.succ.succ.succ := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:783", "score": 5, "deps": "import Mathlib", "proof_state": "n : \u2115\n\u22a2 (2 * n.succ.succ.succ + 1) / 3 < n.succ.succ.succ", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:789"}
{"full_name": "third_eq_div_3", "prop_defn": "theorem third_eq_div_3 : (x/3) = third x := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:854", "score": 5, "deps": "import Mathlib\n\ndef third : Nat \u2192 Nat\n| 0 => 0\n| 1 => 0\n| 2 => 0\n| n + 3 => 1 + (third n)\n", "proof_state": "x : \u2115\n\u22a2 x / 3 = third x", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:862"}
{"full_name": "twon_lt'", "prop_defn": "theorem twon_lt' (n: Nat): twoThirds (n.succ.succ.succ) < n.succ.succ.succ := by sorry", "prop_loc": "LeanSrc/LeanSrc/Sorts.lean:927", "score": 5, "deps": "import Mathlib\n\ndef twoThirds : Nat \u2192 Nat\n| 0 => 0\n| 1 => 0\n| 2 => 0\n| n + 3 => 2 + (twoThirds n)\n", "proof_state": "n : \u2115\n\u22a2 twoThirds n.succ.succ.succ < n.succ.succ.succ", "file_locs": "LeanSrc/LeanSrc/Sorts.lean:935"}
{"full_name": "prop_Select", "prop_defn": "theorem prop_Select (xs: List \u03b1) [DecidableEq \u03b1] :\n  List.map Prod.fst (select xs) == xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:372", "score": 5, "deps": "import Mathlib\n\ndef select : List \u03b1 \u2192 List (\u03b1 \u00d7 (List \u03b1))\n  | [] => []\n  | x :: xs =>\n    \u27e8x, xs\u27e9:: List.map (fun (p: \u03b1 \u00d7 (List \u03b1))  => (p.1, x::p.2)) (select xs)\n", "proof_state": "\u03b1 : Type u_1\nxs : List \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 (List.map Prod.fst (select xs) == xs) = true", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 279], ["LeanSrc/LeanSrc/Properties.lean", 373]]}
{"full_name": "prop_SelectPermutations", "prop_defn": "theorem prop_SelectPermutations (xs: List \u03b1) [DecidableEq \u03b1] :\n  (List.all\n    (List.map\n      (fun (p: \u03b1 \u00d7 List \u03b1) => isPermutation xs (p.1::p.2))\n      (select xs)\n    )\n    (fun x => x)\n  ):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:376", "score": 5, "deps": "import Mathlib\n\ndef select : List \u03b1 \u2192 List (\u03b1 \u00d7 (List \u03b1))\n  | [] => []\n  | x :: xs =>\n    \u27e8x, xs\u27e9:: List.map (fun (p: \u03b1 \u00d7 (List \u03b1))  => (p.1, x::p.2)) (select xs)\n\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n", "proof_state": "\u03b1 : Type u_1\nxs : List \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 ((List.map (fun p => isPermutation xs (p.1 :: p.2)) (select xs)).all fun x => x) = true", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 331], ["LeanSrc/LeanSrc/Properties.lean", 383]]}
{"full_name": "prop_SelectPermutations'", "prop_defn": "theorem prop_SelectPermutations' (xs: List \u03b1) (z: \u03b1) [DecidableEq \u03b1] :\n  let n := count z xs\n  (List.all\n    (List.map\n      (fun (p: \u03b1 \u00d7 List \u03b1) => n == (count z (p.1::p.2)))\n      (select xs)\n    )\n    (fun x => x)\n  ):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:386", "score": 5, "deps": "import Mathlib\n\ndef select : List \u03b1 \u2192 List (\u03b1 \u00d7 (List \u03b1))\n  | [] => []\n  | x :: xs =>\n    \u27e8x, xs\u27e9:: List.map (fun (p: \u03b1 \u00d7 (List \u03b1))  => (p.1, x::p.2)) (select xs)\n\n\ndef count [DecidableEq \u03b1]: \u03b1 -> List \u03b1 -> Nat\n  | _z, []    => 0\n  | z,  x::xs => if x==z then (count z xs).succ else count z xs\n", "proof_state": "\u03b1 : Type u_1\nxs : List \u03b1\nz : \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 let n := count z xs;\n  ((List.map (fun p => n == count z (p.1 :: p.2)) (select xs)).all fun x => x) = true", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 311], ["LeanSrc/LeanSrc/Properties.lean", 394]]}
{"full_name": "prop_PairUnpair", "prop_defn": "theorem prop_PairUnpair (xs: List \u03b1) [DecidableEq \u03b1] :\n  Even (xs.length) \u2192 ((unpair (pairs xs)) == xs):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:397", "score": 5, "deps": "import Mathlib\n\ndef pairs : List \u03b1 \u2192 List (\u03b1 \u00d7 \u03b1)\n  | x::y::xs => (x, y):: (pairs xs)\n  | _ => []\n\n\ndef unpair : List (\u03b1 \u00d7 \u03b1) \u2192 List \u03b1\n  | [] => []\n  | (x, y)::xs => x :: y :: (unpair xs)\n", "proof_state": "\u03b1 : Type u_1\nxs : List \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 Even xs.length \u2192 (unpair (pairs xs) == xs) = true", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 287], ["LeanSrc/LeanSrc/Properties.lean", 398]]}
{"full_name": "prop_PairEvens", "prop_defn": "theorem prop_PairEvens (xs: List \u03b1) [DecidableEq \u03b1] :\n  Even (xs.length) \u2192 List.map Prod.fst (pairs xs) == evens xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:401", "score": 5, "deps": "import Mathlib\n\ndef pairs : List \u03b1 \u2192 List (\u03b1 \u00d7 \u03b1)\n  | x::y::xs => (x, y):: (pairs xs)\n  | _ => []\n\n\nmutual\n  def evens : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | x::xs => x::(odds xs)\n  def odds : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | _x::xs => evens xs\nend\n", "proof_state": "\u03b1 : Type u_1\nxs : List \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 Even xs.length \u2192 (List.map Prod.fst (pairs xs) == evens xs) = true", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 297], ["LeanSrc/LeanSrc/Properties.lean", 402]]}
{"full_name": "prop_PairOdds", "prop_defn": "theorem prop_PairOdds (xs: List \u03b1) [DecidableEq \u03b1] :\n  List.map Prod.snd (pairs xs) == odds xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:405", "score": 5, "deps": "import Mathlib\n\ndef pairs : List \u03b1 \u2192 List (\u03b1 \u00d7 \u03b1)\n  | x::y::xs => (x, y):: (pairs xs)\n  | _ => []\n\n\nmutual\n  def evens : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | x::xs => x::(odds xs)\n  def odds : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | _x::xs => evens xs\nend\n", "proof_state": "\u03b1 : Type u_1\nxs : List \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 (List.map Prod.snd (pairs xs) == odds xs) = true", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 297], ["LeanSrc/LeanSrc/Properties.lean", 406]]}
{"full_name": "prop_interleave", "prop_defn": "theorem prop_interleave (xs: List \u03b1) [DecidableEq \u03b1] :\n  interleave (evens xs) (odds xs) == xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:409", "score": 5, "deps": "import Mathlib\n\nmutual\n  def evens : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | x::xs => x::(odds xs)\n  def odds : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | _x::xs => evens xs\nend\n\n\ndef interleave : List \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | (x::xs), ys => x :: interleave ys xs\n  | [],      ys => ys\ntermination_by xs ys => xs.length + ys.length\n", "proof_state": "\u03b1 : Type u_1\nxs : List \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 (interleave (evens xs) (odds xs) == xs) = true", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 302], ["LeanSrc/LeanSrc/Properties.lean", 410]]}
{"full_name": "prop_append_inj_1", "prop_defn": "theorem prop_append_inj_1 (xs ys zs: List \u03b1) [DecidableEq \u03b1] :\n  (xs ++ zs == ys ++ zs) \u2192 xs == ys:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:414", "score": 3, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\nxs ys zs : List \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 (xs ++ zs == ys ++ zs) = true \u2192 (xs == ys) = true", "file_locs": [["LeanSrc/LeanSrc/Properties.lean", 415]]}
{"full_name": "prop_append_inj_2", "prop_defn": "theorem prop_append_inj_2 (xs ys zs: List \u03b1) [DecidableEq \u03b1] :\n  (xs ++ ys == xs ++ zs) \u2192 ys == zs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:418", "score": 3, "deps": "import Mathlib", "proof_state": "\u03b1 : Type u_1\nxs ys zs : List \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 (xs ++ ys == xs ++ zs) = true \u2192 (ys == zs) = true", "file_locs": [["LeanSrc/LeanSrc/Properties.lean", 419]]}
{"full_name": "prop_nub_nub", "prop_defn": "theorem prop_nub_nub (xs: List \u03b1) [DecidableEq \u03b1] :\n  nub (nub xs) == nub xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:422", "score": 5, "deps": "import Mathlib\n\ndef nub [DecidableEq \u03b1]: List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | x::xs => x::(nub (xs.filter (fun y => x != y)))\ntermination_by xs => xs.length\ndecreasing_by\n  simp_wf\n  rw [Nat.lt_succ]\n  exact List.length_filter_le _ xs\n", "proof_state": "\u03b1 : Type u_1\nxs : List \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 (nub (nub xs) == nub xs) = true", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 322], ["LeanSrc/LeanSrc/Properties.lean", 423]]}
{"full_name": "prop_elem_nub_l", "prop_defn": "theorem prop_elem_nub_l (x: \u03b1) (xs: List \u03b1) [DecidableEq \u03b1] :\n  x \u2208 xs \u2192 x \u2208 nub xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:426", "score": 5, "deps": "import Mathlib\n\ndef nub [DecidableEq \u03b1]: List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | x::xs => x::(nub (xs.filter (fun y => x != y)))\ntermination_by xs => xs.length\ndecreasing_by\n  simp_wf\n  rw [Nat.lt_succ]\n  exact List.length_filter_le _ xs\n", "proof_state": "\u03b1 : Type u_1\nx : \u03b1\nxs : List \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 x \u2208 xs \u2192 x \u2208 nub xs", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 322], ["LeanSrc/LeanSrc/Properties.lean", 427]]}
{"full_name": "prop_elem_nub_r", "prop_defn": "theorem prop_elem_nub_r (x: \u03b1) (xs: List \u03b1) [DecidableEq \u03b1] :\n  x \u2208 nub xs \u2192 x \u2208 xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:430", "score": 5, "deps": "import Mathlib\n\ndef nub [DecidableEq \u03b1]: List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | x::xs => x::(nub (xs.filter (fun y => x != y)))\ntermination_by xs => xs.length\ndecreasing_by\n  simp_wf\n  rw [Nat.lt_succ]\n  exact List.length_filter_le _ xs\n", "proof_state": "\u03b1 : Type u_1\nx : \u03b1\nxs : List \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 x \u2208 nub xs \u2192 x \u2208 xs", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 322], ["LeanSrc/LeanSrc/Properties.lean", 431]]}
{"full_name": "prop_count_nub", "prop_defn": "theorem prop_count_nub (x: \u03b1) (xs: List \u03b1) [DecidableEq \u03b1] :\n  x \u2208 xs \u2192 (count x (nub xs) == 1):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:434", "score": 5, "deps": "import Mathlib\n\ndef count [DecidableEq \u03b1]: \u03b1 -> List \u03b1 -> Nat\n  | _z, []    => 0\n  | z,  x::xs => if x==z then (count z xs).succ else count z xs\n\n\ndef nub [DecidableEq \u03b1]: List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | x::xs => x::(nub (xs.filter (fun y => x != y)))\ntermination_by xs => xs.length\ndecreasing_by\n  simp_wf\n  rw [Nat.lt_succ]\n  exact List.length_filter_le _ xs\n", "proof_state": "\u03b1 : Type u_1\nx : \u03b1\nxs : List \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 x \u2208 xs \u2192 (count x (nub xs) == 1) = true", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 322], ["LeanSrc/LeanSrc/Properties.lean", 435]]}
{"full_name": "prop_perm_trans", "prop_defn": "theorem prop_perm_trans (xs ys zs: List \u03b1) [DecidableEq \u03b1] :\n  isPermutation xs ys \u2192 isPermutation ys zs \u2192 isPermutation xs zs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:438", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n", "proof_state": "\u03b1 : Type u_1\nxs ys zs : List \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 isPermutation xs ys = true \u2192 isPermutation ys zs = true \u2192 isPermutation xs zs = true", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 331], ["LeanSrc/LeanSrc/Properties.lean", 439]]}
{"full_name": "prop_perm_refl", "prop_defn": "theorem prop_perm_refl (xs: List \u03b1) [DecidableEq \u03b1] :\n  isPermutation xs xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:442", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n", "proof_state": "\u03b1 : Type u_1\nxs : List \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 isPermutation xs xs = true", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 331], ["LeanSrc/LeanSrc/Properties.lean", 443]]}
{"full_name": "prop_perm_symm", "prop_defn": "theorem prop_perm_symm (xs ys: List \u03b1) [DecidableEq \u03b1] :\n  isPermutation xs ys \u2192 isPermutation ys xs:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:446", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n", "proof_state": "\u03b1 : Type u_1\nxs ys : List \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 isPermutation xs ys = true \u2192 isPermutation ys xs = true", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 331], ["LeanSrc/LeanSrc/Properties.lean", 447]]}
{"full_name": "prop_perm_elem", "prop_defn": "theorem prop_perm_elem (x: \u03b1) (xs ys: List \u03b1) [DecidableEq \u03b1] :\n  x \u2208 xs \u2192 isPermutation xs ys \u2192 x \u2208 ys:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:450", "score": 5, "deps": "import Mathlib\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n\n\ndef isPermutation [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n| [], ys => (ys == [])\n| x::xs, ys => x \u2208 ys && (isPermutation xs (deleteFirst x ys))\n", "proof_state": "\u03b1 : Type u_1\nx : \u03b1\nxs ys : List \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 x \u2208 xs \u2192 isPermutation xs ys = true \u2192 x \u2208 ys", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 331], ["LeanSrc/LeanSrc/Properties.lean", 451]]}
{"full_name": "prop_deleteAll_count", "prop_defn": "theorem prop_deleteAll_count (x: \u03b1) (xs: List \u03b1) [DecidableEq \u03b1]:\n  (delete x xs == deleteFirst x xs) \u2192 count x xs <= 1:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:454", "score": 5, "deps": "import Mathlib\n\ndef delete [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then (delete n xs) else x::(delete n xs)\n\n\ndef count [DecidableEq \u03b1]: \u03b1 -> List \u03b1 -> Nat\n  | _z, []    => 0\n  | z,  x::xs => if x==z then (count z xs).succ else count z xs\n\n\ndef deleteFirst [DecidableEq \u03b1]: \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | _, [] => []\n  | n, x::xs => if n == x then xs else x::(deleteFirst n xs)\n", "proof_state": "\u03b1 : Type u_1\nx : \u03b1\nxs : List \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 (delete x xs == deleteFirst x xs) = true \u2192 count x xs \u2264 1", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 326], ["LeanSrc/LeanSrc/Properties.lean", 455]]}
{"full_name": "prop_elem", "prop_defn": "theorem prop_elem (x: \u03b1) (xs: List \u03b1) [DecidableEq \u03b1] :\n  x \u2208 xs \u2192 \u2203i, x == at' xs i:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:458", "score": 5, "deps": "import Mathlib\n\ndef at' : List \u03b1 \u2192 Nat \u2192 Option \u03b1\n  | x::_, 0 => x\n  | _::xs, n => at' xs (n - 1)\n  | [], _ => none\n", "proof_state": "\u03b1 : Type u_1\nx : \u03b1\nxs : List \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 x \u2208 xs \u2192 \u2203 i, (some x == at' xs i) = true", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 307], ["LeanSrc/LeanSrc/Properties.lean", 459]]}
{"full_name": "prop_elem_map", "prop_defn": "theorem prop_elem_map (y: \u03b2) (f: \u03b1 \u2192 \u03b2) (xs: List \u03b1) [DecidableEq \u03b2] :\n  y \u2208 xs.map f \u2192 (\u2203x, (f x) == y \u2227 x \u2208 xs):= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:467", "score": 5, "deps": "import Mathlib", "proof_state": "\u03b2 : Type u_1\n\u03b1 : Type u_2\ny : \u03b2\nf : \u03b1 \u2192 \u03b2\nxs : List \u03b1\ninst\u271d : DecidableEq \u03b2\n\u22a2 y \u2208 List.map f xs \u2192 \u2203 x, (f x == y) = true \u2227 x \u2208 xs", "file_locs": [["LeanSrc/LeanSrc/Properties.lean", 468]]}
{"full_name": "prop_Flatten1", "prop_defn": "theorem prop_Flatten1 (p: MyTree \u03b1) [DecidableEq \u03b1] :\n  flatten1 [p] == flatten0 p:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:474", "score": 5, "deps": "import Mathlib\n\ninductive MyTree (\u03b1: Type) where\n| leaf : MyTree \u03b1\n| node : MyTree \u03b1 \u2192 \u03b1 \u2192 MyTree \u03b1  \u2192  MyTree \u03b1\n\n\ndef f1Size : MyTree \u03b1 \u2192 Nat\n| MyTree.leaf => 1\n| MyTree.node p _x q => f1Size p + f1Size q +\n  (match p with\n    | MyTree.leaf => 0\n    | MyTree.node _a _b _c=> 2)\n\n\nlemma f1Size_gt_zero (t: MyTree \u03b1): f1Size t > 0 := by\n  induction t with\n    | leaf => simp [f1Size]\n    | node p _x q ih1 => simp [f1Size, ih1]\n\n\nlemma f1Size_lt_subTrees  (q r: MyTree \u03b1) {x: \u03b1}: f1Size q < f1Size (MyTree.node q x r) \u2227 f1Size r < f1Size (MyTree.node q x r) := by\n  simp [f1Size]\n  exact \u27e8by linarith [f1Size_gt_zero r], by linarith [f1Size_gt_zero q]\u27e9;\n\n\ndef flatten0 : MyTree \u03b1 \u2192 List \u03b1\n  | MyTree.leaf => []\n  | MyTree.node p x q => flatten0 p ++ [x] ++ flatten0 q\n\n\ndef flatten1 : List (MyTree \u03b1) \u2192 List \u03b1\n  | []                                => []\n  | MyTree.leaf::ps                   => flatten1 ps\n  | (MyTree.node MyTree.leaf x q)::ps => x::(flatten1 (q::ps))\n  | (MyTree.node (MyTree.node a b c) x q)::ps => flatten1 ((MyTree.node a b c)::(MyTree.node MyTree.leaf x q)::ps)\ntermination_by ps => List.sum (ps.map (fun (t: MyTree \u03b1 ) => f1Size t))\ndecreasing_by\n  simp_wf\n  simp [f1Size]\n  simp_wf\n  simp [f1Size_lt_subTrees]\n  simp_wf\n  simp [f1Size]\n  linarith\n", "proof_state": "\u03b1 : Type\np : MyTree \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 (flatten1 [p] == flatten0 p) = true", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 373], ["LeanSrc/LeanSrc/Properties.lean", 475]]}
{"full_name": "prop_Flatten1List", "prop_defn": "theorem prop_Flatten1List (ps: List (MyTree \u03b1)) [DecidableEq \u03b1] :\n  flatten1 ps == List.foldl (fun (ps2: List \u03b1) (t: MyTree \u03b1)  => ps2 ++ (flatten0 t) ) [] ps:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:478", "score": 5, "deps": "import Mathlib\n\ninductive MyTree (\u03b1: Type) where\n| leaf : MyTree \u03b1\n| node : MyTree \u03b1 \u2192 \u03b1 \u2192 MyTree \u03b1  \u2192  MyTree \u03b1\n\n\ndef f1Size : MyTree \u03b1 \u2192 Nat\n| MyTree.leaf => 1\n| MyTree.node p _x q => f1Size p + f1Size q +\n  (match p with\n    | MyTree.leaf => 0\n    | MyTree.node _a _b _c=> 2)\n\n\nlemma f1Size_gt_zero (t: MyTree \u03b1): f1Size t > 0 := by\n  induction t with\n    | leaf => simp [f1Size]\n    | node p _x q ih1 => simp [f1Size, ih1]\n\n\nlemma f1Size_lt_subTrees  (q r: MyTree \u03b1) {x: \u03b1}: f1Size q < f1Size (MyTree.node q x r) \u2227 f1Size r < f1Size (MyTree.node q x r) := by\n  simp [f1Size]\n  exact \u27e8by linarith [f1Size_gt_zero r], by linarith [f1Size_gt_zero q]\u27e9;\n\n\ndef flatten0 : MyTree \u03b1 \u2192 List \u03b1\n  | MyTree.leaf => []\n  | MyTree.node p x q => flatten0 p ++ [x] ++ flatten0 q\n\n\ndef flatten1 : List (MyTree \u03b1) \u2192 List \u03b1\n  | []                                => []\n  | MyTree.leaf::ps                   => flatten1 ps\n  | (MyTree.node MyTree.leaf x q)::ps => x::(flatten1 (q::ps))\n  | (MyTree.node (MyTree.node a b c) x q)::ps => flatten1 ((MyTree.node a b c)::(MyTree.node MyTree.leaf x q)::ps)\ntermination_by ps => List.sum (ps.map (fun (t: MyTree \u03b1 ) => f1Size t))\ndecreasing_by\n  simp_wf\n  simp [f1Size]\n  simp_wf\n  simp [f1Size_lt_subTrees]\n  simp_wf\n  simp [f1Size]\n  linarith\n", "proof_state": "\u03b1 : Type\nps : List (MyTree \u03b1)\ninst\u271d : DecidableEq \u03b1\n\u22a2 (flatten1 ps == List.foldl (fun ps2 t => ps2 ++ flatten0 t) [] ps) = true", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 373], ["LeanSrc/LeanSrc/Properties.lean", 479]]}
{"full_name": "prop_Flatten2", "prop_defn": "theorem prop_Flatten2 (p: MyTree \u03b1) [DecidableEq \u03b1] :\n  flatten2 p [] == flatten0 p:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:482", "score": 5, "deps": "import Mathlib\n\ninductive MyTree (\u03b1: Type) where\n| leaf : MyTree \u03b1\n| node : MyTree \u03b1 \u2192 \u03b1 \u2192 MyTree \u03b1  \u2192  MyTree \u03b1\n\n\ndef flatten0 : MyTree \u03b1 \u2192 List \u03b1\n  | MyTree.leaf => []\n  | MyTree.node p x q => flatten0 p ++ [x] ++ flatten0 q\n\n\ndef flatten2 : MyTree \u03b1 -> List \u03b1 -> List \u03b1\n| MyTree.leaf, ys => ys\n| MyTree.node p x q, ys => flatten2 p (x:: flatten2 q ys)\n", "proof_state": "\u03b1 : Type\np : MyTree \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 (flatten2 p [] == flatten0 p) = true", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 377], ["LeanSrc/LeanSrc/Properties.lean", 483]]}
{"full_name": "prop_Flatten3", "prop_defn": "theorem prop_Flatten3 (p: MyTree \u03b1) [DecidableEq \u03b1] :\n  flatten3 p == flatten0 p:= by sorry", "prop_loc": "LeanSrc/LeanSrc/Properties.lean:486", "score": 5, "deps": "import Mathlib\n\ninductive MyTree (\u03b1: Type) where\n| leaf : MyTree \u03b1\n| node : MyTree \u03b1 \u2192 \u03b1 \u2192 MyTree \u03b1  \u2192  MyTree \u03b1\n\n\ndef flatten0 : MyTree \u03b1 \u2192 List \u03b1\n  | MyTree.leaf => []\n  | MyTree.node p x q => flatten0 p ++ [x] ++ flatten0 q\n\n\ndef f3Size : MyTree \u03b1 \u2192 Nat\n| MyTree.leaf => 1\n| MyTree.node p _x q => (f3Size p) * 2 + f3Size q\n\n\nlemma f3Size_gt_zero (t: MyTree \u03b1): f3Size t > 0 := by\n  induction t with\n  | leaf => simp [f3Size]\n  | node p _ q ih1 => simp [f3Size, ih1]\n\n\ndef flatten3 : MyTree \u03b1 \u2192 List \u03b1\n| MyTree.leaf => []\n| MyTree.node (MyTree.node p x q) y r => flatten3 (MyTree.node p x (MyTree.node q y r))\n| MyTree.node MyTree.leaf x q => x :: flatten3 q\ntermination_by t => f3Size t\ndecreasing_by\n  simp_wf\n  simp [f3Size]\n  linarith [f3Size_gt_zero p]\n  simp_wf\n  simp [f3Size]\n", "proof_state": "\u03b1 : Type\np : MyTree \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 (flatten3 p == flatten0 p) = true", "file_locs": [["LeanSrc/LeanSrc/Definitions.lean", 399], ["LeanSrc/LeanSrc/Properties.lean", 487]]}